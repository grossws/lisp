<!DOCTYPE html>
<html>

<head>
    <title>5 – Денотационная семантика</title>
    <link rel="stylesheet" type="text/css" href="css/zz_lisp.css"/>
</head>

<body>

<h1 id="chapter:denotational"><span class="wrap"><span class="seq">Глава 5.</span><span class="title">Денотационная семантика</span></span></h1>

<p class="noindent"><span class="initial">Э</span><span class="sc"><span class="c">та глава</span></span> начинается кратким обзором
<span class="math"><span class="ord var">λ</span></span>-исчисления, после чего переходит к денотационной семантике во всей её
красе. Мы рассмотрим ещё одно определение Лиспа — в этот раз денотационное,
— значительно отличающееся от предыдущих интерпретаторов: смысл программ
теперь будет выражаться математическими объектами — термами
<span class="math"><span class="ord var">λ</span></span>-исчисления.</p>

<div class="bigskip"/>

<!--\indexR{смысл программ}-->
<!--\indexR{программы!смысл}-->
<!--\indexR{язык!и смысл программ}-->
<p>Чем именно является программа? <em class="term">Программа</em> — это описание вычислений,
которые приводят к определённому результату: значению и/или эффекту.</p>

<p>Очень часто программу путают с её исполнимым воплощением для той или иной
машины; аналогично, определением программы часто считают файл с её исходным
кодом; но всё это совершенно различные понятия.</p>

<p>Программы записываются на некотором <em class="term">языке</em>; определение этого языка
придаёт корректным программам <em class="term">смысл</em>. Смысл программы — это не только и
не столько результаты вычислений, так как они зависят от введённых данных, от
событий во внешнем мире, от действий других программ. Смысл программы — это
нечто большее, это суть проводимых вычислений.</p>

<p>Если мы хотим как-то изучать смысл программ и обрабатывать их, то они обязаны
иметь математическое представление. Возьмём любое преобразование, например,
перевод программы в «коробочный стиль» из предыдущей главы.
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.html#ch4-box-transform">4.1.1</a>]</span>
Как мы можем быть уверены, что
после подобной операции смысл программы останется неизменным? Только с помощью
тысячелетнего опыта математики — науки об отношениях, структуре и
преобразованиях. А для этого необходимо связать смысл программ с математическими
объектами. Такой подход кажется вполне разумным и полезным: например, если бы
функция <code><span class="func">fact</span></code> выражалась буквально через факториал,
то стало бы гораздо проще убедиться в том, что она вычисляет именно факториал, или что другие
функции, вроде <code><span class="func">meta-fact</span></code>
<span class="see">[см. раздел <a href="ch02_lisp_1_2_omega.html#lisp1-2-omega/recursion/y-combinator/code:meta-fact">2.6.6</a>]</span>, действительно ей
эквивалентны.</p>

<p>Для определения смысла программы необходим её математический эквивалент, а для
его построения нам надо в точности знать свойства языка, на котором написана
программа. В общем, проблема сводится к отысканию способа построения
математических эквивалентов всех конструкций языка. То есть к формализации его
<em class="term">семантики</em>. Семантика языка программирования даёт нам его полное
понимание: мы можем реализовать язык на чём угодно, мы можем доказывать
правильность программ и их преобразований, мы можем сравнивать языки между собой
и многое другое. Применений семантики великое множество, но не только она одна
даёт такие возможности.</p>

<!--\indexR{эталонная реализация}-->
<p>Одним из древнейших способов определения языков является предоставление
<em class="term">эталонной реализации</em>. Когда необходима некая информация о языке,
например, последствия выполнения какой-либо программы, то эту программу можно
передать эталонной реализации и получить ответ: каким должно быть возвращаемое
значение или побочные эффекты. Но, как и с любым чёрным ящиком, очень непросто
построить полную теорию его работы, пользуясь лишь подобными наблюдениями. Если
мы решим открыть ящик, то внутри окажется ещё одна программа на каком-то языке,
что возвращает нас к исходному вопросу о смысле программ.</p>

<!--\indexR{виртуальная машина}-->
<p>Следующий подход основывается на идее <em class="term">виртуальной машины</em>. Это не решает
проблему одним махом, но разделяет её на две проблемы поменьше. Сначала нам
необходимо описать конструкции языка с помощью ограниченного числа операций
вычислительной машины определённой архитектуры. После этого остаётся только
понять, как работает данная машина. Сама виртуальная машина является формальной
абстракцией, так что может быть реализована на любой реальной вычислительной
машине.</p>

<p>Многие языки определяются именно таким образом: PL/I (на VDM), PSL <span class="cite">[<a href="z1_bibliography.html#gbm82">GBM82</a>]</span>,
Le_Lisp (на LLM3 <span class="cite">[<a href="z1_bibliography.html#cha80">Cha80</a>]</span>), Gambit поверх PVM <span class="cite">[<a href="z1_bibliography.html#fm90">FM90</a>]</span>.</p>

<!--\indexR{семантика!операционная}-->
<p>Главная проблема — это разработать хорошую виртуальную машину. Это не так
легко, как кажется: она должна одновременно подходить для языка, быть простой
в использовании и тривиальной в реализации. На выбор есть множество вариантов:
стековые машины, регистровые, основанные на деревьях, графах — в общем, всё,
что душе угодно. (Здесь мы сначала выбираем язык ассемблера, а затем подгоняем
под него архитектуру машины.) В этом случае сравнение программ сводится
к сравнению соответствующих им машинных кодов или же хода их исполнения машиной.
Так как в итоге всё упирается в работу вычислительной машины, виртуальной или
реальной, то подобный способ определения языка называется <em class="term">операционной
семантикой</em>.</p>

<!--\indexR{денотация!определение}-->
<p>Но у данного способа есть врождённый недостаток: ему необходима специальная
вычислительная машина; иными словами, формальная теория вычислений. Если
в качестве такой теории взять какую-нибудь простую, всем понятную концепцию, то
можно избавиться от поддержки зоопарка всевозможных машин. Программа — это,
прежде всего, функция, преобразующая входные данные в выходные. В этом случае
не требуется сложная машина: математика веками оттачивала такой способ
«исполнения программ», называя его «применением функций». Таким образом,
идея состоит в том, чтобы преобразовать программу в функцию (из определённого
множества функций). Подобная функция называется <em class="term">денотацией</em> программы.
Теперь остаётся только определить вышеупомянутое множество.</p>

<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление}-->
<!--\indexR{лямбда-терм@$\lambda$-терм}-->
<!--\indexR{терм!лямбда-исчисления@<span class="math"><span class="ord var">λ</span></span>-исчисления}-->
<!--\indexR{семантика!денотационная}-->
<p>Для наших целей прекрасно подойдёт <span class="math"><span class="ord var">λ</span></span>-исчисление. Его аксиомы настолько
просты, что их толкование не вызывает никаких разногласий. Таким образом,
семантику языка программирования можно понимать как способ перевода программ
в соответствующие денотации. Этот процесс, между прочим, тоже можно представить
как функцию. Денотация программы — это выражение <span class="math"><span class="ord var">λ</span></span>-исчисления
(<span class="math"><span class="ord var">λ</span></span>-терм), представляющее смысл программы. Вооружившись теорией
<span class="math"><span class="ord var">λ</span></span>-исчисления, мы теперь в состоянии сказать, эквивалентны ли две
программы, предсказать результат вычислений и т. д. Конечно, есть множество
тонкостей: используемый вариант <span class="math"><span class="ord var">λ</span></span>-исчисления, способ определения
семантической функции, преобразующей программы в денотации, и многое другое, но
общая идея — это именно то, что называется <em class="term">денотационной семантикой</em>.</p>

<!--\indexR{семантика!аксиоматическая}-->
<p>Стоит упомянуть ещё один способ понимания программ, особо полезный для
доказательства их корректности. Речь идёт об <em class="term">аксиоматической семантике</em>
Ричарда Флойда и Тони Хоара. Идея состоит в том, что для всех конструкций языка
составляются логические утверждения вида <span class="math"><span class="open">{</span><span class="ord var">P</span><span class="close">}</span><span class="ord normal"><i>форма</i></span><span class="open">{</span><span class="ord var">Q</span><span class="close">}</span></span>. Данная
формула означает, что если утверждение <span class="math"><span class="ord var">P</span></span>
истинно перед исполнением <i>формы</i>, то в результате её исполнения станет истинным
<span class="math"><span class="ord var">Q</span></span>. В итоге конструкции языка
сводятся к набору подобных утверждений-аксиом, из которых выводятся
утверждения-теоремы о поведении программ. Такой подход несомненно удобен для
доказательства корректности программ, но, к сожалению, ничего не говорит о том,
как реализовывать вычислитель для языка. Ни даже о том, возможно ли построить
такой вычислитель в принципе.</p>

<!--\indexR{семантика!естественная}-->
<!--\indexR{семантика!алгебраическая}-->
<p>Конечно же, многообразие семантик не исчерпывается перечисленными вариантами.
Например, существует <em class="term">естественная семантика</em> <span class="cite">[<a href="z1_bibliography.html#kah87">Kah87</a>]</span>, подобная
денотационной, но с большим упором на логический вывод свойств программы из
аксиом. Или <em class="term">алгебраическая семантика</em> <span class="cite">[<a href="z1_bibliography.html#ff89">FF89</a>]</span>, рассматривающая правила
эквивалентных преобразований программ.</p>


<h2 id="denotational/sect:lambda-review"><span class="wrap"><span class="seq">5.1.</span><span class="title">Краткий обзор <span class="math"><span class="ord var">λ</span></span>-исчисления</span></span></h2>

<!--\indexR{интерпретатор!в денотационной семантике}-->
<p>Суть денотационной семантики лежит в определении (специфичной для языка)
функции, называемой <em class="term">интерпретатором</em> (valuation function),
которая переводит корректную программу на языке в соответствующую денотацию —
элемент множества денотаций. В качестве подобного множества мы решили взять
<span class="math"><span class="ord var">λ</span></span>-исчисление, так как оно имеет простую структуру и довольно близко
к Scheme, который иногда так и называют «интерпретатором <span class="math"><span class="ord var">λ</span></span>-термов»
<span class="cite">[<a href="z1_bibliography.html#ss75">SS75</a>,
<a href="z1_bibliography.html#wan84">Wan84</a>]</span>.</p>

<!--\indexR{абстракция}-->
<!--\indexR{аппликация}-->
<p>Сейчас мы быстро пробежимся по основам <span class="math"><span class="ord var">λ</span></span>-исчисления.<a class="footref"
href="zz_footnotes.html#foot5.1"><sup>1</sup></a> Его
синтаксис очень простой: выражения (термы) ограничиваются переменными,
абстракциями и аппликациями. Множество всех доступных переменных будем
обозначать <span class="math"><span class="Vset">Переменные</span></span>.
Множество всех термов <span class="math"><span class="ord var">λ</span></span>-исчисления будем
обозначать Λ; его можно индуктивно определить следующим образом:</p>

<table id="ch5-table-lambda-syntax">
<tbody>
<tr>
  <td class="col1"><i>переменные</i>:</td>
  <td class="col2"><span class="math"><span class="ord">∀</span><span class="ord var">x</span><span class="rel">∈</span><span class="ord"><span class="Vset">Переменные</span></span><span class="ord">:</span></span></td>
  <td class="col3"><span class="math"><span class="ord var">x</span><span class="rel">∈</span><span class="ord">Λ</span></span></td>
</tr>
<tr>
  <td class="col1"><i>абстракции</i>:</td>
  <td class="col2"><span class="math"><span class="ord">∀</span><span class="ord var">x</span><span class="rel">∈</span><span class="ord"><span class="Vset">Переменные</span></span><span class="punct">,</span><span class="ord var">M</span><span class="rel">∈</span><span class="ord">Λ</span><span class="ord">:</span></span></td>
  <td class="col3"><span class="math"><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">M</span><span class="rel">∈</span><span class="ord">Λ</span></span></td>
</tr>
<tr>
  <td class="col1"><i>аппликации</i>:</td>
  <td class="col2"><span class="math"><span class="ord">∀</span><span class="ord var">M</span><span class="punct">,</span><span class="ord var">N</span><span class="rel">∈</span><span class="ord">Λ</span><span class="ord">:</span></span></td>
  <td class="col3"><span class="math"><span class="open">(</span><span class="ord var">M</span> <span class="ord var">N</span><span class="close">)</span><span class="rel">∈</span><span class="ord var">Λ</span></span></td>
</tr>
</tbody>
</table>

<!--\indexR{Лисп!и лямбда-исчисление@и <span class="math"><span class="ord var">λ</span></span>-исчисление}-->
<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!синтаксис}-->
<!--\indexR{синтаксис!лямбда-исчисления@<span class="math"><span class="ord var">λ</span></span>-исчисления}-->
<p>Синтаксис не особо важен и термы <span class="math"><span class="ord var">λ</span></span>-исчисления одинаково удобно
записываются в виде S-выражений.<a class="footref" href="zz_footnotes.html#foot5.2"><sup>2</sup></a> Таким образом, множество термов <span class="math"><span class="ord var">λ</span></span>-исчисления
синтаксически совпадает с подмножеством программ на Scheme, использующих только
одну специальную форму — <code><span class="special">lambda</span></code>:</p>

<blockquote class="equation"><span class="math"><span class="ord var">x</span></span><span class="quad-stub" style="width: 4em"/><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">x</span></span>) <span class="math"><span class="ord var">M</span></span>)</code><span class="quad-stub" style="width: 4em"/><code>(<span class="math"><span class="ord var">M</span></span> <span class="math"><span class="ord var">N</span></span>)</code></blockquote>

<!--\indexR{абстракция!редукция}-->
<!--\indexR{бета-редукция@$\beta$-редукция}-->
<!--\indexR{функции!в лямбда-исчислении@в <span class="math"><span class="ord var">λ</span></span>-исчислении}-->
<!--\indexR{функции!модель подстановки}-->
<!--\indexR{модель подстановки}-->
<p>С помощью <span class="math"><span class="ord var">λ</span></span>-исчисления мы можем определять функции. Есть даже правило
их применения — <em class="term"><span class="math"><span class="ord var">β</span></span>-редукция</em>: в результате применения
функции <span class="math"><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">M</span></span> к терму <span class="math"><span class="ord var">N</span></span> получается новый терм, являющийся телом
функции <span class="math"><span class="ord var">M</span></span>, в котором вместо переменной <span class="math"><span class="ord var">x</span></span> используется <span class="math"><span class="ord var">N</span></span>, что коротко
записывается: <span class="math"><span class="ord var">M</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span></span>. Это обычная модель подстановки, испокон веков
используемая математикой как само собой разумеющееся. Именно так проводятся
вычисления в программах на Scheme, принадлежащих вышеупомянутому подмножеству
(без побочных эффектов, с одной специальной формой).</p>

<blockquote class="equation math"><span class="ord normal"><span class="math"><span class="ord var">β</span></span>-редукция:</span><span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">M</span> <span class="ord var">N</span><span class="close">)</span><span class="rel">→<span class="ontop"><span class="ord var">β</span></span></span><span class="ord var">M</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span></blockquote>

<!--\indexR{лексическое связывание!в лямбда-исчислении@в <span class="math"><span class="ord var">λ</span></span>-исчислении}-->
<p>Подстановка <span class="math"><span class="ord var">M</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span></span> должна быть достаточно сообразительной, чтобы нечаянно
не затронуть лишние переменные. Имеются в виду свободные переменные, которые
могут появиться при подстановке, если <span class="math"><span class="ord var">M</span></span> является абстракцией. Свободные
переменные терма <span class="math"><span class="ord var">N</span></span> не получают значений одноимённых переменных терма <span class="math"><span class="ord var">M</span></span> при
подстановке <span class="math"><span class="ord var">N</span></span> в <span class="math"><span class="ord var">M</span></span>; подстановка значений вместо переменных может быть только
явной. Говоря более понятным языком, в <span class="math"><span class="ord var">λ</span></span>-исчислении принято лексическое
связывание. Подобная подстановка определяется следующим образом (скобки отделяют
выражения, где происходят изменения):</p>

<table id="ch5-table-beta-reduction"><tbody>
<tr><td><span class="math"><span class="ord var">x</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span><span class="rel">=</span><span class="ord var">N</span></span></td></tr>
<tr><td><span class="math"><span class="ord var">y</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span><span class="rel">=</span><span class="ord var">y</span><span class="quad-stub" style="width: 1em"/><span class="normal">если <span class="math"><span class="ord var">x</span><span class="rel">≠</span><span class="ord var">y</span></span></span></span></td></tr>
<tr><td><span class="math"><span class="open">(</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">M</span><span class="close">)</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">M</span></span></td></tr>
<tr><td><span class="math"><span class="open">(</span><span class="ord var">λ</span><span class="ord var">y</span><span class="ord">.</span><span class="ord var">M</span><span class="close">)</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">z</span><span class="ord">.</span><span class="open"><span class="big">(</span></span><span class="ord var">M</span><span class="open">[</span><span class="ord var">y</span><span class="rel">→</span><span class="ord var">z</span><span class="close">]</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span><span class="close"><span class="big">)</span></span><span class="quad-stub" style="width: 1em"/><span class="normal">где <span class="math"><span class="ord var">x</span><span class="rel">≠</span><span class="ord var">y</span></span> и <span class="math"><span class="ord var">z</span></span> не свободна в <span class="math"><span class="ord var">M</span></span> и <span class="math"><span class="ord var">N</span></span></span></span></td></tr>
<tr><td><span class="math"><span class="open">(</span><span class="ord var">M<sub><span class="ord num">1</span></sub></span> <span class="ord var">M<sub><span class="ord num">2</span></sub></span><span class="close">)</span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span><span class="rel">=</span><span class="open">(</span><span class="ord var">M<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span> <span class="ord var">M<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">x</span><span class="rel">→</span><span class="ord var">N</span><span class="close">]</span><span class="close">)</span></span></td></tr>
</tbody></table>

<!--\indexR{редексы}-->
<!--\indexR{приводимые!выражения}-->
<!--\indexR{форма!нормальная}-->
<!--\indexR{нормальная форма}-->
<!--\indexR{теорема Чёрча"""-"- Россера}-->
<!--\indexR{Чёрча"""-"- Россера, теорема}-->
<p><em class="term">Редексом</em> (от reducible expression) или приводимым выражением
называется аппликация, где первый терм (терм на месте функции) является
абстракцией. <span class="math"><span class="ord var">β</span></span>-редукция позволяет избавиться от редексов. Если терм
не содержит редексов (является неприводимым), то говорят, что он находится
в <em class="term">нормальной форме.</em> Термы <span class="math"><span class="ord var">λ</span></span>-исчисления не обязательно имеют
нормальную форму, но если она существует, то, в соответствии с теоремой
Чёрча—Россера, она единственна.</p>

<!--\indexR{стратегия вычислений}-->
<!--\indexR{вычисления!стратегия вычислений}-->
<!--\indexE{Scheme!порядок вычислений}-->
<!--\indexR{нормальный порядок вычислений}-->
<!--\indexR{аппликативный порядок вычислений}-->
<!--\indexR{энергичный порядок вычислений}-->
<!--\indexR{порядок вычислений!нормальный}-->
<!--\indexR{порядок вычислений!аппликативный}-->
<!--\indexR{порядок вычислений!энергичный}-->
<!--\indexR{вызов!по значению}-->
<!--\indexR{вызов!по имени}-->
<p>Если терм имеет нормальную форму, то она обязательно достижима за конечное
число <span class="math"><span class="ord var">β</span></span>-редукций. <em class="term">Стратегией вычислений</em> называется правило выбора
редекса (если их несколько), который будет редуцирован следующим. К сожалению,
есть как хорошие правила, так и плохие. Пример хорошего правила: редуцировать
самый левый редекс. Оно не обязательно ведёт по кратчайшему пути, но
гарантированно достигает нормальной формы (если она вообще существует). Данное
правило называется <em class="term">нормальным</em> порядком вычислений, он же
<em class="term">вызов по имени</em>. Примером плохого правила — именно его использует
Scheme — является <em class="term">аппликативный</em> порядок вычислений, также известный
как <em class="term">вызов по значению</em> или <em class="term">энергичный</em> порядок
(eager evaluation). В этом
случае функция применяется лишь после вычисления её аргументов. Рассмотрим
несколько примеров. Вот терм, который не имеет нормальной формы:</p>

<blockquote class="equation math"><span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span><span class="quad-stub" style="width: 1em"/><span class="normal">где </span><span class="ord var">ω</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="open">(</span><span class="ord var">x</span> <span class="ord var">x</span><span class="close">)</span><span class="quad-stub" style="width: 1em"/><span class="normal">так как </span><span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span><span class="rel">→<span class="ontop"><span class="ord var">β</span></span></span><span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span><span class="rel">→<span class="ontop"><span class="ord var">β</span></span></span><span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span><span class="rel">→<span class="ontop"><span class="ord var">β</span></span></span><span class="ord">…</span></blockquote>

<p>В Scheme подобная программа приводит к бесконечному циклу и, очевидно, точно
не к нормальной форме.</p>

<p>А вот пример терма, который имеет нормальную форму, но правило вычислений,
принятое в Scheme, не позволяет её достичь.</p>

<blockquote class="equation math"><span class="open"><span class="big">(</span></span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">λ</span><span class="ord var">y</span><span class="ord">.</span><span class="ord var">y</span> <span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span><span class="close">)</span> <span class="ord var">z</span><span class="close"><span class="big">)</span></span><span class="rel">→<span class="ontop"><span class="ord var">β</span></span></span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">y</span><span class="ord">.</span><span class="ord var">y</span> <span class="ord var">z</span><span class="close">)</span><span class="rel">→<span class="ontop"><span class="ord var">β</span></span></span><span class="ord var">z</span></blockquote>

<p>Scheme сразу же пойдёт вычислять аргумент <span class="math"><span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span></span> и попадёт в бесконечный цикл, так и не дойдя до нормальной формы.</p>

<p>Из-за этого правила Scheme также может успешно вычислять термы без нормальной
формы: правило требует избавляться от редексов в аргументах сразу же, но
запрещает избавляться от них в теле функций. Так что можно спокойно передавать
что-то вроде <span class="math"><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span></span> как аргумент, не получая никаких
бесконечных циклов.</p>

<!--\indexR{порядок вычислений!ленивый}-->
<!--\indexR{ленивые вычисления}-->
<!--\indexR{вызов!по необходимости}-->
<p>Так почему же Scheme использует такое плохое правило? Во-первых, компьютеры
гораздо эффективнее обрабатывают вызовы по значению, чем «хорошие» вызовы по
имени, даже если их улучшить до <em class="term">вызовов по необходимости</em> (также известных
как <em class="term">ленивый</em> порядок вычислений). Во-вторых, если плохое правило приводит
к нормальной форме, то это будет та же форма, которую мы бы получили при
использовании хорошего правила. Поэтому ради эффективности Scheme использует
плохой аппликативный порядок.</p>

<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!синтаксис}-->
<!--\indexR{синтаксис!лямбда-исчисления@<span class="math"><span class="ord var">λ</span></span>-исчисления}-->
<p>В <span class="math"><span class="ord var">λ</span></span>-исчислении принят удобный синтаксический сахар для записи функций
нескольких переменных: считать <span class="math"><span class="ord var">λ</span><span class="ord var">x</span><span class="ord var">y</span><span class="ord">.</span><span class="ord var">M</span></span> сокращением для <span class="math"><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">λ</span><span class="ord var">y</span><span class="ord">.</span><span class="ord var">M</span></span>, а <span class="math"><span class="open">(</span><span class="ord var">M</span> <span class="ord var">N<sub><span class="ord num">1</span></sub></span> <span class="ord var">N<sub><span class="ord num">2</span></sub></span><span class="close">)</span></span> — сокращением для <span class="math"><span class="open">(</span><span class="open">(</span><span class="ord var">M</span> <span class="ord var">N<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">N<sub><span class="ord num">2</span></sub></span><span class="close">)</span></span>.
Предыдущий пример становится гораздо понятнее, если его переписать в виде
<span class="math"><span class="open">(</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord var">y</span><span class="ord">.</span><span class="ord var">y</span> <span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span> <span class="ord var">z</span><span class="close">)</span></span>. Теперь бессмысленность вычисления
значения локальной переменной <span class="math"><span class="ord var">x</span></span> должна быть очевидна: ведь это значение никак
не используется в результате.</p>

<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!прикладное}-->
<p>Естественно, мы легко могли бы говорить про <span class="math"><span class="ord var">λ</span></span>-исчисление ещё пару глав,
но за этим отправляйтесь к соответствующим книгам: <span class="cite">[<a href="z1_bibliography.html#bar84">Bar84</a>, <a href="z1_bibliography.html#gor88">Gor88</a>, <a href="z1_bibliography.html#dil88">Dil88</a>]</span>.
Среди всего прочего можно ввести вспомогательные термы, например, целые числа.
В результате такого расширения получается <em>прикладное</em>
<span class="math"><span class="ord var">λ</span></span>-исчисление. Мы могли бы также добавить функции от этих термов:
например, <span class="math"><span class="ord num">2</span><span class="binop">+</span><span class="ord num">2</span><span class="rel">→</span><span class="ord num">4</span></span>; они называются <span class="math"><span class="ord var">δ</span></span>-правилами. Однако, подобные
расширения не являются в строгом смысле необходимыми, так как числа, булевы
значения, сложение, вычитание, логическое <span class="sc"><span class="c">или</span></span> — всё это можно
представить и с помощью обычных <span class="math"><span class="ord var">λ</span></span>-термов. Даже списочные структуры
вместе с <code><span class="func">car</span></code>, <code><span class="func">cons</span></code> и <code><span class="func">cdr</span></code> возможно представить подобным образом
<span class="cite">[<a href="z1_bibliography.html#gor88">Gor88</a>]</span>.
<span class="see">[см. упр. <a href="ch04_assignment_and_side_effects.html#assignment/ex:lambda-cons">4.2</a>]</span></p>

<!--\indexR{эквивалентность!лямбда-термов@$\lambda$-термов}-->
<!--\indexR{машина Тьюринга}-->
<!--\indexR{Тьюринга, машина}-->
<p>В заключение стоит сказать, что <span class="math"><span class="ord var">λ</span></span>-исчисление — это хорошо
проработанная теория вычислений, одновременно простая и мощная.
<span class="math"><span class="ord var">β</span></span>-редукция равна по выразительной силе машине Тьюринга, но при этом
не такая запутанная. Также важно, что <span class="math"><span class="ord var">λ</span></span>-исчисление обладает при той же
простоте более гибким понятием эквивалентных программ: два терма эквивалентны,
если эквивалентны их нормальные формы. По всем перечисленным причинам именно
<span class="math"><span class="ord var">λ</span></span>-исчисление было выбрано множеством денотаций для наших целей.</p>


<h2 id="denotational/sect:semantics"><span class="wrap"><span class="seq">5.2.</span><span class="title">Семантика Scheme</span></span></h2>

<!--\indexC{evaluate}-->
<p>По результатам демократических обсуждений, представителем денотаций было избрано
<span class="math"><span class="ord var">λ</span></span>-исчисление. Предыдущий интерпретатор написан на Scheme без побочных
эффектов. Его сердце — это функция-вычислитель <code><span class="func">evaluate</span></code>,
имеющая вот такой тип:</p>

<blockquote class="equation math" style="margin-left: 0; margin-right: 0; max-width: 100%;"><span class="normal"><code><span class="func">evaluate</span></code>:</span><span class="quad-stub" style="width: 0.75em"/><span class="ord Vset">Программа</span><span class="binop">×</span><span class="ord Vset">Окружение</span><span class="binop">×</span><span class="ord Vset">Продолжение</span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord Vset">Значение</span></blockquote>

<p>Первый аргумент (программу) можно легко каррировать, переходя к следующему типу:</p>

<blockquote class="equation math"><span class="ord Vset">Программа</span><span class="rel">→</span><span class="open">(</span><span class="ord Vset">Окружение</span><span class="binop">×</span><span class="ord Vset">Продолжение</span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord Vset">Значение</span><span class="close">)</span></blockquote>

<!--\indexR{контекст вычислений}-->
<!--\indexR{вычисления!контекст}-->
<!--\indexR{Денотация@\protect\Vset{Денотация}}-->
<p>Каждая программа превращается в функцию, которая по окружению, продолжению и
памяти (вместе они называются <em class="term">контекстом вычислений</em>) может сказать нам
возвращаемое значение. Это похоже на понятие смысла программы, так что
остановимся на таком определении:</p>

<table id="ch5-table-denotation-essence"><tbody>
<tr><td><span class="math"><span class="normal"><i>интерпретация</i></span><span class="ord">: </span><span class="quad-stub" style="width: 1em"/><span class="ord Vset">Программа</span><span class="rel">→</span><span class="ord Vset">Денотация</span></span></td></tr>
<tr><td><span class="math"><span class="ord Vset">Денотация</span><span class="ord">: </span><span class="quad-stub" style="width: 1em"/><span class="ord Vset">Окружение</span><span class="binop">×</span><span class="ord Vset">Продолжение</span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord Vset">Значение</span></span></td></tr>
</tbody></table>

<!--\indexR{соглашения именования!в денотациях}-->
<p>Люди, серьёзно занимающиеся денотационной семантикой, не особо любят скобочки
и имеют своеобразные предпочтения в наименовании сущностей. Прежде всего,
они (повсюду) используют греческие буквы и сокращают всё, что только можно.
В итоге, для непосвящённых их записи выглядят загадочным набором иероглифов.
Причиной таких привычек служит то, что подобная запись позволяет уместить
семантику языка на одной-единственной странице, где она как на ладони. Это
преимущество<a class="footref" href="zz_footnotes.html#foot5.3"><sup>3</sup></a>
недостижимо, если использовать пространные названия и лишние символы. Греческие же
буквы выбраны для того, чтобы не путать денотации с выражениями определяемого языка.
Так как чаще всего денотационная семантика используется для определения языков
программирования, алфавит которых ограничен ASCII, то греческие буквы являются
хорошим выбором: они компактные и выделяющиеся. Наконец, для уменьшения
количества ошибок денотации являются типизированными, их тип выводится из имён
переменных.</p>

<!--\indexR{а льфа@$\a$ (адреса)}     -->
<!--\indexE{a lpha@$\a$ (адреса)}-->
<!--\indexR{э псилон@$\e$ (значения)} -->
<!--\indexE{e psilon@$\e$ (значения)}-->
<!--\indexR{р о@$\r$ (окружение)}     -->
<!--\indexE{r ho@$\r$ (окружение)}-->
<!--\indexR{с игма@$\s$ (память)}     -->
<!--\indexE{s igma@$\s$ (память)}-->
<!--\indexR{н ю@$\n$ (переменные)}    -->
<!--\indexE{n u@$\n$ (переменные)}-->
<!--\indexR{п и@$\p$ (программы)}     -->
<!--\indexE{p i@$\p$ (программы)}-->
<!--\indexR{к аппа@$\k$ (продолжения)}-->
<!--\indexE{k appa@$\k$ (продолжения)}-->
<!--\indexR{ф и@$\f$ (функции)}       -->
<!--\indexE{p hi@$\f$ (функции)}-->
<p>Мы тоже будем следовать этим соглашениям. По давней традиции функции
обозначаются буквой <span class="math"><span class="ord var">φ</span></span>.
Остальные сущности обычно именуют по первой букве их
английского названия: <span class="math"><span class="ord var">κ</span></span> для продолжений, <span class="math"><span class="ord var">α</span></span> для адресов, <span class="math"><span class="ord var">ν</span></span> для
идентификаторов (name), <span class="math"><span class="ord var">π</span></span> для программ, <span class="math"><span class="ord var">σ</span></span> для памяти (store или state).
Попробуйте самостоятельно догадаться, почему окружения обозначаются буквой <span class="math"><span class="ord var">ρ</span></span>.</p>

<table id="ch5-table-notation" class="term-def"><tbody>
<tr><td class="left"><span class="math"><span class="ord var">π</span></span></td>
    <td class="right extra"><span class="math"><span class="Vset">Программы</span></span></td>
    <td class="left extra"><span class="math"><span class="ord var">ρ</span></span></td>
    <td class="right"><span class="math"><span class="Vset">Окружения</span></span></td></tr>
<tr><td class="left"><span class="math"><span class="ord var">ν</span></span></td>
    <td class="right extra"><span class="math"><span class="Vset">Переменные</span></span></td>
    <td class="left extra"><span class="math"><span class="ord var">α</span></span></td>
    <td class="right"><span class="math"><span class="Vset">Адреса</span></span></td></tr>
<tr><td class="left"><span class="math"><span class="ord var">σ</span></span></td>
    <td class="right extra"><span class="math"><span class="Vset">Память</span></span></td>
    <td class="left extra"><span class="math"><span class="ord var">ε</span></span></td>
    <td class="right"><span class="math"><span class="Vset">Значения</span></span></td></tr>
<tr><td class="left"><span class="math"><span class="ord var">κ</span></span></td>
    <td class="right extra"><span class="math"><span class="Vset">Продолжения</span></span></td>
    <td class="left extra"><span class="math"><span class="ord var">φ</span></span></td>
    <td class="right"><span class="math"><span class="Vset">Функции</span></span></td></tr>
</tbody></table>

<!--\indexR{домены}-->
<!--\indexR{Программы@\protect\Vset{Программы}}-->
<!--\indexR{Окружения@\protect\Vset{Окружения}}-->
<!--\indexR{Переменные@\protect\Vset{Переменные}}-->
<!--\indexR{Адреса@\protect\Vset{Адреса}}-->
<!--\indexR{Память@\protect\Vset{Память}}-->
<!--\indexR{Значения@\protect\Vset{Значения}}-->
<!--\indexR{Продолжения@\protect\Vset{Продолжения}}-->
<!--\indexR{Функции@\protect\Vset{Функции}}-->
<p>Каждое слово, набранное жирным шрифтом, соответствует <em class="term">домену</em> объектов.
Здесь присутствуют все классы объектов, которые мы рассматривали в предыдущих
главах.</p>

<table class="domains"><tbody>
<tr><td class="lhs"><span class="math"><span class="Vset">Окружение</span></span></td>
    <td class="eq"><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span></td>
    <td class="rhs"><span class="math"><span class="ord Vset">Переменная</span><span class="rel">→</span><span class="ord Vset">Адрес</span></span></td></tr>
<tr><td class="lhs"><span class="math"><span class="Vset">Память</span></span></td>
    <td class="eq"><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span></td>
    <td class="rhs"><span class="math"><span class="ord Vset">Адрес</span><span class="rel">→</span><span class="ord Vset">Значение</span></span></td></tr>
<tr><td class="lhs"><span class="math"><span class="Vset">Значения</span></span></td>
    <td class="eq"><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span></td>
    <td class="rhs"><span class="math"><span class="ord Vset">Функции</span><span class="binop">+</span><span class="ord Vset">Числа</span><span class="binop">+</span><span class="ord Vset">Пары</span><span class="binop">+</span><span class="ord">…</span></span></td></tr>
<tr><td class="lhs"><span class="math"><span class="Vset">Продолжение</span></span></td>
    <td class="eq"><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span></td>
    <td class="rhs"><span class="math"><span class="ord Vset">Значение</span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord Vset">Значение</span></span></td></tr>
<tr><td class="lhs"><span class="math"><span class="Vset">Функция</span></span></td>
    <td class="eq"><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span></td>
    <td class="rhs"><span class="math"><span class="ord Vset">Значения<sup>∗</sup></span><span class="binop">×</span><span class="ord Vset">Продолжение</span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord Vset">Значение</span></span></td></tr>
</tbody></table>

<!--\indexR{приведение типов}-->
<!--\indexR{инъекция, $\protect\Inj{Домен}(x)$}-->
<!--\indexR{проекция, $x\protect\Prj{Домен}$}-->
<!--\indexE{-inj@$\protect\Inj{Домен}(x)$ (инъекция)}-->
<!--\indexE{-proj@$x\protect\Prj{Домен}$ (проекция)}-->
<p>Как обычно, звёздочка означает список. Например, домен
<span class="math"><span class="ord Vset">Значения<sup>∗</sup></span></span> —
это домен последовательностей <span class="math"><span class="Vset">Значений</span></span>. Символ
<span class="math"><span class="binop">×</span></span> означает
декартово произведение. Символ <span class="math"><span class="binop">+</span></span>
означает дизъюнктивную сумму; то есть <span class="math"><span class="Vset">Значение</span></span> — это или <span class="math"><span class="Vset">Функция</span></span>, или <span class="math"><span class="Vset">Число</span></span>, или <span class="math"><span class="Vset">Пара</span></span>,
и т. д. Это важное свойство дизъюнктивной суммы: каждый элемент
домена <span class="math"><span class="Vset">Значений</span></span> принадлежит одному и только одному из доменов,
составляющих дизъюнктивную сумму. Так как мы считаем сущности типизированными,
то необходимо чётко обозначать переходы между доменами. Инъекция
<span class="math"><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">ε</span><span class="close">)</span></span> переносит терм <span class="math"><span class="ord var">ε</span></span> в домен <span class="math"><span class="Vset">Значений</span></span>, а проекция
<span class="math"><span class="ord var">ε</span><span class="ord">∣<sub><span class="Vset">Числа</span></sub></span></span> отображает значение <span class="math"><span class="ord var">ε</span></span> на домен <span class="math"><span class="Vset">Чисел</span></span> (конечно же,
если <span class="math"><span class="ord var">ε</span></span> ему действительно принадлежит).</p>

<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!математическая модель}-->
<p>Домены определяются рекурсивно — это важно с математической точки зрения;
именно по этой и некоторым другим причинам они называются доменами, а не просто
множествами. Не особо углубляясь в детали, скажем, что <span class="math"><span class="ord var">λ</span></span>-исчисление
было разработано Алонзо Чёрчем в 1930-х годах, но ему не хватало строгой
математической модели — она была построена Даной Скоттом около 1970 года.
<span class="math"><span class="ord var">λ</span></span>-исчисление ещё тогда доказало свою полезность, но с математической
моделью оно стало идеальным. Со временем были разработаны и другие модели:
<span class="math"><span class="ord var">D<sub><span class="ord">∞</span></sub></span></span>,
<span class="math"><span class="cal">P</span><span class="ord var">ω</span></span>.
<span class="cite">[<a href="z1_bibliography.html#sco76">Sco76</a>,
<a href="z1_bibliography.html#sto77">Sto77</a>]</span></p>

<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!экстенсиональность}-->
<!--\indexR{эта-редукция@$\eta$-редукция}-->
<!--\indexR{экстенсиональность}-->
<p><em class="term">Экстенcиональность</em> это свойство функций
<span class="math"><span class="ord">∀</span><span class="ord var">x</span><span class="ord">: </span><span class="open"><span class="big">(</span></span><span class="ord var">f</span><span class="open">(</span><span class="ord var">x</span><span class="close">)</span><span class="rel">=</span><span class="ord var">g</span><span class="open">(</span><span class="ord var">x</span><span class="close">)</span><span class="close"><span class="big">)</span></span><span class="rel">⇒</span><span class="open">(</span><span class="ord var">f</span><span class="rel">=</span><span class="ord var">g</span><span class="close">)</span></span>.
Оно связано с <span class="math"><span class="ord var">η</span></span>-редукцией — одним из вспомогательных правил <span class="math"><span class="ord var">λ</span></span>-исчисления:</p>

<blockquote class="equation math"><span class="ord normal"><span class="math"><span class="ord var">η</span></span>-редукция:</span><span class="quad-stub" style="width: 1em"/><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="open">(</span><span class="ord var">M</span> <span class="ord var">x</span><span class="close">)</span><span class="rel">→<span class="ontop"><span class="ord var">η</span></span></span><span class="ord var">M</span><span class="quad-stub" style="width: 1em"/><span class="ord normal">где <span class="math"><span class="ord var">x</span></span> не свободна в <span class="math"><span class="ord var">M</span></span></span></blockquote>

<p>Удивительно, но есть как экстенсиональные модели вроде <span class="math"><span class="ord var">D<sub><span class="ord">∞</span></sub></span></span>, так и нет;
например, <span class="math"><span class="cal">P</span><span class="ord var">ω</span></span> не экстенсиональна. Интересно, а наш мир
экстенсионален?</p>

<p>Дана Скотт показал, что любая формальная система, рекурсивно определяемая
через домены с помощью <span class="math"><span class="rel">→</span></span>,
<span class="math"><span class="binop">×</span></span>,
<span class="math"><span class="binop">+</span></span> и
<span class="math"><span class="ord"><sup>∗</sup></span></span>,
является алгоритмически разрешимой: то есть истинность любого корректного утверждения в ней можно
доказать или опровергнуть за конечное число шагов.</p>

<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!композициональность}-->
<!--\indexR{композициональность!лямбда-исчисления@<span class="math"><span class="ord var">λ</span></span>-исчисления}-->
<p>Ещё один важный принцип денотационной семантики — это
<em class="term">композициональность</em>: смысл фрагмента программы зависит только от смысла
составляющих его частей. Он очень важен для индуктивного метода доказательства и
не только: это удобно для реализации, когда программы не зависят от контекста.</p>

<!--\indexE{"["]@$[\![$\quad$]\!]$ (семантические скобки)}-->
<!--\indexE{E-@$\protect\Eval$, интерпретатор}-->
<!--\indexR{интерпретатор!E@$\protect\Eval$}-->
<p>Функцию-интерпретатор обычно обозначают
<span class="math"><span class="ord cal">𝓔</span></span>.
Чтобы отличать программы от их семантики, фрагменты программ будут заключаться в семантические
скобки: <span class="math"><span class="open sem-brace">[[</span></span> и <span class="math"><span class="close sem-brace">]]</span></span>. Теперь мы наконец-то перейдём к разбору форм одна за другой.</p>


<h3 id="denotational/semantics/ssect:var-ref"><span class="wrap"><span class="seq">5.2.1.</span><span class="title">Обращения к переменным</span></span></h3>

<p>Простейшая из денотаций — получение значения переменной:</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>

<p>Денотация ссылки на переменную (с именем
<span class="math"><span class="ord var">ν</span></span>) это <span class="math"><span class="ord var">λ</span></span>-терм, который по
окружению <span class="math"><span class="ord var">ρ</span></span>,
продолжению <span class="math"><span class="ord var">κ</span></span> и
памяти <span class="math"><span class="ord var">σ</span></span> определяет сначала адрес
расположения переменной с помощью окружения: <span class="math"><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span></span>, потом передаёт адрес
памяти для получения значения: <span class="math"><span class="open">(</span><span class="ord var">σ</span> <span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="close">)</span></span>, затем, наконец, передаёт
значение продолжению вместе с исходной памятью (так как чтение её не меняет).</p>

<p>Здесь мы воспользовались упомянутым ранее сокращением для функций нескольких
аргументов. Конечно, можно было бы писать более строго:</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ρ</span><span class="ord">.</span><span class="ord var">λ</span><span class="ord var">κ</span><span class="ord">.</span><span class="ord var">λ</span><span class="ord var">σ</span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>

<p>Нам нет смысла выставлять напоказ свою педантичность, поэтому мы не будем
использовать подобную запутанную запись. В действительности, мы её ещё сильнее
упростим, приняв синтаксис, похожий на <code><span class="special">define</span></code>:</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>

<!--\indexR{р о0@$\r_0$ (начальное окружение)}-->
<!--\indexE{r ho0@$\r_0$ (начальное окружение)}-->
<p>Конечно, обязательно надо учитывать возможность ошибки: переменной может
не оказаться в окружении. С этим будет разбираться начальное окружение
<span class="math"><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span></span>:</p>

<div class="denotation math"><span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="ord var">ν</span><span class="close">)</span><span class="rel">=</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"No such variable"</span></code></span></div>

<!--\indexE{.bot@$\bot$}-->
<!--\indexR{строгие функции}-->
<!--\indexR{функции!строгие}-->
<!--\indexE{wrong@\protect<i>wrong</i>}-->
<p>Если переменная не будет обнаружена в окружении, то вызывается
<span class="math"><span class="ord var">wrong</span></span>,
которая в свою очередь вернёт особое значение, обычно обозначаемое
<span class="math"><span class="ord">⊥</span></span>. Это
значение является в некотором смысле абсорбентом, то есть
<span class="math"><span class="ord">∀</span><span class="ord var">f</span><span class="ord">: </span><span class="ord var">f</span><span class="open">(</span><span class="ord">⊥</span><span class="close">)</span><span class="rel">=</span><span class="ord">⊥</span></span>.
Следовательно, если возникает ошибка, то всё вычисление
возвращает <span class="math"><span class="ord">⊥</span></span>, что явно сигнализирует о проблеме.
На самом деле, это не <span class="math"><span class="ord">⊥</span></span> само по себе имеет
такое свойство, а функции так с ним обращаются (в этом случае они называются <em class="term">строгими</em>). Функция <span class="math"><span class="ord var">f</span></span> строга тогда и
только тогда, когда <span class="math"><span class="ord var">f</span><span class="open">(</span><span class="ord">⊥</span><span class="close">)</span><span class="rel">=</span><span class="ord">⊥</span></span>. Если условиться использовать только
строгие функции, то это избавит нас в определённой мере от обработки ошибок и
позволит сконцентрироваться на более важных вещах.</p>


<h3 id="denotational/semantics/ssect:sequence"><span class="wrap"><span class="seq">5.2.2.</span><span class="title">Последовательность</span></span></h3>

<!--\indexR{интерпретатор!Eplus@$\protect\Eval^+$}-->
<!--\indexE{E-plus@$\protect\Eval^+$, интерпретатор}-->
<p>Денотация последовательных вычислений как обычно вызывает вспомогательную
функцию, которой в предыдущих интерпретаторах соответствует функция
<code><span class="func">eprogn</span></code>. Мы будем обозначать её
<span class="math"><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span></span>.
С плюсом, потому что в форме <code><span class="special">begin</span></code> должен
присутствовать хотя бы один элемент. Аналогично будем обозначать
последовательность непустых форм: <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>. Интерпретатор <span class="math"><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span></span> превращает
<span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span> в денотацию, которая вычисляет все элементы слева направо и возвращает
значение последнего из них. Его работа сводится к двум случаям: когда <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>
состоит из одной и более чем одной формы. В Scheme смысл <code>(<span class="special">begin</span>)</code>
не определён, поэтому и здесь такого случая нет в определении.</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">begin</span> <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open"><span class="big">(</span></span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close"><span class="big">)</span></span></div>

<!--\indexR{эта-упрощение@$\eta$-упрощение}-->
<p>Если последовательность состоит из одного элемента, то она эквивалентна данному
элементу. Можно было бы записать это буквально:</p>

<div class="denotation math"><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span><span class="rel">=</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span></div>

<p>В <span class="math"><span class="ord var">λ</span></span>-исчислении это называется <span class="math"><span class="ord var">η</span></span>-упрощением. Мы будем избегать
подобных фокусов, так как они затрудняют понимание программ, а также скрывают
естественную арность функций; как говорят
<span class="cite">[<a href="z1_bibliography.html#wl93">WL93</a>]</span>,
часто так пишут только чтобы выглядеть умнее.</p>

<p>Если последовательность состоит из более чем одного элемента, то вычисляется
значение первого из них и управление передаётся продолжению, которое должно
вычислить все остальные. Тут — в одной строке! — ещё раз можно увидеть,
что продолжение игнорирует вычисленное ранее значение, но не состояние памяти
после его вычисления. В конечном итоге именно продолжения позволяют упорядочить
вычисления.</p>


<h3 id="denotational/semantics/ssect:conditional"><span class="wrap"><span class="seq">5.2.3.</span><span class="title">Ветвление</span></span></h3>

<!--\indexE{T@\protect\comb{T}, комбинатор}-->
<!--\indexE{F@\protect\comb{F}, комбинатор}-->
<!--\indexR{комбинаторы}-->
<!--\indexR{комбинаторы!T@\protect\comb{T}}-->
<!--\indexR{комбинаторы!F@\protect\comb{F}}-->
<!--\indexR{логические значения!в лямбда-исчислении@в <span class="math"><span class="ord var">λ</span></span>-исчислении}-->
<!--\indexR{представление!логических значений!в лямбда-исчислении@в <span class="math"><span class="ord var">λ</span></span>-исчислении}-->
<p>Денотация условного оператора довольно стандартна и не представляет трудностей,
если знать, как представить булевы значения с помощью абстракций
<span class="math"><span class="ord var">λ</span></span>-исчисления. На самом деле это не так сложно: мы определим их как
комбинаторы (то есть функции без свободных переменных).</p>

<blockquote class="equation math"><span class="ord comb">T</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord var">y</span>.<span class="ord var">x</span><span class="quad-stub" style="width: 1em"/><span class="normal">и</span><span class="quad-stub" style="width: 1em"/><span class="ord comb">F</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord var">y</span>.<span class="ord var">y</span></blockquote>

<!--\indexE{If@$\mathbf{If}$ (логическая операция)}-->
<p>Эти функции принимают два аргумента и выбирают один из них в качестве
результата. Это напоминает логическую операцию
<span class="math"><span class="ord bf">If</span></span>, определяемую
уравнениями</p>

<blockquote class="equation math"><span class="ord bf">If</span><span class="open">(</span><span class="ord var">истина</span><span class="punct">,</span><span class="ord var">p</span><span class="punct">,</span><span class="ord var">q</span><span class="close">)</span><span class="rel">=</span><span class="ord var">p</span><span class="quad-stub" style="width: 1em"/><span class="normal">и</span><span class="quad-stub" style="width: 1em"/><span class="ord bf">If</span><span class="open">(</span><span class="ord var">ложь</span><span class="punct">,</span><span class="ord var">p</span><span class="punct">,</span><span class="ord var">q</span><span class="close">)</span><span class="rel">=</span><span class="ord var">q</span></blockquote>

<p>Внимание: это не имеет ничего общего с <code><span class="special">if</span></code> в Scheme.
В этом определении ничего не говорится о порядке вычислений, только о том, что
<span class="math"><span class="ord bf">If</span></span> это булева функция;
её можно определить с помощью той же таблицы истинности, но
более коротко она описывается вот так:</p>

<blockquote class="equation math">
  <span class="ord bf">If</span><span class="open">(</span><span class="ord var">c</span><span class="punct">,</span><span class="ord var">p</span><span class="punct">,</span><span class="ord var">q</span><span class="close">)</span><span class="rel">=</span><span class="open">(</span><span class="ord">¬</span><span class="ord var">c</span><span class="binop">∨</span><span class="ord var">p</span><span class="close">)</span><span class="binop">∧</span><span class="open">(</span><span class="ord var">c</span><span class="binop">∨</span><span class="ord var">q</span><span class="close">)</span>
</blockquote>

<!--\indexR{комбинаторы!IF@\protect\comb{IF}}-->
<!--\indexE{IF@\protect\comb{IF}, комбинатор}-->
<p>Благодаря выбранному представлению булевых значений, мы можем легко перенести
<span class="math"><span class="ord bf">If</span></span>
в <span class="math"><span class="ord var">λ</span></span>-исчисление, написав следующий комбинатор:</p>

<blockquote class="equation math">
  <span class="ord comb">IF</span> <span class="ord var">c</span> <span class="ord var">p</span> <span class="ord var">q</span><span class="rel">=</span><span class="open">(</span><span class="ord var">c</span> <span class="ord var">p</span> <span class="ord var">q</span><span class="close">)</span>
</blockquote>

<p>Как и в логике, здесь ничего не сказано о порядке вычислений, только
об отношениях между тремя значениями. Если понимать <span class="math"><span class="ord bf">If</span></span> как функцию,
то она возвращает второй аргумент, если первый является истиной, и третий
в противном случае. Вслед за
<span class="cite">[<a href="z1_bibliography.html#fw84">FW84</a>]</span>, мы будем называть такую
функцию <code><span class="func">ef</span></code>. На Scheme она бы записывалась так:</p>

<!--\indexC{ef}-->
<!--\indexE{if@\protect<code><span class="func">if</span></code>|seealso{\protect<code><span class="func">ef</span></code>}}-->
<pre>(<span class="special">define</span> (<span class="func">ef</span> <span class="var">v</span> <span class="var">v1</span> <span class="var">v2</span>)
  (<span class="func">v</span> <span class="var">v1</span> <span class="var">v2</span>) )</pre>

<p>Чтобы сделать запись более понятной, подобный выбор будем записывать
как в <span class="cite">[<a href="z1_bibliography.html#sch86">Sch86</a>]</span>:</p>

<div class="denotation math"><span class="ord var">ε<sub><span class="ord num">0</span></sub></span><span class="rel">→</span><span class="ord var">ε<sub><span class="ord num">1</span></sub></span><span class="rel">[]</span><span class="ord var">ε<sub><span class="ord num">2</span></sub></span></div>

<p class="noindent">В R<sup>5</sup>RS применяется немного другая нотация:</p>

<div class="denotation math"><span class="ord var">ε<sub><span class="ord num">0</span></sub></span><span class="rel">→</span><span class="ord var">ε<sub><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord num">2</span></sub></span></div>

<p>Держа всё это в уме, определим денотацию условного оператора:</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">if</span> <span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span><span class="rel">→</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span><span class="rel">[]</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>

<!--\indexE{boolify@\protect<i>boolify</i>}-->
<!--\indexR{порядок вычислений!в лямбда-исчислении@в <span class="math"><span class="ord var">λ</span></span>-исчислении}-->
<p>Функция <span class="math"><span class="ord var">boolify</span></span> приводит значение к булевому типу, так как в Scheme любое
значение, кроме <code><span class="hash">#f</span></code>, считается истиной. Условный оператор начинает работу
с вычисления условия с продолжением, которое выбирает нужную ветку
в соответствии со значением условия. Внимание: условный оператор
в <span class="math"><span class="ord var">λ</span></span>-исчислении только выглядит похожим на <i>if–then–else</i>
из Scheme, они отличаются очень важной деталью: порядком вычислений.
В <span class="math"><span class="ord var">λ</span></span>-исчислении он абсолютно произвольный, ничто не мешает параллельно
вычислять все три выражения и выбирать одну из двух веток только в конце всех
вычислений.</p>

<!--\indexE{Scheme!и лямбда-исчисление@и <span class="math"><span class="ord var">λ</span></span>-исчисление}-->
<p>Это очень важное замечание, так как мы не можем считать <span class="math"><span class="ord var">λ</span></span>-исчисление
(и, следовательно, определяемый нами язык) полностью эквивалентным Scheme.
В <span class="math"><span class="ord var">λ</span></span>-исчислении вообще нет понятия порядка вычислений, просто условная
форма может принять одно из двух значений; какое именно — зависит от первого
аргумента.</p>

<!--\indexR{порядок вычислений}-->
<p>Тем не менее, отсутствие порядка не мешает правильности вычислений, так как
переменные обеих веток изолированы, а функции <span class="math"><span class="ord var">λ</span></span>-исчисления не имеют
побочных эффектов. Например, следующее выражение вполне успешно вычисляется,
хотя кажется, что если вычислять его параллельно или в «неправильном» порядке,
то нас ожидает провал:</p>

<pre>(<span class="special">if</span> (<span class="func">=</span> <span class="num">0</span> <span class="var">q</span>) <span class="num">1</span> (<span class="func">/</span> <span class="var">p</span> <span class="var">q</span>))</pre>

<p>Это выражение сначала проверяет, равна ли <code><span class="var">q</span></code> нулю, и, если это так, то
возвращает единицу, иначе — выполняет деление <code><span class="var">p</span></code> на <code><span class="var">q</span></code> и возвращает
его результат. Денотация данного вычисления выражает выбор между <span class="math"><span class="ord num">1</span></span> и <span class="math"><span class="ord var">p</span><span class="ord">/</span><span class="ord var">q</span></span>
в зависимости от того, равна ли <span class="math"><span class="ord var">q</span></span> нулю.</p>

<p>Из-за «плохого» порядка вычислений, принятого в Scheme, денотацию этой формы
иногда сложно понимать, так как от неё ожидается вычисление условия перед телом,
а не вычисление всего сразу вместе с возможными вариантами подобно квантовым
компьютерам. Поэтому мы перепишем денотацию следующим образом:</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">if</span> <span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span><span class="rel">→</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span><span class="rel">[]</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>

<p>Здесь вводится некоторый порядок вычислений. Теперь значение условия служит
только для выбора нужной ветки — собственно вычисление значения выполняется
отдельно и один раз.</p>

<p>Попробуем проверить, эквивалентны ли данные определения. Для этого достаточно
будет доказать эквивалентность их денотаций, иными словами, показать, что</p>

<table id="ch5-boolify-eq"><tbody>
<tr><td><span class="math"><span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span><span class="rel">→</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span><span class="rel">[]</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span><span class="rel">≡</span></span></td></tr>
<tr class="second"><td><span class="math"><span class="quad-stub" style="width: 13em"/><span class="rel">≡</span><span class="open">(</span><span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span><span class="rel">→</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span><span class="rel">[]</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span></span></td></tr>
</tbody></table>

<p>Это тождество очевидно ложно в Scheme из-за аппликативного порядка вычислений.
Для доказательства достаточно положить <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span> равной бесконечному циклу. Но
денотации — это выражения <span class="math"><span class="ord var">λ</span></span>-исчисления, и сравнивать их следует по
законам <span class="math"><span class="ord var">λ</span></span>-исчисления. В этом случае мы видим простейший дистрибутивный
закон.</p>

<!--\indexE{if-then-else-endif@$\protect\IF\ldots\protect\THEN\ldots\protect\ELSE\ldots\protect\ENDIF$}-->
<p>Надеюсь, иероглифов было достаточно. Далее будет использоваться более
читабельная запись условных выражений:</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">if</span> <span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span>
<span/><span class="rel syntax">then</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">else</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">endif</span><span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div></div>


<h3 id="denotational/semantics/ssect:assign"><span class="wrap"><span class="seq">5.2.4.</span><span class="title">Присваивание</span></span></h3>

<p>Денотация присваивания проста. Версия, приведённая здесь, возвращает только что
присвоенное значение.</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">set!</span> <span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord var">f</span><span class="open">[</span><span class="ord var">y</span><span class="rel">→</span><span class="ord var">z</span><span class="close">]</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span/><span class="rel syntax">if</span><span class="ord var">y</span><span class="rel">=</span><span class="ord var">x</span><span class="rel syntax">then</span><span class="ord var">z</span><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">f</span> <span class="ord var">x</span><span class="close">)</span><span class="rel syntax">endif</span></div>

<!--\indexE{->@$\s[\a \protect\to \e]$ (расширение окружения)}-->
<p>Память расширяется, чтобы учесть новое значение <span class="math"><span class="ord var">ε</span></span> по адресу переменной <span class="math"><span class="ord var">π</span></span>.
Мы обозначаем это расширение <span class="math"><span class="ord var">σ</span><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span></span>. Подобная нотация используется и
в других работах: <span class="math"><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="ord var">σ</span></span> в <span class="cite">[<a href="z1_bibliography.html#sch86">Sch86</a>]</span>,
<span class="math"><span class="open">[</span><span class="ord var">ε</span><span class="ord">/</span><span class="ord var">α</span><span class="close">]</span><span class="ord var">σ</span></span> в <span class="cite">[<a href="z1_bibliography.html#sto77">Sto77</a>]</span> или
<span class="math"><span class="ord var">σ</span><span class="open">[</span><span class="ord var">ε</span><span class="ord">/</span><span class="ord var">α</span><span class="close">]</span></span>
в <span class="cite">[<a href="z1_bibliography.html#gor88">Gor88</a>, <a href="z1_bibliography.html#kcr98">KCR98</a>]</span>.</p>

<!--\indexE{-e<>@$\protect\seq{\e^*_1, \ldots, \e^*_n}$ (последовательность)}-->
<!--\indexE{-eS@$\e^*_1 \protect\append \e^*_2$ (конкатенация)}-->
<!--\indexE{-ea@$\e^*\protect\car n$ (денотационный <code><span class="func">car</span></code>)}-->
<!--\indexE{-ed@$\e^*\protect\cdr n$ (денотационный <code><span class="func">cdr</span></code>)}-->
<!--\indexE{-el@$\#\e^*$ (длина последовательности)}-->
<p>Давайте расширим <span class="math"><span class="ord var">λ</span></span>-исчисление несколькими вспомогательными функциями.
Последовательности будем записывать в угловых скобках:
<span class="math"><span class="open">⟨</span></span> и
<span class="math"><span class="close">⟩</span></span>.
Конкатенацию последовательностей будем обозначать знаком
<span class="math"><span class="binop">§</span></span>. Извлечение
<span class="math"><span class="ord var">i</span></span>-го элемента последовательности
будем обозначать
<span class="math"><span class="open">⟨</span><span class="ord var">ε<sub><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord num">2</span></sub></span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord var">n</span></sub></span><span class="close">⟩</span><span class="close">↓<sub><span class="ord var">i</span></sub></span></span>
(получая <span class="math"><span class="ord var">ε<sub><span class="ord var">i</span></sub></span></span>). Отбрасывание первых <span class="math"><span class="ord var">i</span></span> элементов последовательности —
<span class="math"><span class="open">⟨</span><span class="ord var">ε<sub><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord num">2</span></sub></span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord var">n</span></sub></span><span class="close">⟩</span><span class="close">↑<sub><span class="ord var">i</span></sub></span></span> (получая
<span class="math"><span class="open">⟨</span><span class="ord var">ε<sub><span class="ord var">i</span><span class="binop">+</span><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord var">n</span></sub></span><span class="close">⟩</span></span>).
Длина последовательности <span class="math"><span class="ord var">ε<sup>∗</sup></span></span>
записывается <span class="math"><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span></span>. Все эти определения можно было бы привести
непосредственно в виде <span class="math"><span class="ord var">λ</span></span>-термов, но это стало бы чересчур серьёзным
отступлением от темы, поэтому, ничуть не умаляя достоверности повествования, мы
сходу будем использовать
<span class="math"><span class="close">↓<sub><span class="ord num">1</span></sub></span></span>,
<span class="math"><span class="close">↑<sub><span class="ord num">1</span></sub></span></span>,
<span class="math"><span class="ord">#</span></span> и
<span class="math"><span class="binop">§</span></span>
как денотационные эквиваленты <code><span class="func">car</span></code>, <code><span class="func">cdr</span></code>, <code><span class="func">length</span></code> и <code><span class="func">append</span></code>.</p>

<!--\indexE{->*@$\s[\a^* \protect<span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span> \e^*]$ (расширение окружения списком)}-->
<p>Теперь можно коротко записать расширение памяти списком переменных.
Предполагается, что <span class="math"><span class="ord var">y<sup>∗</sup></span></span>
и <span class="math"><span class="ord var">z<sup>∗</sup></span></span> имеют равную длину.</p>

<div class="denotation math"><span class="ord var">f</span><span class="open">[</span><span class="ord var">y<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">z<sup>∗</sup></span><span class="close">]</span><span class="rel ord">=</span><span class="rel syntax">if</span><span class="ord var">y<sup>∗</sup></span><span class="rel">&gt;</span><span class="ord num">0</span><span class="rel syntax">then</span><span class="ord var">f</span><span class="open">[</span><span class="ord var">y<sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">z<sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="close">]</span><span class="open">[</span><span class="ord var">y<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="rel">→</span><span class="ord var">z<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">]</span><span class="rel syntax">else</span><span class="ord var">f</span><span class="rel syntax">endif</span></div>


<h3 id="denotational/semantics/ssect:abstraction"><span class="wrap"><span class="seq">5.2.5.</span><span class="title">Абстракция</span></span></h3>

<p>Для начала рассмотрим лишь случай функций фиксированной арности.</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">α<sup>∗</sup></span><span class="close">]</span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">ε<sup>∗</sup></span><span class="close">]</span><span class="close">)</span></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div></div>

<p>Инъекция <span class="math"><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord">…</span><span class="close">)</span></span> принимает <span class="math"><span class="ord var">λ</span></span>-терм, представляющий
функцию, и превращает его в значение. При применении функции производится
обратное преобразование.</p>


<!--\indexE{allocate@\protect<i>allocate</i>}-->
<p>Вызванная функция проверят фактическую арность, затем выделяет место в памяти
под свои аргументы и связывает переменные со значениями, после чего
последовательно вычисляет формы, составляющие её тело. Выделением памяти
занимается функция <span class="math"><span class="ord var">allocate</span></span>; она принимает память, необходимое количество
адресов и продолжение, которому она передаст список выделенных адресов и новое
состояние памяти. <span class="math"><span class="ord var">allocate</span></span> — это чистая функция: эквивалентные аргументы
дают эквивалентные результаты её применения. Её определение довольно рутинно,
так что здесь мы его опустим, чтобы не перегружать выкладки. (Интересующиеся
могут переписать определение <span class="math"><span class="ord var">allocate</span></span> из предыдущей главы.
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.html#assignment/implementation/ssect:memory">4.3.8</a>]</span>)</p>

<p>Функция <span class="math"><span class="ord var">allocate</span></span> имеет следующий полиморфный тип (<span class="math"><span class="ord var">α</span></span> соответствует
любому типу данных):</p>

<blockquote class="equation math">  <span class="ord Vset">Память</span><span class="binop">×</span><span class="ord Vset">НатуральноеЧисло</span><span class="binop">×</span><span class="open">(</span><span class="ord Vset">Память</span><span class="binop">×</span><span class="ord Vset">Адреса<sup>∗</sup></span><span class="rel">→</span><span class="ord var">α</span><span class="close">)</span><span class="rel">→</span><span class="ord var">α</span></blockquote>


<h3 id="denotational/semantics/ssect:application"><span class="wrap"><span class="seq">5.2.6.</span><span class="title">Аппликация</span></span></h3>

<!--\indexR{интерпретатор!Eseq@$\protect\Eval^*$}-->
<!--\indexE{E-seq@$\protect\Eval^*$, интерпретатор}-->
<p>Функции создаются для того, чтобы их применяли, поэтому на очереди аппликация.
Как обычно, нам потребуется вспомогательный интерпретатор:
<span class="math"><span class="ord cal">𝓔<sup>∗</sup></span></span>,
аналог <code><span class="func">evlis</span></code>.</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">φ</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">φ</span><span class="ord">∣<sub><span class="ord Vset">Функции</span></sub></span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="quad-stub" style="width: 0.1em"/><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span><span class="binop">§</span><span class="ord var">ε<sup>∗</sup></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>

<p>Продолжения, которые принимает
<span class="math"><span class="ord cal">𝓔<sup>∗</sup></span></span>,
работают со списками значений, а не с отдельными значениями. Это отличает
<span class="math"><span class="ord cal">𝓔<sup>∗</sup></span></span> от
<span class="math"><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span></span>.
Данные продолжения <span class="math"><span class="ord var">κ</span></span> имеют тип</p>

<blockquote class="equation math"><span class="ord Vset">Значения<sup>∗</sup></span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord Vset">Значение</span></blockquote>

<h3 id="denotational/semantics/ssect:call/cc"><span class="wrap"><span class="seq">5.2.7.</span><span class="title"><code><span class="func">call/cc</span></code></span></span></h3>

<p>Разумеется, наше знакомство с денотационной семантикой было бы неполным без
определения существенной для Scheme функции —
<code><span class="func">call/cc</span></code>. Глобальная
функция <code><span class="func">call/cc</span></code> определяется следующим образом:</p>

<!--\indexC{call/cc}-->
<div class="denotation math"><span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">call/cc</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><div class="valign math"><span class="open"/><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Функция</span></sub></span>
<span class="open">⟨</span><span class="ord Vset">Значение</span><span class="open">(</span><div class="valign math"><span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span><span class="close">⟩</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div></div>

<p>Обратите внимание на переходы между доменами <span class="math"><span class="Vset">Значений</span></span> и
<span class="math"><span class="Vset">Функций</span></span>. Сама денотация не сложнее любого другого из способов
определения <code><span class="func">call/cc</span></code>, которые были рассмотрены ранее
в третьей главе.
<span class="see">[см. раздел <a href="ch03_escape_and_return.html#escape/implementation/ssect:call/cc">3.4.1</a>]</span></p>


<h3 id="denotational/sematics/ssect:conclusions"><span class="wrap"><span class="seq">5.2.8.</span><span class="title">Предварительные выводы</span></span></h3>

<p>Нам удалось шаг за шагом определить функцию, которая ставит в соответствие
каждой программе <span class="math"><span class="ord var">λ</span></span>-терм. Не подлежит сомнению тот факт, что она
существует, ведь мы руководствовались принципом композициональности при её
определении. Возможны только некоторые проблемы с синтаксически рекурсивными
программами <span class="cite">[<a href="z1_bibliography.html#que92a">Que92a</a>]</span>, так что для точного доказательства корректности
потребуется немного больше математики.</p>

<p>Теперь вы можете своими глазами убедиться в том, что семантика ядра Scheme
умещается на одном листе бумаги:
см. таблицу <a href="#denotational/sematics/fig:naked-scheme">5.1</a>.</p>

<table id="denotational/sematics/fig:naked-scheme" class="semantic">
<!--\indexE{Scheme!семантика}-->
<tbody>
<tr><td><div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">if</span> <span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><div class="valign math"><span/><span class="rel syntax">if</span> <span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span>
<span/><span class="rel syntax">then</span> <span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">else</span> <span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">endif</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">set!</span> <span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">α<sup>∗</sup></span><span class="close">]</span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">ε<sup>∗</sup></span><span class="close">]</span><span class="close">)</span></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">φ</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">φ</span><span class="ord">∣<sub><span class="ord Vset">Функции</span></sub></span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span><span class="binop">§</span><span class="ord var">ε<sup>∗</sup></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="quad-stub" style="width: 0.1em"/><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">begin</span> <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open"><span class="big">(</span></span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close"><span class="big">)</span></span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">call/cc</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><div class="valign math"><span class="open"/><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Функция</span></sub></span>
<span class="open">⟨</span><span class="ord Vset">Значение</span><span class="open">(</span><div class="valign math"><span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span><span class="close">⟩</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div></div></td></tr>
</tbody>
</table>
<span class="caption">Таблица 5.1. Сущность Scheme.</span>

<p>Конечно, специальная форма <code><span class="special">quote</span></code>
остаётся нереализованной (как вы помните, с цитированием не всё так просто
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.html#assignment/sect:quotation">4.5</a>]</span>), функции
с переменной арностью отложены на потом. Естественно, здесь не хватает
<code><span class="func">eq?</span></code>
для сравнения функций, а также множества других примитивов. Правда, у нас есть
<code><span class="func">call/cc</span></code> в костюме Евы. На самом деле важно то, что другие функции вроде
<code><span class="func">car</span></code>, <code><span class="func">cons</span></code>, <code><span class="func">set-cdr!</span></code> могут быть реализованы с помощью данного
базиса без каких-либо добавок в ядро. Специальных форм и некоторых примитивных
функций вроде <code><span class="func">call/cc</span></code> достаточно для понимания принципа.</p>

<p>Как бы то ни было, я настаиваю на том, что выражение сути Scheme с подобной
точностью и лаконичностью стоит затраченных усилий. Таким образом, наше
путешествие, начавшееся в первой главе с определения подмножества Scheme
с помощью всего Scheme, подходит к концу. Сейчас мы определили весь Scheme
с помощью одного лишь <span class="math"><span class="ord var">λ</span></span>-исчисления.</p>


<h2 id="denotational/sect:lambda"><span class="wrap"><span class="seq">5.3.</span><span class="title">Семантика <span class="math"><span class="ord var">λ</span></span>-исчисления</span></span></h2>

<p>Определение сущности языка с помощью нескольких формул является одной из
притягательных черт Scheme. Именно поэтому функциональные языки являются
лингвистическими лабораториями для испытания новых конструкций и изучения их
фундаментальных, обобщённых свойств. Попробуем и мы провести подобное
исследование. Для этого мы примемся за довольно простой по своей сути язык —
само <span class="math"><span class="ord var">λ</span></span>-исчисление. Здесь нет никакой тавтологии или шутки, будет
полезным рассмотреть семантику языка, который отличается от Scheme, но всё же
является родственным.</p>

<p>Начнём с синтаксиса. Он, как уже было сказано, не важен, так что будем
использовать Scheme-подобный синтаксис:</p>

<blockquote class="equation math"><span class="ord var">x</span><span class="quad-stub" style="width: 4em"/><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">x</span></span>) <span class="math"><span class="ord var">M</span></span>)</code></span> <span class="quad-stub" style="width: 4em"/><span class="normal"><code>(<span class="math"><span class="ord var">M</span></span> <span class="math"><span class="ord var">N</span></span>)</code></span></blockquote>

<p>Теперь определим домены. В <span class="math"><span class="ord var">λ</span></span>-исчислении нет присваиваний и продолжений,
что серьёзно облегчает нам работу. Более того, мы ограничимся чистым
<span class="math"><span class="ord var">λ</span></span>-исчислением — то есть никаких чисел и всего такого, только голые
абстракции. Итак, домены:</p>

<table id="ch5-lcalc-domains" class="term-def"><tbody>
<tr><td class="left"><span class="math"><span class="ord var">π</span></span></td>
<td class="right" colspan="2"><span class="math"><span class="ord Vset">Программы</span></span></td></tr>
<tr><td class="left"><span class="math"><span class="ord var">ν</span></span></td>
<td class="right" colspan="2"><span class="math"><span class="ord Vset">Переменные</span></span></td></tr>
<tr><td class="left"><span class="math"><span class="ord var">ρ</span></span></td>
<td class="right"><span class="math"><span class="ord Vset">Окружения</span></span></td><td><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord Vset">Переменная</span><span class="rel">→</span><span class="ord Vset">Значение</span></span></td></tr>
<tr><td class="left"><span class="math"><span class="ord var">ε</span></span></td>
<td class="right"><span class="math"><span class="ord Vset">Значения</span></span></td><td><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord Vset">Функции</span></span></td></tr>
<tr><td class="left"><span class="math"><span class="ord var">φ</span></span></td>
<td class="right"><span class="math"><span class="ord Vset">Функции</span></span></td><td><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord Vset">Значение</span><span class="rel">→</span><span class="ord Vset">Значение</span></span></td></tr>
</tbody></table>

<!--\indexR{интерпретатор!L@$\protect\Lain$}-->
<!--\indexE{L@$\protect\Lain$, интерпретатор}-->
<p>Функцию-интерпретатор мы назовём <span class="math"><span class="ord cal">𝓛</span></span>.
Она будет сопоставлять каждому <span class="math"><span class="ord var">λ</span></span>-терму его денотацию — другой <span class="math"><span class="ord var">λ</span></span>-терм. Таким образом,
интерпретатор имеет простой тип</p>

<blockquote class="equation math"><span class="ord cal">𝓛</span><span class="ord">:</span><span class="quad-stub" style="width: 1em"/><span class="ord Vset">Программа</span><span class="rel">→</span><span class="open">(</span><span class="ord Vset">Окружение</span><span class="rel">→</span><span class="ord Vset">Значение</span><span class="close">)</span></blockquote>

<p>Осталось только определить одну за другой денотации синтаксических форм. Всё их
огромное разнообразие собрано в таблице <a href="#denotational/lambda/fig:self">5.2</a>.</p>

<table id="denotational/lambda/fig:self" class="semantic">
<!--\indexR{лямбда-исчисление@<span class="math"><span class="ord var">λ</span></span>-исчисление!семантика}-->
<tbody>
<tr><td><div class="denotation math"><span class="ord cal">𝓛</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span>
<span class="ord cal">𝓛</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν</span></span>) <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ε</span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓛</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span class="ord cal">𝓛</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π</span><span class="ord">′</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="rel">=</span><span class="open"><span class="big">(</span></span><span class="open">(</span><span class="ord cal">𝓛</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="close">)</span> <span class="open">(</span><span class="ord cal">𝓛</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="ord">′</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="close">)</span><span class="close"><span class="big">)</span></span></div></td></tr>
</tbody></table>
<span class="caption">Таблица 5.2. Семантика <span class="math"><span class="ord var">λ</span></span>-исчисления.</span>

<p>Данная семантика очень точна, вплоть до неопределённости порядка вычислений.
Аппликация переводится в аппликацию, так что никакого порядка
не устанавливается.</p>

<p>Интерпретатор <span class="math"><span class="ord cal">𝓛</span></span> определяется рекурсивно.
Мы можем так делать благодаря композициональности: рано или поздно все вычисления сведутся
к ссылкам на переменные.</p>

<p><span class="math"><span class="ord var">λ</span></span>-исчисление представляет особенный случай, так как мы и безо всяких
денотаций имеем довольно чёткое представление о его семантике. Можно доказать
<span class="cite">[<a href="z1_bibliography.html#sto77">Sto77</a>]</span>, что подобное самоопределение сохраняет все необходимые свойства
<span class="math"><span class="ord var">λ</span></span>-исчисления вроде <span class="math"><span class="ord var">β</span></span>-редукции.</p>

<p>Денотирование <span class="math"><span class="ord var">λ</span></span>-исчислением хорошо работает для языков без побочных
эффектов и продолжений. Но если данные явления в языке всё же присутствуют, то
эффективнее будет использовать другой метод, в котором можно явно задавать
порядок вычислений. Также для работы присваивания необходимо разделить окружение
и память, введя механизм ссылок, как в ML, коробки из четвёртой главы, или нечто
подобное.
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.html#assignment/assignment/ssect:boxes">4.1.1</a>]</span></p>


<h2 id="denotational/sect:varargs"><span class="wrap"><span class="seq">5.4.</span><span class="title">Функции с переменной арностью</span></span></h2>

<!--\indexR{переменная арность}-->
<!--\indexR{арность!переменная}-->
<p>В этом разделе мы покажем, как привнести в Scheme функции с точечным аргументом.
Особенность этих функций в том, что они собирают «лишние» аргументы в список,
который передаётся через последний аргумент. Следовательно, при каждом вызове
подобной функции необходимо создавать в памяти список, что влияет на
производительность. От некоторых проблем нас может избавить функция
<code><span class="func">apply</span></code>,
которая сразу принимает список аргументов и применяет к нему функцию, но ведь
эти списки тоже кто-то должен создать. В общем, переменная арность неразлучно
связана со списками, так что нам потребуются соответствующие функции:
<code><span class="func">car</span></code>,
<code><span class="func">cons</span></code> и т. д.</p>

<!--\indexR{Пары@\protect\Vset{Пары}}-->
<p>Точечные пары принадлежат домену <span class="math"><span class="Vset">Пар</span></span>.
Естественно, этот домен также входит в дизъюнктивную сумму
<span class="math"><span class="Vset">Значений</span></span>. Точечные пары представляются
так же, как и в предыдущей главе: двумя адресами.</p>

<table class="domains"><tbody>
<tr><td class="lhs"><span class="math"><span class="ord Vset">Значения</span><span class="rel"/></span></td>
    <td class="eq"><span class="math"><span class="rel">=</span></span></td>
    <td class="rhs"><span class="math"><span class="rel"/><span class="ord Vset">Функции</span><span class="binop">+</span><span class="ord Vset">Числа</span><span class="binop">+</span><span class="ord Vset">Пары</span><span class="binop">+</span><span class="ord">…</span></span></td></tr>
<tr><td class="lhs"><span class="math"><span class="ord Vset">Пара</span><span class="rel"/></span></td>
    <td class="eq"><span class="math"><span class="rel">=</span></span></td>
    <td class="rhs"><span class="math"><span class="rel"/><span class="ord Vset">Адрес</span><span class="rel">×</span><span class="ord Vset">Адрес</span></span></td></tr>
</tbody></table>

<p>Денотации <code><span class="func">cons</span></code>,
<code><span class="func">car</span></code> и
<code><span class="func">set-cdr!</span></code> (надо же показать хотя бы один
побочный эффект) не таят сюрпризов; мы используем в точности тот же подход, что
и в предыдущей главе. Единственное, о чём стоит договориться, это
ассоциативность операций. Выражение <span class="math"><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Пары</span></sub></span><span class="close">↓<sub><span class="ord num">2</span></sub></span></span> читается слева
направо: первый аргумент <span class="math"><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span></span>, пока ещё значение, проецируется на домен
пар <span class="math"><span class="ord">∣<sub><span class="ord Vset">Пары</span></sub></span></span> (если это значение на самом деле не было парой, то мы
получаем <span class="math"><span class="ord">⊥</span></span>), после чего извлекается <code><span class="var">cdr</span></code> этой пары, её второй
компонент <span class="math"><span class="close">↓<sub><span class="ord num">2</span></sub></span></span>.</p>

<!--\indexC{cons}-->
<!--\indexC{car}-->
<!--\indexC{set-cdr"!}-->
<div class="denotation math"><span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">cons</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord num">2</span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="ord var">allocate</span> <span class="ord var">σ</span> <span class="ord num">2</span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="open">⟨</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">2</span></sub></span><span class="close">⟩</span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="rel">→</span><span class="ord var">ε<sup>∗</sup></span><span class="close">]</span><span class="close">)</span></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div>
<span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">car</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Пары</span></sub></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div>
<span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">set-cdr!</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord num">2</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ</span><span class="open">[</span><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Пары</span></sub></span><span class="close">↓<sub><span class="ord num">2</span></sub></span><span class="rel">→</span><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">2</span></sub></span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div></div>

<p>После определения структуры списков написание <code><span class="func">apply</span></code> не составляет проблем.
Мы собираем в последовательность все элементы формы аппликации, кроме первого
(функции) и последнего. Если предпоследний элемент является списком, то его
необходимо пришить к концу формируемой последовательности. После всех этих
манипуляций выполняется собственно вызов функции.</p>

<!--\indexC{apply}-->
<!--\indexE{collect@\protect<i>collect</i>}-->
<!--\indexE{flat@\protect<i>flat</i>}-->
<!--\indexE{where-and@$\protect\WHERE \ldots \protect\AND \ldots$}-->
<div class="denotation math"><span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">apply</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">⩾</span><span class="ord num">2</span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="open">(</span><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Функции</span></sub></span> <span class="open">(</span><span class="ord var">collect</span> <span class="ord var">ε<sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord"/><span class="rel syntax">where</span><span class="ord var">collect</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord">.</span><div class="valign inline math"><span/><span class="rel syntax">if</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="open">⟨</span><span class="close">⟩</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">flat</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="open">⟨</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">⟩</span><span class="binop">§</span><span class="open">(</span><span class="ord var">collect</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div>
<span class="ord"/><span class="rel syntax">and</span><div class="valign math"><span class="rel"/><span class="ord var">flat</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord var">λ</span><span class="ord var">ε</span><span class="ord">.</span><div class="valign math inline"><span/><span class="rel syntax">if</span><span class="ord var">ε</span><span class="rel">∈</span><span class="ord Vset">Пары</span>
<span/><span class="rel syntax">then</span><span class="open">⟨</span><span class="open">(</span><span class="ord var">σ</span> <span class="ord var">ε</span><span class="ord">∣<sub><span class="ord Vset">Пары</span></sub></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">)</span><span class="close">⟩</span><span class="binop">§</span><span class="open">(</span><span class="ord var">flat</span> <span class="open">(</span><span class="ord var">σ</span> <span class="ord var">ε</span><span class="ord">∣<sub><span class="ord Vset">Пары</span></sub></span><span class="close">↓<sub><span class="ord num">2</span></sub></span><span class="close">)</span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="open">⟨</span><span class="close">⟩</span>
<span/><span class="rel syntax">endif</span></div></div></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div></div>

<p>Здесь <span class="math"><span class="rel syntax">where</span><span class="ord">…</span><span class="rel syntax">and</span><span class="ord">…</span></span> определяет взаимно рекурсивные функции.</p>

<!--\indexR{интерпретатор!B@$\protect\Bind$}-->
<!--\indexE{B@$\protect\Bind$, интерпретатор}-->
<!--\indexR{т ау@$\tau$ (контекст вычислений)}-->
<!--\indexE{t au@$\tau$ (контекст вычислений)}-->
<!--\indexR{м ю@$\mu$ (денотация функции)}-->
<!--\indexE{m u@$\mu$ (денотация функции)}-->
<p>Теперь перейдём к собственно обработке точечных аргументов. Для этого нам
потребуется изменить форму <code><span class="special">lambda</span></code>,
а также ввести ещё один интерпретатор. Его задачей будет правильным образом связывать переменные
и значения. Мы назовём его <span class="math"><span class="ord cal">𝓑</span></span>,
от <em class="term">binding</em>. Его тип связан с типом
<span class="math"><span class="ord cal">𝓔</span></span> для функций; для
краткости обозначим буквой <span class="math"><span class="ord var">μ</span></span>
денотацию функции, для которой <span class="math"><span class="ord cal">𝓑</span></span>
подготавливает аргументы, а для контекста вычислений используем букву
<span class="math"><span class="ord var">τ</span></span>:</p>

<table id="ch5-binding-valuator-explained-table" class="nocaption"><tbody>
<tr><td colspan="4"><span class="math"><span class="ord var">τ</span><span class="rel">≡</span><span class="ord Vset">Значения<sup>∗</sup></span><span class="binop">×</span><span class="ord Vset">Окружение</span><span class="binop">×</span><span class="ord Vset">Продолжение</span><span class="binop">×</span><span class="ord Vset">Память</span></span></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓔</span><span class="ord">:</span><span class="quad-stub" style="width: 1em"/></span></td><td colspan="3"><span class="math"><span class="ord Vset">Программа</span><span class="rel">→</span><span class="open">(</span><span class="ord var">τ</span><span class="rel">→</span><span class="ord Vset">Значение</span><span class="close">)</span></span></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓑</span><span class="ord">:</span><span class="quad-stub" style="width: 1em"/></span></td><td><span class="math"><span class="ord Vset">СписокАргументов</span><span class="rel">→</span><span class="open"><span class="big">(</span></span></span></td><td><span class="math"><span class="open">(</span><span class="ord var">τ</span><span class="rel">→</span><span class="ord Vset">Значение</span><span class="close">)</span></span></td><td><span class="math"><span class="close"/><span class="binop">×</span><span class="ord var">τ</span><span class="rel">→</span><span class="ord Vset">Значение</span><span class="close"><span class="big">)</span></span></span></td></tr>
<tr><td colspan="2"/><td class="low-brace"><span class="math"><span class="ord var">μ</span></span></td><td/></tr>
</tbody></table>

<p><span class="math"><span class="ord cal">𝓑</span></span>, связывающий интерпретатор,
начинает работу после проверки арности. Если с ней всё в порядке, то он заносит один за
другим фактические значения аргументов в память и расширяет лексическое окружение функции
соответствующими переменными. Наконец, управление передаётся телу функции. Определение функций
фиксированной арности с помощью
<span class="math"><span class="ord cal">𝓑</span></span> выглядит так:</p>

<!--\indexC{lambda}-->
<!--\indexE{let-in@$\protect\LET \ldots \IN$}-->
<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span/><span class="rel syntax">then</span><span class="open"><span class="big">(</span></span><span class="open">(</span><span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="ord var">ν<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">ρ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">2</span></sub></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ<sub><span class="ord num">1</span></sub></span> <span class="ord var">κ<sub><span class="ord num">2</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span><span class="close">)</span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">ρ</span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close"><span class="big">)</span></span>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="ord var">ν</span> <span class="ord var">ν<sup>∗</sup></span><span class="close sem-brace">]]</span><span class="ord var">μ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span> <span class="open">(</span><span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="ord var">ν<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">μ</span><span class="close">)</span><span class="close">)</span>
<span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="quad-stub" style="width: 0.1em"/><span class="close sem-brace">]]</span><span class="ord var">μ</span><span class="rel">=</span><span class="ord var">μ</span>
<span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="ord var">ν</span> <span class="ord var">ν<sup>∗</sup></span><span class="close sem-brace">]]</span><span class="ord var">μ</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><span class="ord var">allocate</span> <span class="ord var">σ</span> <span class="ord num">1</span> <span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span>
<span/><span class="rel syntax">in</span><span class="open">(</span><span class="ord var">μ</span> <span class="ord var">ε<sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν</span><span class="rel">→</span><span class="ord var">α</span><span class="close">]</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">]</span><span class="close">)</span></div></div>

<p>Конструкция <span class="math"><span class="rel syntax">let</span><span class="ord">…</span><span class="rel syntax">in</span></span> вводит локальные нерекурсивные определения.</p>

<p>Для обработки случая функций переменной арности потребуется определить
дополнительный синтаксис формы <code><span class="special">lambda</span></code>,
принимающей список с точкой, а также новый вариант
<span class="math"><span class="ord cal">𝓑</span></span>. Эта форма принимает
последовательность «лишних» значений, превращает её в список (настоящий, из точечных пар),
который связывает с именем последнего аргумента. Если учесть, что функции с переменной арностью и
<code><span class="func">apply</span></code> могут использоваться совместно с побочными эффектами,
то подобные списки необходимо создавать заново при каждом вызове. В конце концов,
в стандарте есть требование, чтобы функции вели таким образом. Поэтому следующее
выражение должно возвращать ложь:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">arguments</span> (<span class="func">list</span> <span class="num">1</span> <span class="num">2</span> <span class="num">3</span>)))
  (<span class="func">apply</span> (<span class="special">lambda</span> <span class="var">args</span> (<span class="func">eq?</span> <span class="var">args</span> <span class="var">arguments</span>)) <span class="var">arguments</span>) )</pre>

<p>Если мы не хотим этого делать, то вначале потребуется доказать, что совместное
использование одного и того же физического списка не изменит смысла программы.</p>

<p>Наконец, переходим к денотациям:</p>

<!--\indexE{listify@\protect<i>listify</i>}-->
<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span> . <span class="math"><span class="ord var">ν</span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">⩾</span><span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span/><span class="rel syntax">then</span><span class="open"><span class="big">(</span></span><div class="valign math"><span class="open"/><span class="open">(</span><span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="ord var">ν<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="open">(</span><span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="normal"><code>. <span class="math"><span class="ord var">ν<sup>∗</sup></span></span></code></span><span class="close sem-brace">]]</span> <span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">ρ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">2</span></sub></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ<sub><span class="ord num">1</span></sub></span> <span class="ord var">κ<sub><span class="ord num">2</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span><span class="close">)</span><span class="close">)</span>
<span/><span class="ord var">ε<sup>∗</sup></span> <span class="ord var">ρ</span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close"><span class="big">)</span></span></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<div class="valign math"><span class="ord cal">𝓑</span><span class="open sem-brace">[[</span><span class="normal"><code>. <span class="math"><span class="ord var">ν<sup>∗</sup></span></span></code></span><span class="close sem-brace">]]</span><span class="ord var">μ</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><span class="open"><span class="big">(</span></span><span class="ord var">listify</span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">σ</span> <div class="valign inline math"><span/><span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><stub/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord num">1</span>
<span class="quad-stub" style="width: 0.5em"/><span/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><div class="valign inline math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span>
<span/><span class="rel syntax">in</span><span class="open">(</span><span class="ord var">μ</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν</span><span class="rel">→</span><span class="ord var">α</span><span class="close">]</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span><span class="close"><span class="big">)</span></span></div></div></div>
<span class="quad-stub" style="width: 0.5em"/><span class="rel syntax">where</span><span class="ord var">listify</span><span class="rel">=</span><div class="valign inline math"><span class="rel"/><span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="rel">&gt;</span><span class="ord num">0</span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord num">2</span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><div class="valign inline math"><span/><span class="rel syntax">let</span><span class="ord var">κ<sub><span class="ord num">2</span></sub></span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">3</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">α<sup>∗</sup></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">3</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">2</span></sub></span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="open">(</span><span class="ord var">listify</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="rel">→</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">]</span> <span class="ord var">κ<sub><span class="ord num">2</span></sub></span><span class="close">)</span></div></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="open">⟨</span><span class="close">⟩</span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div></div></div></div>

<!--\indexR{переменная арность!сложность}-->
<p>Как видите, введение нетривиальных возможностей вроде функций переменной арности
требует существенных усилий. Нам пришлось, фактически, написать ещё один
интерпретатор. Если сравнить получившуюся версию с элегантной реализацией ядра
Scheme, то станет очевидным, что добавление всего одной интересной, но всё же
несущественной детали почти удвоило размер кода, не говоря уже о читабельности
и понятности.</p>


<h2 id="denotational/sect:eval-order"><span class="wrap"><span class="seq">5.5.</span><span class="title">Порядок вычисления аргументов</span></span></h2>

<!--\indexR{порядок вычислений!в Scheme и Си}-->
<p>Время от времени в Интернете вспыхивают яростные религиозные войны по поводу
толкования стандартов Scheme. Данная книга строго следует стандарту: порядок
вычисления термов аппликации не определён. К сожалению, из-за этого правила
сложно не только писать корректные программы, зависящие от конкретного порядка,
но и отлаживать некорректные. Многие программы, даже некоторые из написанных
видными экспертами, неявно зависят от порядка вычислений; особенно программы,
использующие продолжения. Лично я предпочитаю порядок слева направо, так как
он соответствует направлению чтения во многих языках, а также привносит хоть
какую-то систематичность в поиск ошибок.</p>

<p>Особый интерес среди доводов противоборствующей стороны представляют
следующие два. Первый из них состоит в том, что многие языки не указывают
порядок вычислений. Даже императивный Си не указывает порядок вычисления
аргументов функций. Если выражение <code>(<span class="func">foo</span>
(<span class="func">f</span> <span class="var">x</span>) (<span class="func">g</span>
<span class="var">x</span> <span class="var">y</span>))</code> транслируется
в следующий код на Си: <code class="c"><span class="func">foo</span>(<span class="func">f</span>(<span class="var">x</span>), <span class="func">g</span>(<span class="var">x</span>, <span class="var">y</span>))</code>, то нам действительно
не следует полагаться на какой-либо порядок.</p>

<p>Второй довод больше философский. В языке без предопределённого порядка
вычислений его всё же можно явно установить самостоятельно с помощью
<code><span class="special">begin</span></code>.
Следовательно, порядок всё же есть, просто «не определён» следует читать как
«не определён нами». Поэтому для истинной неопределённости реализация языка
должна использовать какой-нибудь генератор случайных чисел, который будет
определять «неопределённый» порядок непосредственно перед вычислениями.
<span class="see">[см. упр. <a href="#denotational/ex:truly-random">5.1</a>]</span></p>

<p>В Си порядок в действительности не определяется для того, чтобы разрешить
компилятору выбирать любой необходимый ему порядок, например, чтобы эффективнее
распределять регистры.</p>

<p>Явный порядок вычислений упрощает отладку, делая одной неопределённостью меньше.
Если порядок будет случайным, то два прогона одной и той же программы на одних и
тех же данных могут дать разные результаты. Рассмотрим пример<a class="footref"
href="zz_footnotes.html#foot5.4"><sup>4</sup></a>:</p>

<!--\indexC{dynamically-changing-evaluation-order}-->
<!--\indexC{amb}-->
<pre>(<span class="special">define</span> (<span class="func">dynamically-changing-evaluation-order?</span>)
  (<span class="special">define</span> (<span class="func">amb</span>)
    (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) ((<span class="func">k</span> <span class="hash">#t</span>) (<span class="func">k</span> <span class="hash">#f</span>)))) )
  (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">amb</span>) (<span class="func">amb</span>))
    (<span class="func">dynamically-changing-evaluation-order?</span>)
    <span class="hash">#t</span> ) )</pre>

<p>Функция <code><span class="func">amb</span></code> возвращает истину или ложь
в зависимости от того, какой терм вычисляется первым. Если порядок вычислений не фиксирован,
то функция <code><span class="func">dynamically-changing-evaluation-order?</span></code>
рано или поздно остановится и вернёт <code><span class="hash">#t</span></code>; иначе она
попадает в бесконечный цикл. В R<sup>5</sup>RS нет ничего, что требовало бы от этой функции
того или иного поведения. Оно зависит исключительно от реализации.</p>


<!--\indexR{порядок вычислений!неопределённый}-->
<p>Необходимо чётко отделять реализацию языка от его стандарта. Интерпретатор или
компилятор по очевидным причинам вынуждены использовать хоть какой-нибудь
порядок. Не особо важно, слева направо, или справа налево, как MacScheme, или
хоть в зависимости от текущей фазы Луны. Но ни одна из известных мне реализаций
не изменяет всерьёз порядок вычисления аргументов во время выполнения программы.
Обычно порядок устанавливается при компиляции, после чего к этому вопросу больше
не возвращаются. Поэтому неопределённость порядка всё же следует понимать как
привилегию выбирать любой, а не обязанность поддерживать случайный.</p>

<!--\indexR{результат@\protect\Vset{Результат}}-->
<p>Проблема в том, как показать в денотациях неопределённость порядка, но в то же
время разрешить реализациям определять свой порядок, используя одни и те же
денотации. Идея решения данной проблемы состоит в небольшом изменении структуры
денотаций. Сейчас они считаются <span class="math"><span class="ord var">λ</span></span>-термами, которые принимают окружение,
продолжение и память, а потом возвращают некоторый результат. Данный результат
принадлежит домену <span class="math"><span class="Vset">Значений</span></span>,
но ведь на самом деле он неразрывно связан
с состоянием памяти: мы говорили, что побочные эффекты — это тоже результат
работы программы. Поэтому нам стоит сделать результатом вычислений именно пару
(<i>значение</i>, <i>память</i>). Мы не будем заниматься философствованиями на тему
того, чем именно является результат вычислений, а просто сделаем областью
значений денотаций домен <span class="math"><span class="Vset">Результатов</span></span>.</p>

<!--\indexR{порядок вычислений!неопределённый!денотация}-->
<!--\indexR{интерпретатор!N@$\protect\Noir\mskip-\thinmuskip$}-->
<!--\indexE{N@$\protect\Noir\mskip-\thinmuskip$, интерпретатор}-->
<!--\indexE{P@$\mathcal{P}(Q)$ (множество)}-->
<p>Так как вычисления могут проходить по-разному, то и денотации будут возвращать
не один результат, а множество всех возможных результатов в зависимости от
порядка вычислений. Реализация же будет выбирать из этого множества какой-нибудь
один, руководствуясь собственными соображениями. Следовательно,
<span class="math"><span class="ord cal">𝓔</span></span> теперь
соответствует обобщённому результату, а конкретная реализация представляется
функцией <span class="math"><span class="ord cal">𝓝</span></span>. Если
обозначить множество всех подмножеств <span class="math"><span class="ord var">Q</span></span>
как <span class="math"><span class="ord cal">𝓟</span><span class="open">(</span><span class="ord var">Q</span><span class="close">)</span></span>,
то эти функции имеют следующие типы:</p>

<table class="nocaption"><tbody>
<tr><td><span class="math"><span class="ord cal">𝓔</span><span class="ord">:</span><span class="quad-stub" style="width: 1em"/><span class="ord Vset">Программа</span><span class="rel">→</span><span class="ord Vset">Значения<sup>∗</sup></span><span class="binop">×</span><span class="ord Vset">Окружение</span><span class="binop">×</span></span></td></tr>
<tr><td><span class="math"><span class="quad-stub" style="width: 10em"/><span class="binop">×</span><span class="ord Vset">Продолжение</span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord cal">𝓟</span><span class="open">(</span><span class="ord Vset">Результаты</span><span class="close">)</span></span></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓝</span><span class="ord">:</span><span class="quad-stub" style="width: 1em"/><span class="ord Vset">Программа</span><span class="rel">→</span><span class="ord Vset">Значения<sup>∗</sup></span><span class="binop">×</span><span class="ord Vset">Окружение</span><span class="binop">×</span></span></td></tr>
<tr><td><span class="math"><span class="quad-stub" style="width: 10em"/><span class="binop">×</span><span class="ord Vset">Продолжение</span><span class="binop">×</span><span class="ord Vset">Память</span><span class="rel">→</span><span class="ord Vset">Результат</span></span></td></tr>
</tbody></table>

<!--\indexE{oneof@\protect<i>oneof</i>}-->
<p><span class="math"><span class="ord cal">𝓝</span></span> определяется просто:
она использует <span class="math"><span class="ord var">oneof</span></span>,
чтобы выбрать один из возможных результатов. Определение функции
<span class="math"><span class="ord var">oneof</span></span>, естественно,
возлагается на реализацию.</p>

<div class="denotation math"><span class="ord cal">𝓝</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">oneof</span> <span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span><span class="close">)</span></div>

<p>Теперь необходимо переопределить аппликацию функций так, чтобы получать все
возможные результаты. Если порядок случаен, то это фактически значит, что
аппликация выполняется так: сначала выбирается случайный терм, обозначим
его <span class="math"><span class="ord var">π<sub><span class="ord num">0</span></sub><sup>′</sup></span></span>, он вычисляется в <span class="math"><span class="ord var">ε<sub><span class="ord num">0</span></sub><sup>′</sup></span></span>, потом из оставшихся выбирается следующий
терм <span class="math"><span class="ord var">π<sub><span class="ord num">0</span></sub><sup>′</sup></span></span>, который вычисляется в <span class="math"><span class="ord var">ε<sub><span class="ord num">0</span></sub><sup>′</sup></span></span>, и так далее. Затем значения
<span class="math"><span class="ord var">ε<sub><span class="ord num">0</span></sub><sup>′</sup></span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>′</sup></span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord var">n</span></sub><sup>′</sup></span></span>
переупорядочиваются так, как они шли в исходной форме:
<span class="math"><span class="ord var">ε<sub><span class="ord num">0</span></sub></span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">ε<sub><span class="ord var">n</span></sub></span></span>, и, наконец, первое значение-функция
применяется к последовательности из всех остальных. При таком подходе порядок
вычислений действительно случаен для каждого отдельного вызова, а не выбирается
и фиксируется для каждой функции. Рассмотрим пример. Следующая функция не только
выводит неопределённое число, но и продолжение, которое она возвращает, тоже
выводит неопределённое число.</p>

<!--\indexC{one-two-three}-->
<pre>(<span class="special">define</span> (<span class="func">one-two-three</span>)
  (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>)
             ((<span class="special">begin</span> (<span class="func">display</span> <span class="num">1</span>) (<span class="func">call/cc</span> <span class="var">k</span>))
              (<span class="special">begin</span> (<span class="func">display</span> <span class="num">2</span>) (<span class="func">call/cc</span> <span class="var">k</span>))
              (<span class="special">begin</span> (<span class="func">display</span> <span class="num">3</span>) (<span class="func">call/cc</span> <span class="var">k</span>)) ) )) )</pre>

<!--\indexE{forall@\protect<i>forall</i>}-->
<!--\indexE{cut@\protect<i>cut</i>}-->
<!--\indexR{стиль передачи продолжений (CPS)}-->
<!--\indexE{CPS}-->
<p>Денотация аппликации с неопределённым порядком вычисления аргументов будет
выполнять именно то, что мы сказали ранее. Она рассмотрит все возможные
перестановки аргументов с помощью функции
<span class="math"><span class="ord var">forall</span></span>, которая применяет свой
первый аргумент (тернарную функцию) ко всем возможным срезам своего второго
аргумента (списка). Срезы предоставляются функцией
<span class="math"><span class="ord var">cut</span></span>, которая разрезает
список на две части: одна из них содержит первые
<span class="math"><span class="ord var">i</span></span> элементов, другая — все
оставшиеся; затем <span class="math"><span class="ord var">cut</span></span>
применяет свой третий аргумент (продолжение) к этим
двум частям. Определения слегка запутанные, но это хороший пример стиля передачи
продолжений. (Данная программа была разработана в сотрудничестве с Софи Англад и
Жан-Жаком Лакрампом
<span class="cite">[<a href="z1_bibliography.html#alq95">ALQ95</a>]</span>.)</p>

<!--\indexE{possible-paths@\protect<i>possible-paths</i>}-->
<!--\indexE{loop@\protect<i>loop</i>}-->
<!--\indexE{accumulate@\protect<i>accumulate</i>}-->
<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π<sub><span class="ord num">0</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> ... <span class="math"><span class="ord var">π<sub><span class="ord var">n</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open"><span class="big">(</span></span><div class="valign math"><span class="open"/><span class="open">(</span><span class="ord var">possible-paths</span> <span class="open">⟨</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">0</span></sub></span><span class="close sem-brace">]]</span><span class="punct">,</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord var">n</span></sub></span><span class="close sem-brace">]]</span><span class="close">⟩</span><span class="close">)</span>
<span/><span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Функции</span></sub></span> <span class="ord var">ε<sup>∗</sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close"><span class="big">)</span></span></div>
<span class="open">(</span><span class="ord var">possible-paths</span> <span class="ord var">μ<sup><span class="binop">+</span></sup></span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord var">λ</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">μ<sup><span class="binop">+</span></sup></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="rel">&gt;</span><span class="ord num">0</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">forall</span> <div class="valign math"><span/><span class="ord var">λ</span><span class="ord var">μ<sub><span class="ord num">1</span></sub><sup><span class="binop">+</span></sup></span><span class="ord var">μ</span><span class="ord var">μ<sub><span class="ord num">2</span></sub><sup><span class="binop">+</span></sup></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><span class="open">(</span><span class="ord var">μ</span> <span class="ord var">ρ</span> <div class="valign math"><span/><span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><span class="open">(</span><div class="valign math"><span class="open"/><span class="open">(</span><span class="ord var">possible-paths</span> <span class="ord var">μ<sub><span class="ord num">1</span></sub><sup><span class="binop">+</span></sup></span><span class="binop">§</span><span class="ord var">μ<sub><span class="ord num">2</span></sub><sup><span class="binop">+</span></sup></span><span class="close">)</span>
<span/><span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><div class="valign inline math"><span/><span class="rel syntax">let</span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">ε<sub><span class="ord num">2</span></sub><sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="binop">§</span><span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span><span class="binop">§</span><span class="ord var">ε<sub><span class="ord num">2</span></sub><sup>∗</sup></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="open">(</span><span class="ord var">cut</span> <span class="ord">#</span><span class="ord var">μ<sub><span class="ord num">1</span></sub><sup><span class="binop">+</span></sup></span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="close">)</span></div>
<span/><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span> <span class="ord var">μ<sup><span class="binop">+</span></sup></span><span class="close">)</span></div></div></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">μ<sup><span class="binop">+</span></sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div>
<div class="valign math"><stub/><span class="open">(</span><span class="ord var">forall</span> <span class="ord var">φ</span> <span class="ord var">ℓ</span><span class="close">)</span><span class="rel">=</span><span class="open">(</span><span class="ord var">loop</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">ℓ</span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">ℓ</span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span class="quad-stub" style="width: 0.5em"/><span class="rel syntax">where</span><span class="ord var">loop</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ℓ<sub><span class="ord num">1</span></sub></span><span class="ord var">ε</span><span class="ord var">ℓ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">φ</span> <span class="ord var">ℓ<sub><span class="ord num">1</span></sub></span> <span class="ord var">ε</span> <span class="ord var">ℓ<sub><span class="ord num">2</span></sub></span><span class="close">)</span><span class="binop">∪</span><span class="ord"/><div class="valign inline math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ℓ<sub><span class="ord num">2</span></sub></span><span class="rel">&gt;</span><span class="ord num">0</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">loop</span> <span class="ord var">ℓ<sub><span class="ord num">1</span></sub></span><span class="binop">§</span><span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span> <span class="ord var">ℓ<sub><span class="ord num">2</span></sub></span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">ℓ<sub><span class="ord num">2</span></sub></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="ord">Ø</span>
<span/><span class="rel syntax">endif</span></div></div>
<div class="valign math"><span/><span class="open">(</span><span class="ord var">cut</span> <span class="ord var">ι</span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">κ</span><span class="close">)</span><span class="rel">=</span><span class="open">(</span><span class="ord var">accumulate</span> <span class="ord var">ι</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">ε<sup>∗</sup></span><span class="close">)</span>
<span class="quad-stub" style="width: 0.5em"/><span class="rel syntax">where</span><span class="ord var">accumulate</span><span class="rel">=</span><span class="ord var">λ</span><span class="ord var">ι</span><span class="ord var">ℓ</span><span class="ord var">ℓ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign inline math"><span/><span class="rel syntax">if</span><span class="ord var">ι</span><span class="rel">&gt;</span><span class="ord num">0</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">accumulate</span> <span class="open">(</span><span class="ord var">ι</span><span class="binop">−</span><span class="ord num">1</span><span class="close">)</span> <span class="open">⟨</span><span class="ord var">ℓ<sub><span class="ord num">1</span></sub></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">⟩</span><span class="binop">§</span><span class="ord var">ℓ</span> <span class="ord var">ℓ<sub><span class="ord num">1</span></sub></span><span class="close">↑<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">reverse</span> <span class="ord var">ℓ</span><span class="close">)</span> <span class="ord var">ℓ<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div></div></div>

<!--\indexE{Scheme!параллельные вычисления}-->
<p>Во всех приведённых случаях порядок вычисления аргументов является
неопределённым, но сами вычисления остаются последовательными — это
требование стандарта: результат должен быть эквивалентен вычислению аргументов
в какой-нибудь последовательности. То есть следующая программа может вернуть
<code>(<span class="num">3</span> <span class="num">5</span>)</code> или <code>(<span class="num">4</span> <span class="num">3</span>)</code>, но никак не <code>(<span class="num">3</span> <span class="num">3</span>)</code>:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">x</span> <span class="num">1</span>) (<span class="var">y</span> <span class="num">2</span>))
  (<span class="func">list</span> (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">x</span> (<span class="func">+</span> <span class="var">x</span> <span class="var">y</span>)) <span class="var">x</span>)
        (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">y</span> (<span class="func">+</span> <span class="var">x</span> <span class="var">y</span>)) <span class="var">y</span>) ) )</pre>

<p>Денотация следующей программы, полученная с помощью новой
  <span class="math"><span class="ord cal">𝓔</span></span>, будет
возвращать два возможных результата: <code><span class="func">1</span></code> и
<code><span class="func">2</span></code>. Конкретная реализация
сможет выбрать один из них с помощью <span class="math"><span class="ord cal">𝓝</span></span>
и <span class="math"><span class="ord var">oneof</span></span>.</p>

<pre>(<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) ((<span class="func">k</span> <span class="num">1</span>) (<span class="func">k</span> <span class="num">2</span>)))) <span class="math"><span class="rel">→</span></span> <span class="math"><span class="open">{</span><span class="ord normal"><code><span class="num">1</span></code></span><span class="punct">,</span> <span class="ord normal"><code><span class="num">2</span></code></span><span class="close">}</span></span></pre>


<h2 id="denotational/sect:dynamic"><span class="wrap"><span class="seq">5.6.</span><span class="title">Динамическое связывание</span></span></h2>

<!--\indexR{динамическое связывание}-->
<!--\indexR{связывание!динамическое}-->
<!--\indexR{окружение!динамическое}-->
<p>Идея динамического связывания не только важна сама по себе, но и действительно
полезна. В конце концов, довольно долгое время разнообразные диалекты Лиспа были
именно динамическими. Поэтому мы просто не можем обойти стороной эту идею и
не показать её денотацию. Для этого нам потребуется поправить ядро Scheme, а
также добавить несколько специальных форм для работы с новым типом привязок.
Конечно, есть далеко не один вариант реализации динамического окружения; взять
хотя бы возможность использовать или специальные формы, или же
специализированные функции.
<span class="see">[см. раздел <a href="ch02_lisp_1_2_omega.html#lisp1-2-omega/namespaces/ssect:dyn-vars-no-special">2.5.3</a>]</span>
Традиционно в Scheme принят второй подход, чтобы как можно меньше вмешиваться в ядро языка.
К сожалению, не все функции можно отделить от ядра, даже если они вызываются,
используются и ведут себя именно как функции. Например,
<code><span class="func">call/cc</span></code>: ей
необходим доступ к продолжениям. Аналогично, всем функциям для работы
с динамическими переменными потребуется доступ к окружению динамических
переменных. Доработанное ядро Scheme приведено
в таблице <a href="#denotational/dynamic/fig:dynamic-scheme">5.3</a>.</p>

<table id="denotational/dynamic/fig:dynamic-scheme" class="semantic">
<!--\indexE{Scheme!семантика!динамическое окружение}-->
<tbody>
<tr><td><div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">if</span> <span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><div class="valign math"><span/><span class="rel syntax">if</span> <span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span>
<span/><span class="rel syntax">then</span> <span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">else</span> <span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">endif</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">set!</span> <span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">δ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">α<sup>∗</sup></span><span class="close">]</span> <span class="ord var">δ<sub><span class="ord num">1</span></sub></span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">ε<sup>∗</sup></span><span class="close">]</span><span class="close">)</span></div></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<div class="valign math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">φ</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">φ</span><span class="ord">∣<sub><span class="ord Vset">Функции</span></sub></span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">δ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span><span class="binop">§</span><span class="ord var">ε<sup>∗</sup></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="quad-stub" style="width: 0.1em"/><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">begin</span> <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open"><span class="big">(</span></span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close"><span class="big">)</span></span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">call/cc</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><div class="valign math"><span class="open"/><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Функция</span></sub></span>
<span class="open">⟨</span><span class="ord Vset">Значение</span><span class="open">(</span><div class="valign math inline"><span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">δ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span><span class="close">⟩</span> <span class="ord var">δ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div></div></td></tr>
</tbody></table>
<span class="caption">Таблица 5.3. Scheme с динамическим окружением.</span>

<!--\indexR{д ельта@$\d$ (динамическое окружение)}-->
<!--\indexE{d elta@$\d$ (динамическое окружение)}-->
<!--\indexR{память!однопоточность}-->
<p>Динамическое окружение, обозначаемое <span class="math"><span class="ord var">δ</span></span>,
отличается от лексического <span class="math"><span class="ord var">ρ</span></span>. Оно
передаётся только туда, где его можно использовать. Отличается оно и от
памяти <span class="math"><span class="ord var">σ</span></span>, которая
является <em class="term">однопоточной</em>: каждое вычисление принимает
память, достаёт значения нужных переменных или изменяет их, после чего передаёт
новое состояние памяти дальше. Поток передачи памяти только один, в каждый
момент времени существует только одно актуальное состояние памяти. Динамическое
окружение хоть и передаётся от функции к функции похожим образом, но поток может
разделяться, например, при вычислении термов аппликации.</p>


<!--\indexR{ДинамическоеОкружение@\protect\Vset{ДинамическоеОкружение}}-->
<p>Динамические окружения принадлежат одноимённому домену, определяемому следующим
образом:</p>

<blockquote class="equation math"><span class="ord var">δ</span><span class="quad-stub" style="width: 1em"/><span class="ord Vset">ДинамическоеОкружение</span><span class="rel">=</span><span class="ord Vset">Переменная</span><span class="rel">→</span><span class="ord Vset">Значение</span></blockquote>

<p id="denotational/dynamic/par:two-forms">Для работы с динамическим окружением предназначены две
специальные формы: <code><span class="special">dynamic-let</span></code> и <code><span class="special">dynamic</span></code>. Форма <code><span class="special">dynamic-let</span></code> устанавливает
динамическую связь между <i>переменной</i> и <i>значением</i> на время вычисления
<i>тела</i>. Она обрабатывает только одну переменную за раз, но это не проблема
(макросы). Форма <code><span class="special">dynamic</span></code> возвращает текущее значение динамической
переменной; или ошибку, если запрошенная переменная не существует. Так как
изменять динамические привязки мы запрещаем, то данное окружение связывает
переменные со значениями напрямую, без посредников в виде адресов. Семантика
рассмотренных форм показана
в таблице <a href="#denotational/dynamic/fig:dynamic-semantics">5.4</a>, а вот их синтаксис:</p>

<!--\indexC{dynamic-let}-->
<!--\indexC{dynamic}-->
<pre>(<span class="special">dynamic-let</span> (<i>переменная</i> <i>значение</i>) <i>тело</i>...)
(<span class="special">dynamic</span> <i>переменная</i>)</pre>

<table id="denotational/dynamic/fig:dynamic-semantics" class="semantic">
<!--\indexR{динамическое связывание!семантика}-->
<!--\indexR{д ельта0@$\delta_0$ (начальное окружение)}-->
<!--\indexE{d elta0@$\delta_0$ (начальное окружение)}-->
<tbody>
<tr><td><div class="denotation math"><span class="open">(</span><span class="ord var">δ<sub><span class="ord num">0</span></sub></span> <span class="ord var">ν</span><span class="close">)</span><span class="rel">=</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"No such dynamic variable"</span></code></span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">dynamic</span> <span class="math"><span class="ord var">ν</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">δ</span> <span class="ord var">ν</span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<div class="valign math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">dynamic-let</span> (<span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">δ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">δ</span><span class="open">[</span><span class="ord var">ν</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div></div></td></tr>
</tbody></table>
<span class="caption">Таблица 5.4. Семантика специальных форм динамического связывания.</span>

<p>Приведённая денотация довольно очевидна. Формы получают значение из
динамического окружения или же расширяют его, таким образом мы получаем второе
пространство имён для динамических переменных, отделённое от пространства
лексических. И снова вы можете убедиться в огромной информативности подобной
записи: лишь несколькими греческими буквами описывается новое пространство имён.
Денотационная семантика одарит своей силой любого, кто сможет разобраться
в её тайнописи.</p>

<!--\indexR{обработка ошибок}-->
<p>Идея динамического окружения находит применение не только просто для переменных,
но и при обработке ошибок, для реализации переходов и иных механизмов управления
потоком исполнения <span class="cite">[<a href="z1_bibliography.html#hd90">HD90</a>, <a href="z1_bibliography.html#qd93">QD93</a>]</span>. Рассмотрим, например, простой, собранный
на коленке механизм обработки ошибок: в случае неожиданной ситуации функция
создаёт объект, описывающий, что именно произошло, и передаёт его функции,
хранящейся в динамической переменной <code><span class="var">*error*</span></code>. Теперь можно на любые
вычисления навесить нужный нам обработчик ошибок, обернув эти вычисления в форму
<code><span class="special">dynamic-let</span></code>, устанавливающую необходимую функцию в <code><span class="var">*error*</span></code>. Например,
стандарт Scheme требует, чтобы попытка открыть несуществующий файл вызывала
ошибку, но, к сожалению, он не определяет функцию, позволяющую заранее
проверить, существует ли файл. Используя динамические переменные, мы можем
написать подобный предикат самостоятельно:</p>

<!--\indexC{file-exists"?}-->
<pre>(<span class="special">define</span> (<span class="func">file-exists?</span> <span class="var">filename</span>)
  (<span class="special">dynamic-let</span> (<span class="var">*error*</span> (<span class="special">lambda</span> (<span class="var">anomaly</span>) <span class="hash">#f</span>))
    (<span class="func">call-with-input-file</span> <span class="var">filename</span>
      (<span class="special">lambda</span> (<span class="var">port</span>) <span class="hash">#t</span>) ) ) )</pre>

<p>Это приближённое определение, так как в действительности надо ещё проверить,
что <code><span class="var">*error*</span></code> вызвана потому, что файл действительно не существует, а не,
например, потому что мы исчерпали лимит открытых портов ввода. Для этого
необходимо знать структуру объектов, которые <code><span class="func">call-with-input-file</span></code> может
положить в <code><span class="var">anomaly</span></code>.</p>


<h2 id="denotational/sect:global"><span class="wrap"><span class="seq">5.7.</span><span class="title">Глобальное окружение</span></span></h2>

<!--\indexR{глобальное окружение}-->
<!--\indexR{окружение!глобальное}-->
<!--\indexR{г амма@$\g$ (глобальное окружение)}-->
<!--\indexE{g amma@$\g$ (глобальное окружение)}-->
<p>В этом разделе мы изучим глобальное окружение, рассмотрев несколько вариантов
его денотации. Добавляется оно аналогично динамическому окружению
<span class="math"><span class="ord var">δ</span></span>. Как и
локальное окружение <span class="math"><span class="ord var">ρ</span></span>,
глобальное окружение <span class="math"><span class="ord var">γ</span></span>
переводит идентификаторы в адреса. Глобальное окружение следует тенью за памятью:
всякое вычисление теперь принимает, возможно использует и передаёт дальше не только
память, но и глобальное окружение. В таблице
<a href="#denotational/global/fig:global-scheme">5.5</a>
приведена денотация ядра Scheme с глобальным окружением. Из неё пока исключены
ссылки на переменные и присваивание, их мы рассмотрим чуть позже.</p>

<table id="denotational/global/fig:global-scheme" class="semantic">
<!--\indexE{Scheme!семантика!глобальное окружение}-->
<tbody>
<tr><td><div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">if</span> <span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><div class="valign math"><span/><span class="rel syntax">if</span> <span class="open">(</span><span class="ord var">boolify</span> <span class="ord var">ε</span><span class="close">)</span>
<span/><span class="rel syntax">then</span> <span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">1</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">else</span> <span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="close sem-brace">]]</span>
<span/><span class="rel syntax">endif</span> <span class="ord var">ρ</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">α<sup>∗</sup></span><span class="close">]</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">ε<sup>∗</sup></span><span class="close">]</span><span class="close">)</span></div></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span> <span class="ord var">γ</span> <span class="ord var">σ</span><span class="close">)</span></div>
<div class="valign math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">φ</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">γ<sub><span class="ord num">2</span></sub></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">φ</span><span class="ord">∣<sub><span class="ord Vset">Функции</span></sub></span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">γ<sub><span class="ord num">2</span></sub></span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<div class="valign math"><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">γ<sub><span class="ord num">2</span></sub></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span><span class="binop">§</span><span class="ord var">ε<sup>∗</sup></span> <span class="ord var">γ<sub><span class="ord num">2</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>
<span class="ord cal">𝓔<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="quad-stub" style="width: 0.1em"/><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">γ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">begin</span> <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open"><span class="big">(</span></span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close"><span class="big">)</span></span>
<span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="open">(</span><span class="ord var">σ<sub><span class="ord num">0</span></sub></span> <span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="open sem-brace">[[</span><span class="normal"><code><span class="func">call/cc</span></code></span><span class="close sem-brace">]]</span><span class="close">)</span><span class="close">)</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><div class="valign math"><span class="open"/><span class="ord var">ε<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="ord">∣<sub><span class="ord Vset">Функция</span></sub></span>
<span class="open">⟨</span><span class="ord Vset">Значение</span><span class="open">(</span><div class="valign inline math"><span class="ord var">λ</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span>
<span class="quad-stub" style="width: 0.5em"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="rel">=</span><span class="ord num">1</span>
<span/><span class="rel syntax">then</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε<sub><span class="ord num">1</span></sub><sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span><span class="close">⟩</span> <span class="ord var">γ</span> <span class="ord var">κ</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span></div></div></td></tr>
</tbody></table>
<span class="caption">Таблица 5.5. Scheme с глобальным окружением.</span>


<h3 id="denotational/global/ssect:in-scheme"><span class="wrap"><span class="seq">5.7.1.</span><span class="title">Глобальное окружение в Scheme</span></span></h3>

<p>С помощью подобного базиса можно реализовать несколько вариантов глобального
окружения. В стандарте Scheme используется следующая вариация:
1) получить значение переменной можно только если она существует
и инициализирована;
2) изменять значение переменной можно только если она существует;
3) переопределение переменной эквивалентно присваиванию.</p>

<!--\indexR{ГлобальноеОкружение@\protect\Vset{ГлобальноеОкружение}}-->
<!--\indexR{ЛокальноеОкружение@\protect\Vset{ЛокальноеОкружение}}-->
<!--\indexE{no-binding@\protect<i>no-binding</i>}-->
<!--\indexE{no-global-binding@\protect<i>no-global-binding</i>}-->
<p>Чтобы выразить первые два правила, нам необходим способ проверки, определена ли
переменная в окружении. Для этого расширим область значений окружений: к домену
адресов прибавим специальное значение, которое не является адресом и обозначает
отсутствие привязки в окружении:</p>

<table class="domains">
<tr><td class="lhs"><span class="math"><span class="ord Vset">ЛокальноеОкружение</span><span class="ord">:</span></span></td><td class="rhs"><span class="math"><span class="quad-stub" style="width: 1em"/><span class="ord Vset">Переменная</span><span class="rel">→</span><span class="ord Vset">Адрес</span><span class="binop">+</span><span class="open">{</span><span class="ord var">no-binding</span><span class="close">}</span></span></td></tr>
<tr><td class="lhs"><span class="math"><span class="ord Vset">ГлобальноеОкружение</span><span class="ord">:</span></span></td><td class="rhs"><span class="math"><span class="quad-stub" style="width: 1em"/><span class="ord Vset">Переменная</span><span class="rel">→</span><span class="ord Vset">Адрес</span><span class="binop">+</span><span class="open">{</span><span class="ord var">no-global-binding</span><span class="close">}</span></span></td></tr>
</table>

<p>Теперь смысл ссылок и присваиваний должен быть ясен: сначала мы ищем локальную
переменную, если не находим, то продолжаем искать уже в глобальном окружении.
В итоге у нас на руках или адрес, с которым мы идём к памяти, или
<span class="math"><span class="ord">⊥</span></span>,
который отдаётся как есть. Конечно, кроме этого ещё надо подправить начальные
окружения.</p>

<div class="denotation math"><span class="open">(</span><span class="ord var">ρ<sub><span class="ord num">0</span></sub></span> <span class="ord var">ν</span><span class="close">)</span><span class="rel">=</span><span class="ord var">no-binding</span>
<span class="open">(</span><span class="ord var">γ<sub><span class="ord num">0</span></sub></span> <span class="ord var">ν</span><span class="close">)</span><span class="rel">=</span><span class="ord var">no-global-binding</span>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">ν</span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">no-binding</span>
<span/><span class="rel syntax">then</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="open">(</span><span class="ord var">γ</span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="ord var">no-global-binding</span>
<span/><span class="rel syntax">then</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"No such variable"</span></code></span>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">γ</span> <span class="ord var">σ</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="ord var">α</span><span class="close">)</span> <span class="ord var">γ</span> <span class="ord var">σ</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div></div>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">set!</span> <span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">no-binding</span>
<span/><span class="rel syntax">then</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="open">(</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="ord var">no-global-binding</span>
<span/><span class="rel syntax">then</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"No such variable"</span></code></span>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>

<p>Пусть глобальные переменные определяются специальной формой
<code><span class="special">define</span></code>, причём
для простоты положим, что она (пере)определяет исключительно <em class="term">глобальные</em>
переменные (даже если находится внутри определения функции). Поэтому назовём её
<code><span class="special">define-global</span></code>. Итак, запишем её денотацию,
которая должна или создать новую переменную, или изменить значение уже существующей:</p>

<!--\indexC{define-global}-->
<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">define-global</span> <span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="open">(</span><span class="ord var">γ</span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">no-global-binding</span>
<span/><span class="rel syntax">then</span><span class="ord"/><div class="valign math"><span/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord num">1</span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">ν</span><span class="rel">→</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">]</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>

<!--\indexR{г амма0@$\g_0$ (начальное окружение)}-->
<!--\indexE{g amma0@$\g_0$ (начальное окружение)}-->
<p>Единственная деталь, оставшаяся недоработанной, — это начальное состояние
глобального окружения <span class="math"><span class="ord var">γ<sub><span class="ord num">0</span></sub></span></span>. Сейчас в нём нет ни одной переменной, но мы
могли бы их туда добавить. Можно сделать так, чтобы в начальном глобальном
окружении были лишь примитивы, а можно добавить туда все мыслимые переменные:
раз уж все повторные определения переменной эквивалентны присваиванию ей, то
пусть и первое будет таким же.</p>


<h3 id="denotational/global/ssect:autoexpand"><span class="wrap"><span class="seq">5.7.2.</span><span class="title">Автоматически расширяемое окружение</span></span></h3>

<!--\indexR{автоматически расширяемое окружение}-->
<!--\indexR{глобальное окружение!автоматически расширяемое}-->
<p>Некоторые диалекты Лиспа делают немного по-другому: в них первое присваивание
переменной эквивалентно её определению. Это можно легко реализовать, вместо
ошибки создавая новую переменную при присваивании.</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">set!</span> <span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="open">(</span><span class="ord var">ρ</span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">no-binding</span>
<span/><span class="rel syntax">then</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="open">(</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">=</span><span class="ord var">no-global-binding</span>
<span/><span class="rel syntax">then</span><span class="ord"/><div class="valign math"><span/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord num">1</span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">ν</span><span class="rel">→</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">]</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α<sub><span class="ord num">1</span></sub></span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>

<p>Преимущество такой вариации в том, что нам больше не требуется отдельная форма
<code><span class="special">define</span></code>. Недостаток же в том, что ошибки
в именах переменных становятся менее заметными, так как никаких предупреждений
о неопределённых переменных уже не выводится.</p>


<h3 id="denotational/global/ssect:hyperstatic"><span class="wrap"><span class="seq">5.7.3.</span><span class="title">Гиперстатическое окружение</span></span></h3>

<!--\indexR{гиперстатическое окружение}-->
<!--\indexR{глобальное окружение!гиперстатическое}-->
<!--\indexR{окружение!глобальное!гиперстатическое}-->
<p>В гиперстатическом случае замыкания захватывают не только локальное окружение,
но и текущее состояние глобального. Это поведение реализуется простым изменением
определения абстракции из таблицы
<a href="#denotational/global/fig:global-scheme">5.5</a>:</p>

<!--\indexC{lambda}-->
<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord var">κ</span> <span class="ord Vset">Значение</span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">κ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord">#</span><span class="ord var">ε<sup>∗</sup></span><span class="rel">=</span><span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span/><span class="rel syntax">then</span><div class="valign math"><span class="rel"/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord">#</span><span class="ord var">ν<sup>∗</sup></span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord cal">𝓔<sup><span class="binop">+</span></sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span><span class="open">[</span><span class="ord var">ν<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">α<sup>∗</sup></span><span class="close">]</span> <span class="ord var">γ</span> <span class="ord var">κ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="rel">→<span class="ontop"><span class="ord">∗</span></span></span><span class="ord var">ε<sup>∗</sup></span><span class="close">]</span><span class="close">)</span></div>
<span/><span class="rel syntax">else</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"Incorrect arity"</span></code></span>
<span/><span class="rel syntax">endif</span><span class="close">)</span> <span class="ord var">γ</span> <span class="ord var">σ</span><span class="close">)</span></div></div>

<p>Если присваивание, как в Scheme, может изменять значения только существующих
переменных, то такое определение не вызывает проблем. Если же
<code><span class="special">set!</span></code> может
работать как <code><span class="special">define</span></code>, то поведение уже
не всегда очевидно. Например:</p>

<!--\indexC{weird}-->
<pre>(<span class="special">define</span> (<span class="func">weird</span> <span class="var">v</span>)
  (<span class="special">set!</span> <span class="var">a-new-variable</span> <span class="var">v</span>) )</pre>

<p class="noindent">Присваивание внутри <code><span class="func">weird</span></code> расширяет
глобальное окружение, захваченное замыканием. Но состояние этого окружения не сохраняется между
вызовами <code><span class="func">weird</span></code>, каждый из них начинает с чистого листа.</p>

<!--\indexC{global}-->
<!--\indexR{рекурсия!взаимная}-->
<p>Также, как мы упоминали ранее, гиперстатическое глобальное окружение не дружит
со взаимно рекурсивными функциями. Можно было бы ввести специальную форму для
множественных одновременных определений, но лучше создать новый механизм для
доступа к глобальным переменным: <code>(<span class="special">global</span>
<span class="math"><span class="ord var">ν</span></span>)</code>. Эта специальная форма
позволяет обратиться к глобальной переменной
<span class="math"><span class="ord var">ν</span></span> в <em class="term">любом</em> контексте,
даже если существует одноимённая локальная переменная. Следовательно, мы сможем
определять глобальные взаимно рекурсивные функции следующим образом:</p>

<pre>(<span class="syntax">letrec</span> ((<span class="var">odd?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))))
         (<span class="var">even?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))) )
  (<span class="special">define-global</span> <span class="var">odd?</span> <span class="var">odd?</span>)
  (<span class="special">define-global</span> <span class="var">even?</span> <span class="var">even?</span>) )</pre>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">global</span> <span class="math"><span class="ord var">ν</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="open">(</span><span class="ord var">γ</span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">no-global-binding</span>
<span/><span class="rel syntax">then</span><span class="ord var">wrong</span> <span class="normal"><code><span class="string">"No such variable"</span></code></span>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">σ</span> <span class="ord var">α</span><span class="close">)</span> <span class="ord var">γ</span> <span class="ord var">σ</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span></div></div>
<span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">define-global</span> <span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">γ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span>
<span class="quad-stub" style="width: 1em"/><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">γ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><div class="valign math"><span/><span class="rel syntax">let</span><span class="ord var">α</span><span class="rel">=</span><span class="open">(</span><span class="ord var">γ</span> <span class="ord var">ν</span><span class="close">)</span>
<span/><span class="rel syntax">in</span><span class="ord"/><div class="valign math"><span/><span class="rel syntax">if</span><span class="ord var">α</span><span class="rel">=</span><span class="ord var">no-global-binding</span>
<span/><span class="rel syntax">then</span><span class="ord"/><div class="valign math"><span/><span class="ord var">allocate</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span> <span class="ord num">1</span>
<span class="quad-stub" style="width: 0.5em"/><span class="ord var">λ</span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord var">α<sup>∗</sup></span><span class="ord">.</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">ν</span><span class="rel">→</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="close">]</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="ord var">α<sup>∗</sup></span><span class="close">↓<sub><span class="ord num">1</span></sub></span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span></div>
<span/><span class="rel syntax">else</span><span class="open">(</span><span class="ord var">κ</span> <span class="ord var">ε</span> <span class="ord var">γ<sub><span class="ord num">1</span></sub></span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="open">[</span><span class="ord var">α</span><span class="rel">→</span><span class="ord var">ε</span><span class="close">]</span><span class="close">)</span>
<span/><span class="rel syntax">endif</span> <span class="ord var">σ</span><span class="close">)</span></div></div></div>

<p>И снова мы видим, как денотационная семантика позволяет элегантно описывать
разнообразные варианты окружений. Конечно, мы также могли бы легко объединить
определённые выше окружения, получив множественные пространства имён, как это
сделано в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>.</p>


<h2 id="denotational/sect:beneath"><span class="wrap"><span class="seq">5.8.</span><span class="title">Под капотом у денотаций</span></span></h2>

<p>Предназначением данной главы было снять покров таинственности с денотационной
семантики. Здесь это сделано весьма неформально (кое-кто бы поправил:
„кощунственно“), так как именно такой подход полезен для популяризации
денотационной семантики. Мы постепенно уточняли определяемый язык с помощью
различных интерпретаторов, одновременно с этим используя всё более и более
ограниченный язык описания; в итоге к этой главе мы дошли до чистой математики,
до денотационного интерпретатора.</p>

<!--\indexR{денотация!исполнимость}-->
<p>Scheme и <span class="math"><span class="ord var">λ</span></span>-исчисление — дальние родственники, но всё же
родственники. Поэтому вполне возможно сделать денотации исполнимыми, чтобы
получить возможность исправить ошибки в этих запутанных уравнениях. Возможность
перепроверить правильность денотаций с помощью компьютера очень важна: так можно
убедиться в том, что язык ведёт себя именно так, как задумано; это позволяет
экспериментировать с языком без опаски что-либо сломать. Так как денотации
почти непосредственно исполнимы, отсутствует необходимость писать сложный
интерпретатор и доказывать, что он правильно понимает их семантику.</p>

<!--\indexE{LISP0@LISP2\protect\TeX}-->
<p>Поэтому писать транслятор денотаций в исполнимый код приятно и полезно. Он
не уменьшает мощь <span class="math"><span class="ord var">λ</span></span>-исчисления, хоть и накладывает одно ограничение:
все вызовы производятся по значению (используется «плохое» правило вычислений
Scheme). Но эта не такая уж и проблема. Заявляю при свидетелях: все денотации,
приведённые в данной главе, на самом деле выполнены на Scheme и пропущены через
небольшой препроцессор (LISP2<span class="TeX">Τ<span class="E">e</span>Χ</span>), который перевёл их на греческий
<span class="cite">[<a href="z1_bibliography.html#que93d">Que93d</a>]</span>.
Представьте себе, скольких трудов стоило бы сделать денотации
исполнимыми (и протестировать их), если бы для симуляции аппликативного
<span class="math"><span class="ord var">λ</span></span>-исчисления (в котором, к тому же, ещё и порядок вычислений должен
быть неопределённым) использовался бы не аппликативный язык!</p>

<!--\indexR{абстракция!денотация}-->
<p>Вот пример исходного кода для денотации простой абстракции (с фиксированной
арностью). Можете сравнить его с соответствующим «греческим профилем»
на таблице <a href="#denotational/sematics/fig:naked-scheme">5.1</a>.</p>

<pre>(<span class="special">define</span> ((<span class="func">meaning-abstraction</span> <span class="var">n*</span> <span class="var">e+</span>) <span class="var">r</span> <span class="var">k</span> <span class="var">s</span>)
  (<span class="func">k</span> (<span class="func">inValue</span> (<span class="special">lambda</span> (<span class="var">v*</span> <span class="var">k1</span> <span class="var">s1</span>)
                (<span class="special">if</span> (<span class="func">=</span> (<span class="func">length</span> <span class="var">v*</span>) (<span class="func">length</span> <span class="var">n*</span>))
                    (<span class="func">allocate</span> <span class="var">s1</span> (<span class="func">length</span> <span class="var">n*</span>)
                              (<span class="special">lambda</span> (<span class="var">s2</span> <span class="var">a*</span>)
                                ((<span class="func">meaning*-sequence</span> <span class="var">e+</span>)
                                 (<span class="func">extend*</span> <span class="var">r</span> <span class="var">n</span> <span class="var">a*</span>)
                                 <span class="var">k1</span>
                                 (<span class="func">extend*</span> <span class="var">s2</span> <span class="var">a*</span> <span class="var">v*</span>) ) ) )
                    (<span class="func">wrong</span> <span class="var">"Incorrect</span> <span class="var">arity"</span>) ) ))
     <span class="var">s</span> ) )</pre>

<!--\indexCS{define}{синтаксис}-->
<p>Здесь используется устаревшая форма <code><span class="special">define</span></code>,
которая понимает <code>(<span class="special">define</span> (<span class="math"><span class="ord var">ν</span></span> . <i>переменные</i>) <span class="math"><span clas="ord var">π<sup>∗</sup></span></span>)</code>
как <code>(<span class="special">define</span> <span class="math"><span class="ord var">ν</span></span> (<span class="special">lambda</span> <i>переменные</i> <span class="math"><span clas="ord var">π<sup>∗</sup></span></span>))</code>,
где <span class="math"><span class="ord var">ν</span></span> описывает форму вызова
определяемой функции.</p>

<p>Заданные подобным образом функции ставятся под начало синтаксического
анализатора, который по получаемому выражению определяет соответствующую
функцию для его обработки. Его структура вам давно знакома:</p>

<!--\indexC{meaning}-->
<pre>(<span class="special">define</span> (<span class="func">meaning</span> <span class="var">e</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">meaning-reference</span> <span class="var">e</span>)
                      (<span class="func">meaning-quotation</span> <span class="var">e</span>) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">meaning-quotatione</span> (<span class="func">cadr</span> <span class="var">e</span>)))
        ((<span class="var">lambda</span>) (<span class="func">meaning-abstraction</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>)))
        ((<span class="var">if</span>)     (<span class="func">meaning-alternative</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) (<span class="func">cadddr</span> <span class="var">e</span>)))
        ((<span class="var">begin</span>)  (<span class="func">meaning-sequence</span> (<span class="func">cdr</span> <span class="var">e</span>)))
        ((<span class="var">set!</span>)   (<span class="func">meaning-assigment</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>)))
        (<span class="syntax">else</span>     (<span class="func">meaning-application</span> (<span class="func">car</span> <span class="var">e</span>) (<span class="func">cdr</span> <span class="var">e</span>))) ) ) )</pre>


<h2 id="denotational/sect:lambdify"><span class="wrap"><span class="seq">5.9.</span><span class="title"><span class="math"><span class="ord var">λ</span></span>-исчисление и Scheme</span></span></h2>

<!--\indexR{Лисп!и лямбда-исчисление@и <span class="math"><span class="ord var">λ</span></span>-исчисление}-->
<!--\indexE{Scheme!и лямбда-исчисление@и <span class="math"><span class="ord var">λ</span></span>-исчисление}-->
<p>Так как для нас важен вопрос исполнимости денотаций, то следует подробнее
разобраться в различиях между Scheme и <span class="math"><span class="ord var">λ</span></span>-исчислением. (Естественно,
имеется в виду «целомудренное» подмножество Scheme, не испорченное побочными
эффектами, присваиваниями и т. п.) Самое главное отличие лежит в порядке
вычислений. В <span class="math"><span class="ord var">λ</span></span>-исчислении нет фиксированного порядка, есть только
не очень хорошие порядки, которых стоит избегать. В Scheme же всё по-другому:
здесь обязателен аппликативный порядок вычислений. То есть, хоть
последовательность вычисления аргументов и не определена, но все они должны быть
вычислены до применения функции. Кроме того, это же правило запрещает вычислять
тела <code><span class="special">lambda</span></code>-форм раньше времени.</p>

<!--\indexR{обещания}-->
<p>Вызовы по имени можно проэмулировать в Scheme с помощью <em class="term">обещаний</em>
(promises, также известны как thunks, futures или delays). Обещание — это
замыкание без параметров, инкапсулирующее отложенные вычисления. Мы можем дать
обещание что-то вычислить с помощью <code><span class="syntax">delay</span></code>
и потребовать выполнения обещания с помощью <code><span class="func">force</span></code>.
Эти функции на Scheme определяются элементарно:</p>

<!--\indexC{delay}-->
<!--\indexC{force}-->
<pre>(<span class="special">define-syntax</span> <span class="var">delay</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">delay</span> <span class="var">expression</span>) (<span class="special">lambda</span> () <span class="var">expression</span>)) ) )

(<span class="special">define</span> (<span class="func">force</span> <span class="var">promise</span>) (<span class="func">promise</span>))</pre>

<!--\indexR{вызов!по имени!эмуляция}-->
<p>Форма <code><span class="syntax">delay</span></code> замыкает вычисления вместе
с их окружением в обещании, которое можно выполнить, передав его
<code><span class="func">force</span></code>. Используя обещания, можно легко
проэмулировать вызов по имени, преобразуя каждый вызов
<code>(<i>f</i> <i>a</i> ... <i>z</i>)</code>
в <code>(<i>f</i> (<span class="syntax">delay</span> <i>a</i>) ... (<span class="syntax">delay</span> <i>z</i>))</code>, а когда нам внутри понадобится
значение аргумента, мы его затребуем с помощью <code><span class="func">force</span></code>. Рассмотрим пример.
Вот выражение, с которым у нас были проблемы из-за аппликативного порядка
вычислений:</p>

<pre>(((<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">lambda</span> (<span class="var">y</span>) <span class="var">y</span>)) <span class="dialect"><span class="comment">; </span><span class="math"><span class="open"><span class="big">(</span></span><span class="open">(</span><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">λ</span><span class="ord var">y</span><span class="ord">.</span><span class="ord var">y</span> <span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span><span class="close">)</span> <span class="ord var">z</span><span class="close"><span class="big">)</span></span></span></span>
  ((<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">x</span> <span class="var">x</span>)) (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">x</span> <span class="var">x</span>))) ) <span class="var">z</span> )</pre>

<p>Использовав вышеуказанный приём, мы задерживаем вычисление
<span class="math"><span class="open">(</span><span class="ord var">ω</span> <span class="ord var">ω</span><span class="close">)</span></span> до
тех пор, пока его значение не потребуется (то есть навсегда), и возвращаем
правильное значение нормальной формы этого выражения — значение свободной
переменной <code><span class="var">z</span></code>.</p>

<pre>(((<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">lambda</span> (<span class="var">y</span>) (<span class="syntax">delay</span> <span class="var">y</span>)))
  (<span class="syntax">delay</span> ((<span class="special">lambda</span> (<span class="var">x</span>) ((<span class="func">force</span> <span class="var">x</span>) (<span class="syntax">delay</span> (<span class="func">force</span> <span class="var">x</span>))))
          (<span class="special">lambda</span> (<span class="var">x</span>) ((<span class="func">force</span> <span class="var">x</span>) (<span class="syntax">delay</span> (<span class="func">force</span> <span class="var">x</span>)))) )) )
 (<span class="syntax">delay</span> <span class="var">z</span>) )</pre>

<!--\indexR{мемоизация}-->
<!--\indexR{вызов!по необходимости}-->
<p>Хотя это несомненно работает <span class="cite">[<a href="z1_bibliography.html#dh92">DH92</a>]</span>, но вычисления выполняются
неэффективно. Не говоря уже о бессмысленных <code>(<span class="syntax">delay</span> (<span class="func">force</span> <span class="var">x</span>))</code>, сейчас
каждый вызов <code><span class="func">force</span></code> требует вычислить нам значение <em>заново</em>. А ведь
мы можем вычислить его один раз, сохранить где-нибудь и впоследствии просто
возвращать уже сохранённое значение. Такой приём называется вызовом по
необходимости или <em class="term">мемоизацией</em>. Для его использования потребуется изменить
определение <code><span class="syntax">delay</span></code>, чтобы обещание при его выполнении запоминало результат.
К счастью, Scheme прекрасно подходит для метапрограммирования, так что
реализация такого поведения не представляет труда:</p>

<!--\indexCS{delay}{<code><span class="func">memo-delay</span></code>}-->
<pre>(<span class="special">define-syntax</span> <span class="var">memo-delay</span>
  (<span class="syntax">synatax-rules</span> ()
    ((<span class="syntax">memo-delay</span> <span class="var">expression</span>)
     (<span class="syntax">let</span> ((<span class="var">already-computed?</span> <span class="hash">#f</span>)
           (<span class="var">value</span> '<span class="var">wait</span>) )
       (<span class="special">lambda</span> ()
         (<span class="special">if</span> (<span class="func">not</span> <span class="var">already-computed?</span>)
             (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">value</span> <span class="var">expression</span>)
                    (<span class="special">set!</span> <span class="var">already-computed?</span> <span class="hash">#t</span>) ) )
         <span class="var">value</span> ) ) ) ) )</pre>

<!--\indexR{анализ строгости}-->
<!--\indexR{ленивые вычисления}-->
<p>Конечно, вовсе необязательно преобразовывать все вызовы вручную, когда в языке
есть макросы, см. <span class="cite">[<a href="z1_bibliography.html#dfh86">DFH86</a>]</span>. Если же мы желаем максимальной эффективности, то
существует техника <em class="term">анализа строгости</em> (strictness analysis), которая
определяет, какие объекты бессмысленно заворачивать в обещания, потому что они
вычисляются всегда <span class="cite">[<a href="z1_bibliography.html#bhy88">BHY88</a>]</span>. Наконец, сами обещания можно представлять иным
образом, чтобы минимизировать затраты времени на проверку <code>(<span class="special">if</span>
(<span class="func">not</span> <span class="var">already-computed?</span>) ...)</code>.
Обещания добавляют в Scheme ленивые вычисления,
где преобразования лишь описываются, а выполняются уже самостоятельно и
автоматически в нужное время. Однако такой стиль программирования вызывает
очевидные затруднения при отладке, а также не особо сочетается с побочными
эффектами и продолжениями. Сравним, например, следующие программы
из <span class="cite">[<a href="z1_bibliography.html#kw90">KW90</a>,
<a href="z1_bibliography.html#mor92">Mor92</a>]</span>,
они отличаются лишь на одну <code><span class="syntax">delay</span></code>, но дают
совершенно различные результаты:</p>

<pre>(<span class="func">pair?</span> (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="func">list</span> (<span class="func">k</span> <span class="num">33</span>)))))
(<span class="func">pair?</span> (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="func">list</span> (<span class="syntax">delay</span> (<span class="func">k</span> <span class="num">33</span>))))))</pre>


<h3 id="denotational/lambdify/ssect:cps"><span class="wrap"><span class="seq">5.9.1.</span><span class="title">Круговорот продолжений в природе</span></span></h3>

<!--\indexC{call/cc}-->
<p>Только совсем уж невнимательный читатель ещё не заметил, что все денотации были
записаны в <em class="term">стиле передачи продолжений</em> (continuation passing
style). Очевидно, что мы можем транслировать любую программу на Scheme,
использует она <code><span class="func">call/cc</span></code> или нет, в её денотационный эквивалент
в <span class="math"><span class="ord var">λ</span></span>-исчислении. Но ведь сами <span class="math"><span class="ord var">λ</span></span>-термы тоже однозначно
представляются в виде программ на Scheme, которые не используют <code><span class="func">call/cc</span></code>.
Вопрос: а можно ли преобразовать программу на Scheme, содержащую <code><span class="func">call/cc</span></code>,
в эквивалентную программу на Scheme, но без <code><span class="func">call/cc</span></code>?</p>

<p>Ответ: да, но в этом случае нам придётся передавать продолжения явно. К счастью,
с этим нет особых проблем, так как продолжения — это те же <code><span class="special">lambda</span></code>-формы.
В действительности, некоторые компиляторы <span class="cite">[<a href="z1_bibliography.html#app92a">App92a</a>]</span> намеренно переводят
компилируемые программы сначала в такой промежуточный вид, чтобы избавиться от
«особенной» формы <code><span class="func">call/cc</span></code>. Однако, у этого приёма есть и недостатки: он
сильно вредит читабельности получаемого кода, а также иногда преждевременно
вносит упорядоченность в вычисления. Тем не менее, программы, как показано
в <span class="cite">[<a href="z1_bibliography.html#sf92">SF92</a>]</span>, действительно остаются эквивалентными. Преобразование,
рассматриваемое здесь, вдохновлено работой <span class="cite">[<a href="z1_bibliography.html#df90">DF90</a>]</span>.
В разделе <a href="ch10_compiling_into_c.html#cc/call/cc/ssect:cc">10.11.2</a> рассматривается иной вариант.</p>

<!--\indexE{CPS}-->
<!--\indexR{преобразование!в CPS}-->
<!--\indexR{стиль передачи продолжений (CPS)!CPS-преобразование}-->
<p>Перейдём к реализации. Мы полагаем, что отныне всякая функция принимает
дополнительный аргумент<a class="footref" href="zz_footnotes.html#foot5.5"><sup>5</sup></a> —
своё продолжение. То есть <code><sub><i>k</i></sub>(<span class="func">foo</span> <span class="var">bar</span> ... <span class="var">hux</span>)</code>
превращается в <code>(<span class="func">foo</span> <i>k</i> <span class="var">bar</span> ... <span class="var">hux</span>)</code>.
С продолжениями разобрались, с функциями тоже, остались специальные формы.
Их разбор и преобразование производится обычным способом. Продолжения в них
используются точно так же, как и в денотациях: для вычисления и хранения
промежуточных результатов, а также для передачи управления следующему коду
(оставшимся вычислениям).</p>

<!--\indexC{cps}-->
<pre>(<span class="special">define</span> (<span class="func">cps</span> <span class="var">e</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>) (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="func">k</span> `,<span class="var">e</span>))
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">cps-quote</span> (<span class="func">cadr</span> <span class="var">e</span>)))
        ((<span class="var">if</span>)     (<span class="func">cps-if</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) (<span class="func">cadddr</span> <span class="var">e</span>)))
        ((<span class="var">begin</span>)  (<span class="func">cps-begin</span> (<span class="func">cdr</span> <span class="var">e</span>)))
        ((<span class="var">set!</span>)   (<span class="func">cps-set!</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>)))
        ((<span class="var">lambda</span>) (<span class="func">cps-abstraction</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>)))
        (<span class="syntax">else</span>     (<span class="func">cps-application</span> <span class="var">e</span>)) ) ) )</pre>

<p>Транслятор <code><span class="func">cps</span></code> принимает программу,
выполняет преобразования и возвращает замыкание, являющееся той же программой
в стиле передачи продолжений. Такая программа принимает своё продолжение
(такое же замыкание) и возвращает результат
вычислений, представляемый ещё одним замыканием. В итоге,
<code><span class="func">cps</span></code> имеет
следующий своеобразный тип:</p>

<blockquote class="equation math"><span class="ord Vset">Программа</span><span class="rel">→</span><span class="open"><span class="big">(</span></span><span class="open">(</span><span class="ord Vset">Программа</span><span class="rel">→</span><span class="ord Vset">Программа</span><span class="close">)</span><span class="rel">→</span><span class="ord Vset">Программа</span><span class="close"><span class="big">)</span></span></blockquote>

<p>Цитирование снова элементарно:</p>

<!--\indexC{cps-quote}-->
<pre>(<span class="special">define</span> (<span class="func">cps-quote</span> <span class="var">data</span>)
  (<span class="special">lambda</span> (<span class="var">k</span>)
    (<span class="func">k</span> `(<span class="special">quote</span> ,<span class="var">data</span>)) ) )</pre>

<p>Присваивание тоже просто записывается:</p>

<!--\indexC{cps-set"!}-->
<pre>(<span class="special">define</span> (<span class="func">cps-set!</span> <span class="var">variable</span> <span class="var">form</span>)
  (<span class="special">lambda</span> (<span class="var">k</span>)
    ((<span class="func">cps</span> <span class="var">form</span>)
     (<span class="special">lambda</span> (<span class="var">a</span>)
       (<span class="func">k</span> `(<span class="special">set!</span> ,<span class="var">variable</span> ,<span class="var">a</span>)) ) ) ) )</pre>

<p class="noindent">Мы вычисляем новое значение переменной <code>(<span class="func">cps</span> <span class="var">form</span>)</code>,
передаём его промежуточному продолжению через переменную
<code><span class="var">a</span></code>, затем передаём результат
присваивания дальнейшей программе.</p>

<p>Условный оператор действует аналогично:</p>

<!--\indexC{cps-if}-->
<pre>(<span class="special">define</span> (<span class="func">cps-if</span> <span class="var">bool</span> <span class="var">formT</span> <span class="var">formF</span>)
  (<span class="special">lambda</span> (<span class="var">k</span>)
    ((<span class="func">cps</span> <span class="var">bool</span>)
     (<span class="special">lambda</span> (<span class="var">b</span>)
       `(<span class="special">if</span> ,<span class="var">b</span> ,((<span class="func">cps</span> <span class="var">formT</span>) <span class="var">k</span>)
               ,((<span class="func">cps</span> <span class="var">formF</span>) <span class="var">k</span>) ) ) ) ) )</pre>

<p>Упорядочить вычисления чуть сложнее:</p>

<!--\indexC{cps-begin}-->
<pre>(<span class="special">define</span> (<span class="func">cps-begin</span> <span class="var">e</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e</span>))
          (<span class="syntax">let</span> ((<span class="var">void</span> (<span class="func">gensym</span> <span class="var">"void"</span>)))
            (<span class="special">lambda</span> (<span class="var">k</span>)
              ((<span class="func">cps</span> (<span class="func">car</span> <span class="var">e</span>))
               (<span class="special">lambda</span> (<span class="var">a</span>)
                 ((<span class="func">cps-begin</span> (<span class="func">cdr</span> <span class="var">e</span>))
                  (<span class="special">lambda</span> (<span class="var">b</span>)
                    (<span class="func">k</span> `((<span class="special">lambda</span> (,<span class="var">void</span>) ,<span class="var">b</span>) ,<span class="var">a</span>)) ) ) ) ) ) )
          (<span class="func">cps</span> (<span class="func">car</span> <span class="var">e</span>)) )
      (<span class="func">cps</span> <span class="hash">'()</span>) ) )</pre>

<p class="noindent">Здесь интересным местом является способ игнорирования промежуточных значений.</p>

<p>Самое сложное — это обработка <code><span class="special">lambda</span></code>-форм.
Им всем надо добавить ещё один аргумент — продолжение — и гарантировать правильность его
передачи. Кроме этого мы введём небольшую оптимизацию для простых функций
(которые быстро выполняются и всегда возвращают результат). Список
<code><span class="var">primitives</span></code> определяет перечень таких функций.<a class="footref" href="zz_footnotes.html#foot5.6"><sup>6</sup></a></p>

<!--\indexC{cps-application}-->
<!--\indexC{cps-terms}-->
<!--\indexC{cps-abstraction}-->
<pre>(<span class="special">define</span> (<span class="func">cps-application</span> <span class="var">e</span>)
  (<span class="special">lambda</span> (<span class="var">k</span>)
    (<span class="special">if</span> (<span class="func">memq</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">primitives</span>)
        ((<span class="func">cps-terms</span> (<span class="func">cdr</span> <span class="var">e</span>))
         (<span class="special">lambda</span> (<span class="var">t*</span>)
           (<span class="func">k</span> `(,(<span class="func">car</span> <span class="var">e</span>) ,@<span class="var">t*</span>)) ) )
        ((<span class="func">cps-terms</span> <span class="var">e</span>)
         (<span class="special">lambda</span> (<span class="var">t*</span>)
           (<span class="syntax">let</span> ((<span class="var">d</span> (<span class="func">gensym</span>)))
             `(,(<span class="func">car</span> <span class="var">t*</span>) (<span class="special">lambda</span> (,<span class="var">d</span>) ,(<span class="func">k</span> <span class="var">d</span>))
                         . ,(<span class="func">cdr</span> <span class="var">t*</span>) ) ) ) ) ) ) )

(<span class="special">define</span> <span class="var">primitives</span> '(<span class="var">cons</span> <span class="var">car</span> <span class="var">cdr</span> <span class="var">list</span> <span class="var">*</span> <span class="var">+</span> <span class="var">-</span> <span class="var">=</span> <span class="var">pair?</span> <span class="var">eq?</span>))

(<span class="special">define</span> (<span class="func">cps-terms</span> <span class="var">e*</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
      (<span class="special">lambda</span> (<span class="var">k</span>)
        ((<span class="func">cps</span> (<span class="func">car</span> <span class="var">e*</span>))
         (<span class="special">lambda</span> (<span class="var">a</span>)
           ((<span class="func">cps-terms</span> (<span class="func">cdr</span> <span class="var">e*</span>))
            (<span class="special">lambda</span> (<span class="var">a*</span>)
              (<span class="func">k</span> (<span class="func">cons</span> <span class="var">a</span> <span class="var">a*</span>)) ) ) ) ) )
      (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="func">k</span> <span class="hash">'()</span>)) ) )

(<span class="special">define</span> (<span class="func">cps-abstraction</span> <span class="var">variables</span> <span class="var">body</span>)
  (<span class="special">lambda</span> (<span class="var">k</span>)
    (<span class="func">k</span> (<span class="syntax">let</span> ((<span class="var">c</span> (<span class="func">gensym</span> <span class="var">"cont"</span>)))
         `(<span class="special">lambda</span> (,<span class="var">c</span> . ,<span class="var">variables</span>)
            ,((<span class="func">cps</span> `(<span class="special">begin</span> ,@<span class="var">body</span>))
              (<span class="special">lambda</span> (<span class="var">a</span>) `(,<span class="func">c</span> ,<span class="var">a</span>)) ) ) )) ) )</pre>

<p class="noindent">Готово. Посмотрим, во что данная трансформация превратит факториал:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">set!</span> <span class="var">fact</span> (<span class="special">lambda</span> (<span class="var">n</span>)
             (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) <span class="num">1</span>
                 (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) ))
<span class="math"><span class="rel">⇝</span></span> (<span class="special">set!</span> <span class="var">fact</span>
         (<span class="special">lambda</span> (<span class="var">cont112</span> <span class="var">n</span>)
           (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>)
               (<span class="func">cont112</span> <span class="num">1</span>)
               (<span class="func">fact</span> (<span class="special">lambda</span> (<span class="var">g113</span>) (<span class="func">cont112</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">g113</span>)))
                     (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) ) ) ) )</pre>

<p>Теперь мы автоматически получаем то, что раньше были вынуждены писать вручную.
Заметьте, что преобразование превратило программу в последовательность простых
вызовов функций: сравнений, арифметики и продолжений. Нет никаких дополнительных
особых случаев, кроме специальных форм.</p>

<p>После CPS-преобразования форма <code><sub><i>k</i></sub>(<span class="func">call/cc</span>
<span class="var">f</span>)</code> превращается в <code>(<span class="func">call/cc</span> <i>k</i> <span class="var">f</span>)</code>, а сама функция <code><span class="func">call/cc</span></code> становится вообще
тривиальной: <code>(<span class="special">lambda</span> (<span class="var">k</span> <span class="var">f</span>) (<span class="func">f</span> <span class="var">k</span> <span class="var">k</span>))</code>, поэтому мы на ней и
не останавливались. Единственная загвоздка в том, чтобы сами продолжения,
возвращаемые <code><span class="func">call/cc</span></code>, оставались функциями. То есть, чтобы форма
<code>(<span class="func">procedure?</span> (<span class="func">apply</span> <span class="var">call/cc</span> (<span class="func">list</span> <span class="var">call/cc</span>)))</code> возвращала истину.</p>

<p>Одним из достоинств стиля передачи продолжений является то, что благодаря явному
указанию, когда что вычислять и кому возвращать результат, становится без
разницы, нормальный ли порядок принят в языке реализации или аппликативный.
В обоих случаях мы получим одинаковое поведение. Поэтому использование обещаний
совместно с подобным стилем позволяет сократить разрыв между Scheme
и <span class="math"><span class="ord var">λ</span></span>-исчислением <span class="cite">[<a href="z1_bibliography.html#dh92">DH92</a>]</span>.</p>


<h3 id="denotational/lambdify/ssect:dynamic"><span class="wrap"><span class="seq">5.9.2.</span><span class="title">Динамическое окружение</span></span></h3>

<!--\indexR{динамическое окружение}-->
<!--\indexR{окружение!динамическое}-->
<p>В предыдущем разделе денотации натолкнули нас на идею преобразования программ,
позволяющего избавиться от <code><span class="func">call/cc</span></code>.
Ранее мы рассматривали динамическое
окружение; а ведь мы можем аналогичным образом избавиться и от форм
<code><span class="special">dynamic-let</span></code> и
<code><span class="special">dynamic</span></code>.
Для этого потребуется явно ввести динамическое
окружение и определить соответствующее преобразование программ.</p>


<!--\indexE{D@$\protect\Dana$, преобразование}-->
<!--\indexR{преобразование!динамического окружения ($\protect\Dana$)}-->
<p>Предположим, у нас есть идентификатор, который не используется ни в одной
программе. Назовём его <span class="math"><span class="ord var">δ</span></span>.
Свяжем его с динамическим окружением — функцией,
которая по имени динамической переменной возвращает её значение. Предположим,
что у нас есть функция <code><span class="func">update</span></code>,
которая умеет расширять подобное окружение
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.html#assignment/implementation/ssect:environment">4.3.3</a>]</span>,
которая доступна отовсюду, которую нельзя переопределить, перекрыть локальными
переменными и т. п. Используя всё это, можно реализовать преобразования
<span class="math"><span class="ord cal">𝓓</span></span>
и <span class="math"><span class="ord cal">𝓓<sup>∗</sup></span></span>,
приведённые в таблице <a href="#ch5-dynamic-denotation-transform">5.6</a>.</p>

<table id="ch5-dynamic-denotation-transform">
<tbody>
<tr><td><span class="math"><span class="ord cal">𝓓<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="quad-stub" style="width: 0.1em"/><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td/></tr>
<tr><td><span class="math"><span class="ord cal">𝓓<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td><span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord cal">𝓓<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span></span></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">if</span> <span class="math"><span class="ord var">π<sub><span class="ord var">c</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord var">t</span></sub></span></span> <span class="math"><span class="ord var">π<sub><span class="ord var">f</span></sub></span></span>)</code></span><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td><code>(<span class="special">if</span> <span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord var">c</span></sub></span><span class="close sem-brace">]]</span></span> <span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord var">t</span></sub></span><span class="close sem-brace">]]</span></span> <span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="ord var">π<sub><span class="ord var">f</span></sub></span><span class="close sem-brace">]]</span></span>)</code></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">begin</span> <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td><code>(<span class="special">begin</span> <span class="math"><span class="ord cal">𝓓<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span></span>)</code></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td><code>(<span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span></span> <span class="math"><span class="ord var">δ</span></span> <span class="math"><span class="ord cal">𝓓<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span></span>)</code></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td><code>(<span class="special">lambda</span> (<span class="math"><span class="ord var">δ</span></span> <span class="math"><span class="ord var">ν<sup>∗</sup></span></span>) <span class="math"><span class="ord cal">𝓓<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span></span>)</code></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">dynamic</span> <span class="math"><span class="ord var">ν</span></span>)</code></span><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td><code>(<span class="math"><span class="ord var">δ</span></span> (<span class="special">quote</span> <span class="math"><span class="ord var">ν</span></span>))</code></td></tr>
<tr><td><span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="special">dynamic-let</span> (<span class="math"><span class="ord var">ν</span></span> <span class="math"><span class="ord var">π</span></span>) <span class="math"><span class="ord var">π<sup><span class="binop">+</span></sup></span></span>)</code></span><span class="close sem-brace">]]</span></span></td>
<td class="arrow"><span class="math"><span class="rel">→</span></span></td>
<td><code>(<span class="syntax">let</span> ((<span class="math"><span class="ord var">δ</span></span> (<span class="func">update</span> <span class="math"><span class="ord var">δ</span></span> (<span class="special">quote</span> <span class="math"><span class="ord var">ν</span></span>))) <span class="math"><span class="ord cal">𝓓<sup>∗</sup></span><span class="open sem-brace">[[</span><span class="ord var">π<sup><span class="binop">+</span></sup></span><span class="close sem-brace">]]</span></span>)</code></td></tr>
</tbody></table>
<span class="caption">Таблица 5.6. Трансформация, убирающая динамическое окружение.</span>

<p>Таким образом мы можем проэмулировать динамическое окружение, если не можем или
не хотим встраивать его поддержку в ядро языка. Последний штрих: начальное
динамическое окружение.
Программа <span class="math"><span class="ord var">π</span></span> преобразуется в</p>

<pre>(<span class="syntax">let</span> ((<span class="math"><span class="ord var">δ</span></span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">error</span> <span class="string">"No such dynamic variable"</span> <span class="var">n</span>)))) <span class="math"><span class="ord cal">𝓓</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span></span>)</pre>

<p>В итоге можно сделать следующий вывод: денотации специальных форм языка иногда
способны показать, что некоторые формы вовсе не такие уж и специальные.</p>


<h2 id="denotational/sect:conclusions"><span class="wrap"><span class="seq">5.10.</span><span class="title">Заключение</span></span></h2>

<p>Данная глава венчает серию интерпретаторов, определяющих Scheme всё точнее и
точнее с использованием всё более ограниченных средств. Денотационная семантика,
по крайней мере в рассмотренном виде, позволяет очень точно и лаконично
описывать <em class="term">ядро</em> языка. Она плохо подходит для описания всего языка, его
мельчайших деталей, так как на таком уровне нотация уже чрезмерно усложняется.</p>

<p>В данной главе среди важных вещей мы не рассмотрели сравнение функций, денотацию
констант, а также всевозможные не особо важные тонкости, которые редко заметны и
ещё реже используются. Денотационная семантика прекрасно подходит для
набрасывания общей формы языка, но проработка деталей с её помощью становится
неимоверно скучной.</p>

<p>Существует огромное множество вещей, которые можно описать с помощью
денотационной семантики. Например, организовать параллелизм с помощью техники
пошаговых вычислений <span class="cite">[<a href="z1_bibliography.html#que90c">Que90c</a>]</span>. Или распределённое хранение и обработку
данных <span class="cite">[<a href="z1_bibliography.html#que92b">Que92b</a>]</span>. Но есть также вещи, которые таким образом описывать
неудобно <span class="cite">[<a href="z1_bibliography.html#mcd93">McD93</a>]</span>. К примеру, вывод типов довольно сложно выразить
денотационно, именно поэтому существует естественная семантика <span class="cite">[<a href="z1_bibliography.html#kah87">Kah87</a>]</span>.</p>


<h2 id="denotational/sect:exercises"><span class="wrap"><span class="seq">5.11.</span><span class="title">Упражнения</span></span></h2>

<h5 class="exercise" id="denotational/ex:truly-random">Упражнение <span class="seq">5.1</span></h5>
<!--\indexR{интерпретатор!E@$\protect\Eval$}-->
<!--\indexE{E-@$\protect\Eval$, интерпретатор}-->
<p>Рассмотрим ещё один способ денотации аппликации. Докажите, что он эквивалентен
показанному в разделе <a href="#denotational/semantics/ssect:application">5.2.6</a>.</p>

<div class="denotation math"><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="normal"><code>(<span class="math"><span class="ord var">π</span></span> <span class="math"><span class="ord var">π<sup>∗</sup></span></span>)</code></span><span class="close sem-brace">]]</span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">φ</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal"><span class="overline">𝓔</span></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="open">⟨</span><span class="close">⟩</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord var">φ</span><span class="ord">∣<sub><span class="ord Vset">Функции</span></sub></span> <span class="ord var">ε<sup>∗</sup></span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">2</span></sub></span><span class="close">)</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal"><span class="overline">𝓔</span></span><span class="open sem-brace">[[</span><span class="quad-stub" style="width: 0.1em"/><span class="close sem-brace">]]</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord var">κ</span> <span class="open">(</span><span class="ord var">reverse</span> <span class="ord var">ε<sup>∗</sup></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span>
<span class="ord cal"><span class="overline">𝓔</span></span><span class="open sem-brace">[[</span><span class="ord var">π</span> <span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span><span class="ord var">ε<sup>∗</sup></span><span class="ord var">ρ</span><span class="ord var">κ</span><span class="ord var">σ</span><span class="rel">=</span><span class="open">(</span><span class="ord cal">𝓔</span><span class="open sem-brace">[[</span><span class="ord var">π</span><span class="close sem-brace">]]</span> <span class="ord var">ρ</span> <span class="ord var">λ</span><span class="ord var">ε</span><span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="ord">.</span><span class="open">(</span><span class="ord cal"><span class="overline">𝓔</span></span><span class="open sem-brace">[[</span><span class="ord var">π<sup>∗</sup></span><span class="close sem-brace">]]</span> <span class="open">⟨</span><span class="ord var">ε</span><span class="close">⟩</span><span class="binop">§</span><span class="ord var">ε<sup>∗</sup></span> <span class="ord var">ρ</span> <span class="ord var">κ</span> <span class="ord var">σ<sub><span class="ord num">1</span></sub></span><span class="close">)</span> <span class="ord var">σ</span><span class="close">)</span></div>


<h5 class="exercise" id="denotational/ex:label">Упражнение <span class="seq">5.2</span></h5>
<!--\indexC{label}-->
<p>Определения из раздела <a href="#denotational/sect:lambda">5.3</a> слишком затрудняют
описание рекурсивных функций. Мы могли бы, как в <span class="sc">L<span class="c">isp</span> 1.5</span>, ввести
специальную форму <code><span class="special">label</span></code>. В Scheme форма <code>(<span class="special">label</span> <span class="math"><span class="ord var">ν</span></span> (<span class="special">lambda</span> ...))</code> эквивалентна
<code>(<span class="syntax">letrec</span> ((<span class="math"><span class="ord var">ν</span></span>  (<span class="special">lambda</span> ...))) <span class="math"><span class="ord var">ν</span></span>)</code>. Определите семантику аналогичного
оператора <code><span class="special">label</span></code> для <span class="math"><span class="ord var">λ</span></span>-исчисления.</p>


<h5 class="exercise" id="denotational/ex:dynamic-fallback">Упражнение <span class="seq">5.3</span></h5>

<p>Измените денотацию <code><span class="special">dynamic</span></code> таким образом, чтобы в случае отсутствия
динамической переменной с искомым именем возвращалась одноимённая переменная
из глобального окружения.</p>


<h5 class="exercise" id="denotational/ex:quantum">Упражнение <span class="seq">5.4</span></h5>
<!--\indexR{порядок вычислений!неопределённый}-->
<p>Напишите макрос, который бы эмулировал неопределённый порядок вычисления
аргументов в такой реализации Scheme, где аргументы вычисляются слева направо.
В вашем распоряжении есть унарная функция
<code><span class="func">random-permutation</span></code>, которая
принимает целое число <span class="math"><span class="ord var">n</span></span>
и возвращает случайную перестановку чисел
<span class="math"><span class="ord num">0</span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">n</span><span class="binop">−</span><span class="ord num">1</span></span>.</p>


<h2><span class="wrap"><span class="title">Рекомендуемая литература</span></span></h2>

<p>Я настойчиво рекомендую обратить внимание на книги <span class="cite">[<a href="z1_bibliography.html#sto77">Sto77</a>]</span> и <span class="cite">[<a href="z1_bibliography.html#sch86">Sch86</a>]</span>.
В обеих содержатся просто горы информации о денотационной семантике, а также
примеры денотирования языков.</p>

<p>Тем же, кого серьёзно зацепило <span class="math"><span class="ord var">λ</span></span>-исчисление, стоит приняться за
классическую книгу <span class="cite">[<a href="z1_bibliography.html#bar84">Bar84</a>]</span>.</p>

</body>
</html>
