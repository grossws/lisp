<!DOCTYPE html>
<html>

<head>
    <title>8 – Вычисления и рефлексия</title>
    <link rel="stylesheet" type="text/css" href="css/zz_lisp.css">
</head>

<body>

<div class="substrate">
<div class="body">

<h1 id="chapter:reflection"><span class="wrap"><span class="seq">Глава 8.</span><span class="title">Вычисления и рефлексия</span></span></h1>

<!--\indexC{eval}-->
<!--\indexR{вычислитель}-->
<p class="noindent"><span class="initial">У</span><span class="sc"><span class="c">никальной чертой</span></span> Лиспа
является его вычислитель: <code><span class="func">eval</span></code>. Хотя в данной
книге вычисления упоминаются чуть ли не на каждой странице, мы никогда не касались
возможности явного использования
вычислителя. И на то есть веские причины: явные вычисления создают определённые
затруднения с их формализацией, они влияют на целостность окружения вычислений,
поднимают неудобные вопросы лингвистического плана. Всё это дало жизнь расхожему
выражению: «<code><span class="func">eval</span></code> is <i>evil</i>».
Нахождение возможностей плодотворного применения <code><span class="func">eval</span></code> —
это первый шаг к рефлексивному программированию —
теме, которая также будет затронута в этой главе.</p>

<div class="bigskip"></div>

<p>Каждый рассмотренный нами интерпретатор показывал ту или иную сторону процесса
вычислений. Для большинства из них явное предоставление вычислителя
пользователям не требует значительных усилий и выполняется всего парой строк
кода. Это тривиальная задача по сравнению с реализацией самого интерпретатора.
Однозначно можно сказать <span class="see">[см. раздел <a href="ch01_basics.html#basics/sect:evaluation">1.1</a>]</span>, что облегчение её
решения намеренно заложено в дизайн Лиспа. Явная функция
<code><span class="func">eval</span></code>
присутствовала ещё в первых работах отцов-основателей:
<span class="cite">[<a href="z1_bibliography.html#mcc60">McC60</a>, <a href="z1_bibliography.html#mae+62">MAE<sup>+</sup>62</a>]</span>.</p>

<p>Наличие в языке явного вычислителя является его фундаментальным качеством,
позволяющим реализовать мощную макросистему, объединить язык и среду разработки,
а также наделить программы уже упомянутыми возможностями интроспекции. Конечно, при этом
имеются и недостатки, такие как макросы, неотрывность среды разработки от языка
и сующая свой нос куда попало интроспекция. Подобно волшебному джинну, <code><span class="func">eval</span></code>
может быть как полезной, так и принести погибель.</p>

<p>Итак, какой контракт нам стоит заключить с <code><span class="func">eval</span></code>?
Безусловно, одним из его пунктов должно быть утверждение</p>

<!--\indexCS{eval}{контракт!идемпотентности}-->
<blockquote id="reflection/eq:eval-idemp" class="equation math"><span class="normal ord"><code>(<span class="func">eval</span> '<span class="math"><span class="ord var">π</span></span>)</code></span><span class="rel">≡</span><span class="ord var">π</span><span class="eqno">(1)</span></blockquote>

<p>Вскоре мы покажем, что это уравнение далеко от однозначности.</p>


<h2 id="reflection/sect:prog-and-val"><span class="wrap"><span class="seq">8.1.</span><span class="title">Программы и значения</span></span></h2>

<!--\indexR{вычисления!динамические}-->
<p>Давайте попробуем добавить <code><span class="func">eval</span></code> в самый первый
интерпретатор, рассмотренный в этой книге.
<span class="see">[см. раздел <a href="ch01_basics.html#basics/sect:basic-evaluator">1.2</a>]</span>
Он написан на чистом Scheme без использования каких-либо библиотек. Для начала сделаем
<code><span class="special">eval</span></code> специальной формой.
Следовательно, в <code><span class="func">evaluate</span></code> появляется
соответствующая ветка:</p>

<!--\indexC{evaluate}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">lookup</span> <span class="var">e</span> <span class="var">env</span>))
            ((<span class="syntax">or</span> (<span class="func">number?</span> <span class="var">e</span>)(<span class="func">string?</span> <span class="var">e</span>)(<span class="func">char?</span> <span class="var">e</span>)
                 (<span class="func">boolean?</span> <span class="var">e</span>)(<span class="func">vector?</span> <span class="var">e</span>) )
              <span class="var">e</span>)
            (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Cannot evaluate"</span> <span class="var">e</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>) (<span class="func">cadr</span> <span class="var">e</span>))
        ((<span class="var">if</span>)     (<span class="special">if</span> (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>)
                      (<span class="func">evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span>)
                      (<span class="func">evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span>) ))
        ((<span class="var">begin</span>)  (<span class="func">eprogn</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>))
        ((<span class="var">set!</span>)   (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span> (<span class="func">evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span>)))
        ((<span class="var">lambda</span>) (<span class="func">make-function</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span>))
        <span class="highlight">((<span class="var">eval</span>)   (<span class="func">evaluate</span> (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>) <span class="var">env</span>))</span>
        (<span class="syntax">else</span>     (<span class="func">invoke</span> (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>)
                          (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>) )) ) ) )</pre>

<p>Специальная форма <code><span class="special">eval</span></code> вычисляет свой единственный аргумент (прямо как
функция), а затем ещё раз вычисляет полученное в результате значение в текущем
окружении. К сожалению, в этом вроде как самоочевидном описании на самом деле
полно неясностей.</p>


<!--\indexR{программы!как данные}-->
<!--\indexR{значения!как программы}-->
<p>Как уже не раз было сказано, <code><span class="func">evaluate</span></code> разделяется на этап анализа и этап
исполнения. В последних интерпретаторах мы даже явно ввели две отдельные
функции: <code><span class="func">meaning</span></code> и <code><span class="func">run</span></code>. Функция <code><span class="func">evaluate</span></code> принимает программы, а
возвращает значения — результаты вычислений. Вот здесь и возникает первая
проблема (назовём её проблемой типизации): в форме <code>(<span class="func">evaluate</span> (<span class="func">evaluate</span> ...)
...)</code> внешняя <code><span class="func">evaluate</span></code> применяется к значению, а не к программе.
Являются ли программы значениями? А значения программами?</p>


<!--\indexE{Scheme!грамматика}-->
<!--\indexR{грамматика!Scheme}-->
<p>Определения языков программирования обычно включают в себя грамматику —
описание допустимых синтаксических конструкций этого языка. Грамматика Scheme
приведена в <span class="cite">[<a href="z1_bibliography.html#kcr98">KCR98</a>]</span>. Там написано, что определённые наборы букв и скобочек
являются синтаксически допустимыми программами. Кроме того, грамматика задаёт
синтаксис значений (данных), поэтому можно легко проверить, является ли
программа значением с синтаксической точки зрения. Благо, в Scheme есть
универсальная функция <code><span class="func">read</span></code>, умеющая читать как программы, так и данные.
Ведь ничто не обязывает нас сразу же исполнять считанные <code><span class="func">read</span></code> программы.
Многие интерпретаторы Smalltalk, вроде <span class="cite">[<a href="z1_bibliography.html#gr83">GR83</a>]</span>, сперва проверяют синтаксис
программы и отображают её в специальном окне, подсвечивая все найденные
синтаксические ошибки. Это достаточно распространённая практика, так что при
необходимости вполне можно трактовать программы как значения, если с точки
зрения синтаксиса они являются нормальными значениями.</p>

<p>Но вот обратное не всегда верно: существует множество значений, не являющихся
синтаксически корректными программами, например, <code>(<span class="special">quote</span> . <span class="num">1</span>)</code>. А есть и
значения, которые нельзя однозначно отнести к той или иной группе.</p>

<ul>
  <li>Возьмём значение, являющееся корректной программой во всём,
    кроме пары-тройки деталей. Например, <code>(<span class="special">if</span> <span class="hash">#t</span> <span class="num">1</span> (<span class="special">quote</span> . <span class="num">2</span>))</code>.
    Это программа? Если передать данное выражение определённой ранее
    <code><span class="special">eval</span></code>, то она вычислит его без особых проблем, так как не будет
    даже смотреть на <code>(<span class="special">quote</span> . <span class="num">2</span>)</code>. Но данное выражение нарушает
    правила записи программ на Scheme.</li>

  <!--\indexR{внешнее представление}-->
  <li>Или, например, значение, возвращаемое формой вроде <code>`(',<span class="var">car</span>
    '(<span class="var">a</span> <span class="var">b</span>))</code>, где первым термом является
    процитированное значение функции <code><span class="func">car</span></code>. Это программа?
    В соответствии с синтаксисом R<sup>5</sup>RS, это значение не является программой,
    так как у него нет <em>внешнего представления</em>: его нельзя непосредственно набрать
    на клавиатуре. Тем не менее, <code><span class="special">eval</span></code> опять
    выполнит такую программу без запинки.</li>

<!--\indexE{##n##@\ic{\#<i>n</i>\#}, \ic{\#<i>n</i>=}}-->
<!--\indexR{рекурсия!синтаксическая}-->
  <li><p>Теперь воспользуемся нотацией <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>:
    пусть <code><span class="hash">#1=</span></code> даёт имя следующему за ним выражению,
    а <code><span class="hash">#1#</span></code> позволяет сослаться на выражение
    с именем <code><span class="num">1</span></code>. Держа это в голове,
    рассмотрим следующую программу, чьё графическое представление
    показано на рисунке <a href="#reflection/prog-and-val/pic:recusive">8.1</a>.</p>

<pre>(<span class="syntax">let</span> ((<span class="var">n</span> <span class="num">4</span>))
  <span class="hash">#1=</span>(<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) <span class="num">1</span>
         (<span class="func">*</span> <span class="var">n</span> ((<span class="special">lambda</span> (<span class="var">n</span>) <span class="hash">#1#</span>) (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))) ) )</pre>

        <p>Это значение содержит цикл. Можно сказать, это синтаксически
        рекурсивная программа. К сожалению, синтаксис Scheme запрещает
        подобные трюки. Осталось только объяснить это
        <code><span class="special">eval</span></code>, которую
        данный цикл ничуть не смущает.</p></li>
</ul>

<div class="image" id="reflection/prog-and-val/pic:recusive">
<img src="images/png12.png" alt="Изображение синтаксически рекурсивной функции факториала в виде списков Лиспа" style="width: 4.19in">
<span class="caption">Рис. 8.1. Синтаксически рекурсивный факториал.</span>
</div>

<p>Конечно, вам может показаться, что все эти примеры взяты из специальной книги
«Тысяча и одно извращение на Лиспе», но зато они вполне доходчиво
демонстрируют, насколько расплывчатой становится идея программы с появлением
<code><span class="func">eval</span></code>.
Похожие проблемы возникают и у макросов, проводящих разнообразные
вычисления со значениями-программами.</p>

<!--\indexR{ошибки!статические}-->
<!--\indexR{ошибки!динамические}-->
<!--\indexR{цитаты!запрещённые}-->
<p>Кстати, вспомните наш разговор о статических и динамических ошибках.
<span class="see">[см. раздел <a href="ch06_fast_interpretation.html#fast/fast/classify/sssect:static-err">6.1.4</a>]</span>
Где именно проводить границу
между ними? Наиболее либеральная позиция: допускать любые синтаксические
аномалии вроде <code>(<span class="special">quote</span> . <span class="num">3</span>)</code>, пока они не мешают проводить вычисления.
Наиболее строгая: допускать только такие программы, которые представимы в виде
конечного ациклического графа синтаксически корректных выражений. В этом случае
упомянутый ранее синтаксически рекурсивный факториал будет признан недопустимым,
несмотря на то, что отдельные выражения, из которых он состоит, являются вполне
корректными. Пожалуй, мы примем именно эту позицию (её же занимает и Scheme),
потому как существует алгоритм, рассмотренный в <span class="cite">[<a href="z1_bibliography.html#que92a">Que92a</a>]</span>, позволяющий
переписать произвольную синтаксически рекурсивную программу в виде дерева
инструкций без циклов. Что касается цитат, то мы разрешим только цитаты,
состоящие из конечного числа атомов, имеющих внешнее представление. Таким
образом, под запретом цитирования оказываются замыкания, продолжения, порты,
а также циклические<a class="footref" href="zz_footnotes.html#foot8.1"><sup>1</sup></a>
конструкции.</p>

<!--\indexR{синтаксис!проверка}-->
<p>Правила, формализующие понятие синтаксически корректной программы, можно
записать в виде следующих предикатов. Они проверяют синтаксис выражений и
обнаруживают<a class="footref" href="zz_footnotes.html#foot8.2"><sup>2</sup></a> циклы.</p>

<!--\indexC{program"?}-->
<!--\indexC{variables-list"?}-->
<!--\indexC{quotation"?}-->
<pre>(<span class="special">define</span> (<span class="func">program?</span> <span class="var">e</span>)
  (<span class="special">define</span> (<span class="func">program?</span> <span class="var">e</span> <span class="var">m</span>)
    (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
        (<span class="syntax">or</span> (<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">number?</span> <span class="var">e</span>) (<span class="func">string?</span> <span class="var">e</span>) (<span class="func">char?</span> <span class="var">e</span>) (<span class="func">boolean?</span> <span class="var">e</span>))
        (<span class="special">if</span> (<span class="func">memq</span> <span class="var">e</span> <span class="var">m</span>) <span class="hash">#f</span>
            (<span class="syntax">let</span> ((<span class="var">m</span> (<span class="func">cons</span> <span class="var">e</span> <span class="var">m</span>)))
              (<span class="special">define</span> (<span class="func">all-programs?</span> <span class="var">e+</span> <span class="var">m+</span>)
                (<span class="special">if</span> (<span class="func">memq</span> <span class="var">e+</span> <span class="var">m+</span>) <span class="hash">#f</span>
                    (<span class="syntax">let</span> ((<span class="var">m+</span> (<span class="func">cons</span> <span class="var">e+</span> <span class="var">m+</span>)))
                      (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">e+</span>)
                           (<span class="func">program?</span> (<span class="func">car</span> <span class="var">e+</span>) <span class="var">m</span>)
                           (<span class="syntax">or</span> (<span class="func">null?</span> (<span class="func">cdr</span> <span class="var">e+</span>))
                               (<span class="func">all-programs?</span> (<span class="func">cdr</span> <span class="var">e+</span>) <span class="var">m+</span>) ) ) ) ) )
              (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
                ((<span class="var">quote</span>) (<span class="syntax">and</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e</span>))
                              (<span class="func">quotation?</span> (<span class="func">cadr</span> <span class="var">e</span>))
                              (<span class="func">null?</span> (<span class="func">cddr</span> <span class="var">e</span>)) ))
                ((<span class="var">if</span>) (<span class="syntax">and</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e</span>))
                           (<span class="func">program?</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">m</span>)
                           (<span class="func">pair?</span> (<span class="func">cddr</span> <span class="var">e</span>))
                           (<span class="func">program?</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">m</span>)
                           (<span class="func">pair?</span> (<span class="func">cdddr</span> <span class="var">e</span>))
                           (<span class="func">program?</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">m</span>)
                           (<span class="func">null?</span> (<span class="func">cddddr</span> <span class="var">e</span>)) ))
                ((<span class="var">begin</span>) (<span class="func">all-programs?</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="hash">'()</span>))
                ((<span class="var">set!</span>) (<span class="syntax">and</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e</span>))
                             (<span class="func">symbol?</span> (<span class="func">cadr</span> <span class="var">e</span>))
                             (<span class="func">pair?</span> (<span class="func">cddr</span> <span class="var">e</span>))
                             (<span class="func">program?</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">m</span>)
                             (<span class="func">null?</span> (<span class="func">cdddr</span> <span class="var">e</span>)) ))
                ((<span class="var">lambda</span>) (<span class="syntax">and</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e</span>))
                               (<span class="func">variables-list?</span> (<span class="func">cadr</span> <span class="var">e</span>))
                               (<span class="func">all-programs?</span> (<span class="func">cddr</span> <span class="var">e</span>) <span class="hash">'()</span>) ))
                (<span class="syntax">else</span> (<span class="func">all-programs?</span> <span class="var">e</span> <span class="hash">'()</span>)) ) ) ) ) )
  (<span class="func">program?</span> <span class="var">e</span> <span class="hash">'()</span>) )

(<span class="special">define</span> (<span class="func">variables-list?</span> <span class="var">v*</span>)
  (<span class="special">define</span> (<span class="func">variables-list?</span> <span class="var">v*</span> <span class="var">already-seen</span>)
    (<span class="syntax">or</span> (<span class="func">null?</span> <span class="var">v*</span>)
        (<span class="syntax">and</span> (<span class="func">symbol?</span> <span class="var">v*</span>)
             (<span class="func">not</span> (<span class="func">memq</span> <span class="var">v*</span> <span class="var">already-seen</span>)) )
        (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">v*</span>)
             (<span class="func">symbol?</span> (<span class="func">car</span> <span class="var">v*</span>))
             (<span class="func">not</span> (<span class="func">memq</span> (<span class="func">car</span> <span class="var">v*</span>) <span class="var">already-seen</span>))
             (<span class="func">variables-list?</span> (<span class="func">cdr</span> <span class="var">v*</span>)
                              (<span class="func">cons</span> (<span class="func">car</span> <span class="var">v*</span>) <span class="var">already-seen</span>) ) ) ) )
  (<span class="func">variables-list?</span> <span class="var">v*</span> <span class="hash">'()</span>) )

(<span class="special">define</span> (<span class="func">quotation?</span> <span class="var">e</span>)
  (<span class="special">define</span> (<span class="func">quotation?</span> <span class="var">e</span> <span class="var">m</span>)
    (<span class="special">if</span> (<span class="func">memq</span> <span class="var">e</span> <span class="var">m</span>) <span class="hash">#f</span>
        (<span class="syntax">let</span> ((<span class="var">m</span> (<span class="func">cons</span> <span class="var">e</span> <span class="var">m</span>)))
          (<span class="syntax">or</span> (<span class="func">null?</span> <span class="var">e</span>) (<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">number?</span> <span class="var">e</span>)
              (<span class="func">string?</span> <span class="var">e</span>) (<span class="func">char?</span> <span class="var">e</span>) (<span class="func">boolean?</span> <span class="var">e</span>)
              (<span class="syntax">and</span> (<span class="func">vector?</span> <span class="var">e</span>)
                   (<span class="syntax">let</span> <span class="func">loop</span> ((<span class="var">i</span> <span class="num">0</span>))
                     (<span class="syntax">or</span> (<span class="func">&gt;=</span> <span class="var">i</span> (<span class="func">vector-length</span> <span class="var">e</span>))
                         (<span class="syntax">and</span> (<span class="func">quotation?</span> (<span class="func">vector-ref</span> <span class="var">e</span> <span class="var">i</span>) <span class="var">m</span>)
                              (<span class="func">loop</span> (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>)) ) ) ) )
              (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">e</span>)
                   (<span class="func">quotation?</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">m</span>)
                   (<span class="func">quotation?</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">m</span>) ) ) ) ) )
  (<span class="func">quotation?</span> <span class="var">e</span> <span class="hash">'()</span>) )</pre>

<p>Вооружившись предикатом <code><span class="func">program?</span></code>, можно уточнить определение специальной
формы <code><span class="special">eval</span></code> следующим образом:</p>

<pre>... ((<span class="var">eval</span>) (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>)))
              (<span class="special">if</span> (<span class="func">program?</span> <span class="var">v</span>)
                  (<span class="func">evaluate</span> <span class="var">v</span> <span class="var">env</span>)
                  (<span class="func">wrong</span> <span class="string">"Illegal program"</span> <span class="var">v</span>) ) )) ...</pre>


<!--\indexR{смысл программ!по отношению к синтаксису}-->
<!--\indexR{программы!смысл}-->
<!--\indexR{значения!как программы}-->
<p>Увы, это определение всё ещё весьма топорно, потому как предыдущие предикаты
не проверяют, <em>является ли</em> значение программой или корректной цитатой; они
лишь говорят, правильно ли <em>записана</em> программа или цитата. Это предел
информативности, доступной значениям. Значения сами по себе — это
ни программы, ни цитаты. Действительно, программа — это то, что интерпретатор
считает программой, то же самое касается и цитат. Именно интерпретатор придаёт
смысл значениям. Для уточнения этого момента перейдём к интерпретатору из
<a href="ch04_assignment_and_side_effects.html">четвёртой главы</a>. В нём память и продолжения
используются явно, а значения интерпретируемого Scheme представляются
объектами-замыканиями. Вот его вычислитель с добавленной формой
<code><span class="special">eval</span></code>:</p>

<!--\indexC{evaluate}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">evaluate-variable</span> <span class="var">e</span> <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>)
          (<span class="func">evaluate-quote</span> <span class="var">e</span> <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">evaluate-quote</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>))
        ((<span class="var">if</span>)     (<span class="func">evaluate-if</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>))
        ((<span class="var">begin</span>)  (<span class="func">evaluate-begin</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>))
        ((<span class="var">set!</span>)   (<span class="func">evaluate-set!</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>))
        ((<span class="var">lambda</span>) (<span class="func">evaluate-lambda</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>))
        <span class="highlight">((<span class="var">eval</span>)   (<span class="func">evaluate-eval</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>))</span>
        (<span class="syntax">else</span>     (<span class="func">evaluate-application</span> (<span class="func">car</span> <span class="var">e</span>) (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>)) ) ) )

(<span class="special">define</span> (<span class="func">evaluate-eval</span> <span class="var">e</span> <span class="var">r</span> <span class="var">s</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">r</span> <span class="var">s</span>
    (<span class="special">lambda</span> (<span class="var">v</span> <span class="var">ss</span>)
      (<span class="syntax">let</span> ((<span class="var">ee</span> (<span class="func">transcode-back</span> <span class="var">v</span> <span class="var">s</span>)))
        (<span class="special">if</span> (<span class="func">program?</span> <span class="var">ee</span>)
            (<span class="func">evaluate</span> <span class="var">ee</span> <span class="var">r</span> <span class="var">ss</span> <span class="var">k</span>)
            (<span class="func">wrong</span> <span class="string">"Illegal program"</span> <span class="var">ee</span>) ) ) ) ) )</pre>


<!--\indexC{load}-->
<!--\indexC{transcode-back}-->
<p>В этом интерпретаторе вычисленное значение первого аргумента формы <code><span class="special">eval</span></code>
дополнительно преобразуется (с помощью <code><span class="func">transcode-back</span></code>) из внутреннего
представления во внешнее. Затем проверяется правильность записи программы, после
чего она исполняется. Переменные <code><span class="var">e</span></code> и <code><span class="var">ee</span></code> хранят описания программ, а
переменная <code><span class="var">v</span></code> — значения. Задача <code><span class="func">transcode-back</span></code>: взять значение и
что-то с ним сделать, чтобы его можно было считать корректным описанием
программы. Примерно таким же путём можно получить <code><span class="special">eval</span></code> в интерпретаторе,
где нет <code><span class="special">eval</span></code>, но есть функция <code><span class="func">load</span></code>: записываем программу в файл,
задачу <code><span class="func">transcode-back</span></code> в этом случае выполняет <code><span class="func">display</span></code>; читаем и
исполняем программу из файла с помощью <code><span class="func">load</span></code>. Таким образом, программа
«компилируется»<a class="footref" href="zz_footnotes.html#foot8.3"><sup>3</sup></a> в имя этого файла.</p>

<p>Наконец, давайте рассмотрим также быстрый интерпретатор из <a href="ch06_fast_interpretation.html">шестой главы</a>. Там обнаружится ещё несколько интересных моментов. В нём
значения интерпретируемого языка представляются родными значениями Scheme, так
что нужда в преобразованиях отпадает. Главной задачей этого интерпретатора было
предварительное вычисление всех выражений, которые можно вычислить статически.</p>

<!--\indexC{meaning}-->
<!--\indexC{meaning-eval}-->
<pre>(<span class="special">define</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">meaning-reference</span> <span class="var">e</span> <span class="var">r</span> <span class="var">tail?</span>)
                      (<span class="func">meaning-quotation</span> <span class="var">e</span> <span class="var">r</span> <span class="var">tail?</span>) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">meaning-quotation</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>))
        ((<span class="var">lambda</span>) (<span class="func">meaning-abstraction</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>))
        ((<span class="var">if</span>)     (<span class="func">meaning-alternative</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) (<span class="func">cadddr</span> <span class="var">e</span>)
                                       <span class="var">r</span> <span class="var">tail?</span>))
        ((<span class="var">begin</span>)  (<span class="func">meaning-sequence</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>))
        ((<span class="var">set!</span>)   (<span class="func">meaning-assignment</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>))
        <span class="highlight">((<span class="var">eval</span>)   (<span class="func">meaning-eval</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>))</span>
        (<span class="syntax">else</span>     (<span class="func">meaning-application</span> (<span class="func">car</span> <span class="var">e</span>) (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>)) ) ) )

(<span class="special">define</span> (<span class="func">meaning-eval</span> <span class="var">e</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">m</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r</span> <span class="hash">#f</span>)))
    (<span class="special">lambda</span> ()
      (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">m</span>)))
        (<span class="special">if</span> (<span class="func">program?</span> <span class="var">v</span>)
            (<span class="syntax">let</span> ((<span class="var">mm</span> (<span class="func">meaning</span> <span class="var">v</span> <span class="var">r</span> <span class="var">tail?</span>)))
              (<span class="func">mm</span>) )
            (<span class="func">wrong</span> <span class="string">"Illegal program"</span> <span class="var">v</span>) ) ) ) ) )</pre>

<p>Вот теперь, на примере компилирующего интерпретатора, преобразующего программы
в деревья из инструкций-замыканий, становится окончательно понятным, что
компиляция <code><span class="var">v</span></code> не может быть выполнена статически. Впервые узел дерева,
создаваемый компилятором, не является простой операцией вроде выделения памяти,
проверки условия или обращения к структурам данных. Вместо этого (о ужас!)
внутри замыкания находится вызов <code><span class="func">meaning</span></code>. Это значит, что во время
исполнения программы требуется держать в памяти функцию <code><span class="func">meaning</span></code>, а также
всех её друзей, чтобы иметь возможность выполнять компиляцию программ на лету,
— недешёвое удовольствие!</p>

<div class="bigskip"></div>

<!--\indexCS{eval}{параллель с <code><span class="func">quote</span></code>}-->
<p>В этом разделе мы попытались уменьшить путаницу между понятиями значения и
программы. Похожие отношения существуют также между цитатами и значениями.
Поэтому иногда говорят, что <code><span class="special">eval</span></code> и <code><span class="special">quote</span></code> дополняют друг друга:
<code><span class="special">quote</span></code> получает описание некоторого значения, которое она должна создать, а
<code><span class="special">eval</span></code> получает значение, являющееся описанием некоторых действий, которые
она должна выполнить. Важно понимать, что они обе преобразуют обозначения
в обозначаемые объекты.</p>


<h2 id="reflection/sect:eval-as-spec-form"><span class="wrap"><span class="seq">8.2.</span><span class="title"><code><span class="special">eval</span></code> как специальная форма</span></span></h2>

<!--\indexR{взаимозаменимость}-->
<!--\indexCS{eval}{как специальная форма}-->
<p><code><span class="special">eval</span></code> в виде специальной формы приближает нас к идеалу —
уравнению (<a href="#reflection/eq:eval-idemp">1</a>); то есть, <code>(<span class="special">eval</span> (<span class="special">quote</span> <span class="math"><span class="ord var">π</span></span>))</code>
становится эквивалентом <span class="math"><span class="ord var">π</span></span>.
Но это верно лишь при чисто алгебраическом понимании этого уравнения, как, например,
в <span class="cite">[<a href="z1_bibliography.html#fh89">FH89</a>,
<a href="z1_bibliography.html#mul92">Mul92</a>]</span>. Любая надёжная
теория допускает взаимозаменимость двух объектов только в случае, когда они
эквивалентны <em>в любом контексте</em>. Точнее говоря, получается, что
(<a href="#reflection/eq:eval-idemp">1</a>) — это менее строгая форма
уравнения (<a href="#reflection/eq:eval-idemp-context">2</a>),
где <span class="math"><span class="ord var">C</span></span> означает контекст вычислений:</p>

<!--\indexCS{eval}{контракт!с контекстом}-->
<blockquote id="reflection/eq:eval-idemp-context" class="equation math"><span class="ord">∀</span><span class="ord var">C</span><span class="ord">: </span><span class="ord var">C</span><span class="open">[</span><span class="normal ord"><code>(<span class="special">eval</span> '<span class="math"><span class="ord var">π</span></span>)</code></span><span class="close">]</span><span class="rel">≡</span><span class="ord var">C</span><span class="open">[</span><span class="ord var">π</span><span class="close">]</span><span class="eqno">(2)</span></blockquote>

<p>Следовательно, значением замкнутой формы (не имеющей свободных переменных)
вроде <code>(<span class="special">eval</span> '((<span class="special">lambda</span> (<span class="var">x</span> <span class="var">y</span>) <span class="var">x</span>) <span class="num">1</span> <span class="num">2</span>))</code> всегда будет <code><span class="num">1</span></code>. Однако,
вычисляемая форма может иметь контекст в виде лексического окружения:</p>

<pre>((<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">eval</span> '<span class="var">x</span>))
 <span class="num">3</span> )                       <span class="math"><span class="rel">→</span></span> <span class="num">3</span>
((<span class="special">lambda</span> (<span class="var">x</span> <span class="var">y</span>) (<span class="special">eval</span> <span class="var">y</span>))
 <span class="num">4</span> '<span class="var">x</span> )                    <span class="math"><span class="rel">→</span></span> <span class="num">4</span>
((<span class="special">lambda</span> (<span class="var">x</span> <span class="var">y</span> <span class="var">z</span>) (<span class="special">eval</span> <span class="var">y</span>))
 <span class="num">5</span> (<span class="func">list</span> '<span class="var">eval</span> '<span class="var">z</span>) '<span class="var">x</span> )    <span class="math"><span class="rel">→</span></span> <span class="num">5</span></pre>

<!--\indexR{лексическое окружение!и eval@и \protect<code><span class="func">eval</span></code>}-->
<p>Подобное поведение возможно только при условии, что <code><span class="special">eval</span></code> доступно
лексическое окружение. В быстром интерпретаторе замыканию, создаваемому
<code><span class="func">meaning</span></code> для <code><span class="special">eval</span></code>, необходимо не только получить доступ к функции
<code><span class="func">meaning</span></code>, но и захватить текущее лексическое окружение <code><span class="var">r</span></code> (а также
<code><span class="var">tail?</span></code>), чтобы проводить внутренние вычисления в правильном локальном
лексическом окружении. Следовательно, во время исполнения программ потребуется
хранить не только <code><span class="func">meaning</span></code>, а ещё и всевозможные окружения.</p>

<p>Это видно ещё лучше на примере компилятора в байт-код из <a href="ch07_compilation.html">седьмой главы</a>. Функция-анализатор <code><span class="func">meaning-eval</span></code> вызывает
функцию-генератор <code><span class="func">EVAL/CE</span></code> (от <em class="term">eval in current environment</em>).
Она принимает выражение, которое необходимо вычислить, и окружение для
компиляции.</p>

<!--\indexC{EVAL/CE}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-eval</span> <span class="var">e</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">m</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r</span> <span class="hash">#f</span>)))
    (<span class="func">EVAL/CE</span> <span class="var">m</span> <span class="var">r</span>) ) )

(<span class="special">define</span> (<span class="func">EVAL/CE</span> <span class="var">m</span> <span class="var">r</span>)
  (<span class="func">append</span> (<span class="func">PRESERVE-ENV</span>) (<span class="func">CONSTANT</span> <span class="var">r</span>) (<span class="func">PUSH-VALUE</span>)
          <span class="var">m</span> (<span class="func">COMPILE-RUN</span>) (<span class="func">RESTORE-ENV</span>) ) )</pre>

<p>Функция <code><span class="func">EVAL/CE</span></code> игнорирует <code><span class="var">tail?</span></code> и всегда сохраняет локальное
окружение. Новая «простейшая» инструкция <code><span class="func">COMPILE-RUN</span></code> содержит в себе
весь компилятор-интерпретатор. Она забирает выражение из регистра <code><span class="var">*val*</span></code> и
окружение с верхушки стека, а затем применяет к ним функцию
<code><span class="func">compile-on-the-fly</span></code>, которая выполняет компиляцию, загружает в память
полученный байт-код и передаёт ему управление так, как если бы там была обычная
функция.</p>

<!--\indexC{COMPILE-RUN}-->
<!--\indexC{compile-and-run}-->
<!--\indexC{compile-on-the-fly}-->
<pre>(<span class="special">define</span> (<span class="func">COMPILE-RUN</span>) (<span class="func">list</span> <span class="num">255</span>))

(<span class="syntax">define-instruction</span> (<span class="func">COMPILE-RUN</span>) <span class="num">255</span>
  (<span class="syntax">let</span> ((<span class="var">v</span> <span class="var">*val*</span>)
        (<span class="var">r</span> (<span class="func">stack-pop</span>)) )
    (<span class="special">if</span> (<span class="func">program?</span> <span class="var">v</span>)
        (<span class="func">compile-and-run</span> <span class="var">v</span> <span class="var">r</span> <span class="hash">#f</span>)
        (<span class="func">signal-exception</span> <span class="hash">#t</span>
          (<span class="func">list</span> <span class="string">"Illegal program"</span> <span class="var">v</span>) ) ) ) )

(<span class="special">define</span> (<span class="func">compile-and-run</span> <span class="var">v</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">unless</span> <span class="var">tail?</span> (<span class="func">stack-push</span> <span class="var">*pc*</span>))
  (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">compile-on-the-fly</span> <span class="var">v</span> <span class="var">r</span>)) )

(<span class="special">define</span> (<span class="func">compile-on-the-fly</span> <span class="var">v</span> <span class="var">r</span>)
  (<span class="special">set!</span> <span class="var">g.current</span> <span class="hash">'()</span>)
  (<span class="func">for-each</span> <span class="var">g.current-extend!</span> <span class="var">sg.current.names</span>)
  (<span class="special">set!</span> <span class="var">*quotations*</span> (<span class="func">vector-&gt;list</span> <span class="var">*constants*</span>))
  (<span class="special">set!</span> <span class="var">*dynamic-variables*</span> <span class="var">*dynamic-variables*</span>)
  (<span class="syntax">let</span> ((<span class="var">code</span> (<span class="func">apply</span> <span class="var">vector</span> (<span class="func">append</span> (<span class="func">meaning</span> <span class="var">v</span> <span class="var">r</span> <span class="hash">#f</span>) (<span class="func">RETURN</span>)))))
    (<span class="special">set!</span> <span class="var">sg.current.names</span> (<span class="func">map</span> <span class="var">car</span> (<span class="func">reverse</span> <span class="var">g.current</span>)))
    (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">make-vector</span> (<span class="func">length</span> <span class="var">sg.current.names</span>) <span class="var">undefined-value</span>)))
      (<span class="func">vector-copy!</span> <span class="var">sg.current</span> <span class="var">v</span> <span class="num">0</span> (<span class="func">vector-length</span> <span class="var">sg.current</span>))
      (<span class="special">set!</span> <span class="var">sg.current</span> <span class="var">v</span>) )
    (<span class="special">set!</span> <span class="var">*constants*</span> (<span class="func">apply</span> <span class="var">vector</span> <span class="var">*quotations*</span>))
    (<span class="special">set!</span> <span class="var">*dynamic-variables*</span> <span class="var">*dynamic-variables*</span>)
    (<span class="func">install-code!</span> <span class="var">code</span>) ) )</pre>

<!--\indexR{компиляция!на лету}-->
<!--\indexR{загрузчик!динамический}-->
<p>При компиляции на лету, естественно, потребуются все глобальные переменные,
используемые при обычной компиляции: <code><span class="var">g.current</span></code> (окружение изменяемых
глобальных переменных), <code><span class="var">*quotations*</span></code> и <code><span class="var">*dynamic-variables*</span></code><a class="footref" href="zz_footnotes.html#foot8.4"><sup>4</sup></a>. Откомпилированный код заканчивается инструкцией <code><span class="func">RETURN</span></code>,
возвращающей управление обратно вызывающей программе. После завершения
компиляции окружение исполнения расширяется новыми цитатами, а также глобальными
и динамическими переменными, созданными в процессе. В конце концов полученный
фрагмент кода загружается в память и начинается его исполнение.</p>


<!--\indexCS{eval}{реализация в Си}-->
<!--\indexR{библиотека!динамически загружаемая}-->
<!--\indexR{динамически загружаемые библиотеки}-->
<!--\indexR{сборка мусора!динамическая компиляция}-->
<p>Подобная загрузка принципиально аналогична механизму динамически подключаемых
библиотек. Для языков вроде Си <code><span class="special">eval</span></code> можно свести к записи строки
с программой в файл, компиляции этого файла с помощью <code>cc</code>, загрузке
средствами операционной системы полученной библиотеки и вызову содержащихся
внутри неё функций. К сожалению, на данном этапе наша машина не поддерживает
удаление из памяти загружаемого подобным образом кода, так что он остаётся
висеть мёртвым грузом после завершения исполнения. Мусорить всегда легче, чем
убирать.</p>

<p>Таким образом, стоимость новой специальной формы составляют:</p>

<ul>
  <li>новая инструкция <code><span class="func">COMPILE-RUN</span></code>, требующая наличия
    функции <code><span class="func">meaning</span></code> и некоторых другими, что приводит
    к значительному увеличению размера кода для небольших
    приложений;</li>

  <li>расходы памяти на сохранение текущего окружения при каждом
    вызове <code><span class="special">eval</span></code>.</li>
</ul>

<p class="noindent">К счастью, дополнительные окружения необходимо сохранять только при этих
вызовах, так что суммарная стоимость использования
<code><span class="special">eval</span></code> линейно зависит
от количества данных форм в программе.</p>

<p>Кроме того, <code><span class="special">eval</span></code> иногда используется для отладки: ведь она позволяет
внедрить REPL в саму программу и просматривать или изменять переменные изнутри,
обращаясь к ним по именам. А если туда встроен ещё и отладчик, позволяющий
прервать исполнение программы в произвольный момент времени (например, по
команде с клавиатуры), то кроме окружений необходимо вдобавок где-то хранить и
весь исходный код вместе с таблицей символов.</p>


<h3 id="reflection/eval-as-spec-form/ssect:global"><span class="wrap"><span class="seq">8.2.1.</span><span class="title">Глобальные переменные</span></span></h3>

<!--\indexR{глобальное окружение!и eval@и \protect<code><span class="func">eval</span></code>}-->
<p>Согласно контракту (<a href="#reflection/eq:eval-idemp-context">2</a>), выражение
<code>(<span class="special">eval</span> '(<span class="special">set!</span> <span class="var">foo</span> <span class="num">33</span>))</code> должно быть эквивалентным <code>(<span class="special">set!</span> <span class="var">foo</span> <span class="num">33</span>)</code>. Впервые мы
столкнулись с неоднозначностью семантики присваивания в <a href="ch04_assignment_and_side_effects.html">четвёртой главе</a>. Затем в разделе <a href="ch06_fast_interpretation.html#fast/fast/ssect:variations">6.1.9</a>
были рассмотрены различные варианты реализации окружений и присваивания.
Следовательно, если для создания переменной
достаточно её упоминания, то и <code><span class="special">eval</span></code> это позволено. И наоборот, если
переменные необходимо определять до использования, то данное ограничение
касается в том числе и <code><span class="special">eval</span></code>. Функция <code><span class="func">compile-on-the-fly</span></code> расширяет
в конце своей работы глобальное окружение корректно созданными глобальными
переменными компилируемой программы.</p>


<!--\indexCS{eval}{и побочные эффекты}-->
<!--\indexR{побочные эффекты!и eval@и <code><span class="func">eval</span></code>}-->
<p>Это замечание сделано для того, чтобы вы поняли, что уравнения
(<a href="#reflection/eq:eval-idemp">1</a>) и (<a href="#reflection/eq:eval-idemp-context">2</a>)
касаются не только значений <span class="math"><span class="ord var">π</span></span> и
<code>(<span class="special">eval</span> '<span class="math"><span class="ord var">π</span></span>)</code>, а и всех иных побочных
эффектов вроде создания новых переменных, изменения значений старых, переходов
и т. д. Именно в таком смысле надо понимать эквивалентность выражений
в уравнении (<a href="#reflection/eq:eval-idemp-context">2</a>): они должны быть одинаковы
во всём, везде и всегда. Должно быть абсолютно невозможным<a class="footref" href="zz_footnotes.html#foot8.5"><sup>5</sup></a> составить программу, которая смогла бы различить
<span class="math"><span class="ord var">π</span></span> и
<code>(<span class="special">eval</span> '<span class="math"><span class="ord var">π</span></span>)</code> по поведению.</p>


<h2 id="reflection/sect:eval-as-func"><span class="wrap"><span class="seq">8.3.</span><span class="title"><code><span class="func">eval</span></code> как функция</span></span></h2>

<!--\indexCS{eval}{как примитив}-->
<p>Специальная форма <code><span class="special">eval</span></code> вычисляет свой
единственный аргумент подобно функциям, так что возникает логичный вопрос: можно ли
добиться того же поведения с помощью функции, а не специальной формы? Для ответа на
него давайте снова обратимся к нашим интерпретаторам и попробуем написать для каждого
из них соответствующий примитив.</p>

<p>С наивным интерпретатором из первой главы <span class="see">[см. раздел <a href="ch01_basics.html#basics/sect:basic-evaluator">1.2</a>]</span> всё просто:</p>

<pre>(<span class="syntax">defprimitive</span> <span class="var">eval</span>
  (<span class="special">lambda</span> (<span class="var">v</span>)
    (<span class="special">if</span> (<span class="func">program?</span> <span class="var">v</span>)
        (<span class="func">evaluate</span> <span class="var">v</span> <span class="var">env.global</span>)
        (<span class="func">wrong</span> <span class="string">"Illegal program"</span> <span class="var">v</span>) ) ) )</pre>

<!--\indexC{eval/at}-->
<!--\indexC{eval/ce}-->
<p>Сразу же в глаза бросается один серьёзный момент: <code><span class="func">eval</span></code> недоступно текущее
лексическое окружение. Так как в <code><span class="func">evaluate</span></code> необходимо передать хоть что-то,
мы берём единственное окружение, которое есть в наличии, — глобальное! Следовательно, эта
функция-вычислитель работает на самом верхнем уровне вложенности — уровне
глобальных определений. Назовём её <code><span class="func">eval/at</span></code>, от <em class="term">eval at top-level</em>,
а предыдущий вариант будем называть <code><span class="special">eval/ce</span></code>, если нам потребуется их
различать. Функция <code><span class="func">eval/at</span></code> не так уж и плоха, какой может показаться на
первый взгляд: ей всё же не требуется сохранять текущее лексическое окружение,
что экономит немного памяти.</p>

<p>Для пояснения поведения <code><span class="func">eval/at</span></code> воспользуемся предыдущим примером:</p>

<pre>(<span class="special">set!</span> <span class="var">x</span> <span class="num">2</span>) (<span class="special">set!</span> <span class="var">z</span> <span class="num">1</span>)
((<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">eval/at</span> '<span class="var">x</span>))
 <span class="num">3</span> )                          <span class="math"><span class="rel">→</span></span> <span class="num">2</span>
((<span class="special">lambda</span> (<span class="var">x</span> <span class="var">y</span>) (<span class="func">eval/at</span> <span class="var">y</span>))
 <span class="num">4</span> '<span class="var">x</span> )                       <span class="math"><span class="rel">→</span></span> <span class="num">2</span>
((<span class="special">lambda</span> (<span class="var">x</span> <span class="var">y</span> <span class="var">z</span>) (<span class="func">eval/at</span> <span class="var">y</span>))
 <span class="num">5</span> (<span class="func">list</span> '<span class="var">eval/at</span> '<span class="var">z</span>) '<span class="var">x</span> )    <span class="math"><span class="rel">→</span></span> <span class="num">1</span></pre>

<p class="noindent">При необходимости можно (приближённо) выразить <code><span class="func">eval/at</span></code> через <code><span class="special">eval/ce</span></code>:</p>

<pre>(<span class="special">define</span> (<span class="func">eval/at</span> <span class="var">x</span>) (<span class="special">eval/ce</span> <span class="var">x</span>))</pre>

<p class="noindent">К сожалению, в захватываемом <code><span class="special">eval/ce</span></code> окружении
оказывается одна лишняя переменная — локальная переменная <code><span class="var">x</span></code>
скрывает одноимённую глобальную.
<span class="see">[см. упр. <a href="#reflection/ex:no-capture">8.3</a>]</span>
Похоже, эту проблему можно решить, применив
более тонкий подход к управлению окружениями, поэтому попробуем реализовать
<code><span class="func">eval/at</span></code> для интерпретатора байт-кодов. Новое определение снова использует
функцию <code><span class="func">compile-and-run</span></code>, но при этом просит её не сохранять адрес возврата,
так как он уже был сохранён при вызове функции <code><span class="func">eval/at</span></code>. Как и в предыдущем
случае, компиляция выполняется в единственно доступном окружении <code><span class="var">r.init</span></code>.</p>

<pre>(<span class="syntax">definitial</span> <span class="var">eval</span>
  (<span class="syntax">let*</span> ((<span class="var">arity</span> <span class="num">1</span>)
         (<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
    (<span class="func">make-primitive</span>
      (<span class="special">lambda</span> ()
        (<span class="special">if</span> (<span class="func">=</span> <span class="var">arity+1</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>))
            (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>)))
              (<span class="special">if</span> (<span class="func">program?</span> <span class="var">v</span>)
                  (<span class="func">compile-and-run</span> <span class="var">v</span> <span class="var">r.init</span> <span class="hash">#t</span>)
                  (<span class="func">signal-exception</span> <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Illegal program"</span> <span class="var">v</span>)) ) )
            (<span class="func">signal-exception</span> <span class="hash">#t</span>
              (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">eval</span>) ) ) ) ) ) )</pre>

<p>Не стоит понимать ограниченность <code><span class="func">eval/at</span></code> глобальным уровнем чересчур
буквально, ведь ещё остаются динамические переменные. Совершенно не важно,
реализована <code><span class="func">eval</span></code> как специальная форма или функция, — следующее
выражение всегда будет работать так, как задумано:</p>

<pre>(<span class="special">dynamic-let</span> (<span class="var">a</span> <span class="num">22</span>)
  (<span class="func">eval</span> '(<span class="special">dynamic</span> <span class="var">a</span>)) ) <span class="math"><span class="rel">→</span></span> <span class="num">22</span></pre>

<p>Изначальный контракт <code><span class="func">eval</span></code>, выраженный
уравнением (<a href="#reflection/eq:eval-idemp">1</a>), не подразумевал какого-либо
контекста вообще. Уравнению (<a href="#reflection/eq:eval-idemp-context">2</a>), судя по
рассмотренным примерам, <code><span class="func">eval/at</span></code> тоже не удовлетворяет.
Поэтому для неё мы составим новый контракт, записанный ниже
в уравнении (<a href="reflection/eq:eval-top-context">3</a>);
здесь переменная <i>v</i> не захватывается создаваемым замыканием.</p>

<!--\indexCS{eval}{контракт!eval/at@<code><span class="func">eval/at</span></code>}-->
<blockquote id="reflection/eq:eval-top-context" class="equation math"><span class="ord var">C</span><span class="open">[</span><span class="normal ord"><code>(<span class="func">eval/at</span> '<span class="math"><span class="ord var">π</span></span>)</code></span><span class="close">]</span><span class="rel">≡</span><span class="normal ord"><code>(<span class="syntax">let</span> ((<i>v</i> (<span class="special">lambda</span> () <span class="math"><span class="ord var">π</span></span>))) <span class="math"><span class="ord var">C</span><span class="open">[</span><span class="normal ord"><code>(<i>v</i>)</code></span><span class="close">]</span></span>)</code></span><span class="eqno">(3)</span></blockquote>

<p>Чаще всего <code><span class="func">eval</span></code>, реализуемая лисп-системами, является именно <code><span class="func">eval/at</span></code>.</p>

<h2 id="reflection/sect:cost"><span class="wrap"><span class="seq">8.4.</span><span class="title">Цена <code><span class="func">eval</span></code></span></span></h2>

<!--\indexCS{eval}{стоимость}-->
<p>Довольно сложно оценить суммарную стоимость <code><span class="func">eval</span></code>.
Предположим, разрабатываемый программный продукт является ничем иным, как
<code>(<span class="func">display</span> <span class="string">"Hello world!"</span>)</code>.
Если специальная форма <code><span class="special">eval/ce</span></code> не встречается в программе
(а это можно проверить статически), то стоимость её использования нулевая! Если
она всё же используется, то тянет за собой весь компилятор, так что размер
приложения увеличивается примерно на порядок; скажем, где-то с 50 килобайт
до 500. Если же динамический вычислитель реализован в виде функции и нельзя
доказать, что эта функция не нужна, то стоимость остаётся примерно той же.
Код <code><span class="func">eval/at</span></code> из приложения можно выбросить лишь тогда, когда компилятор
абсолютно уверен в том, что она никогда не будет вызвана. Язык может серьёзно
помочь с доказательством этого утверждения: например, в Scheme достаточно
убедиться, что глобальная переменная <code><span class="var">eval/at</span></code> не упоминается в программе.
В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>, напротив, в общем случае данное утверждение недоказуемо, так
как кроме всего прочего потребуется доказать, что никто и нигде не создал строку
<code><span class="string">"eval/at"</span></code>, не превратил её в символ с помощью <code><span class="func">find-symbol</span></code> и не получил
соответствующую функцию с помощью <code><span class="func">symbol-function</span></code>. Уже страшно? А теперь
представьте, что сама <code><span class="func">symbol-function</span></code> вызывается таким же образом</p>

<p>А что насчёт самой <code><span class="func">eval</span></code>, можно ли как-то контролировать значения её
аргумента? Аналогично — нет. Это вряд ли возможно выполнить одновременно
легко, быстро и статически, не лишив при этом <code><span class="func">eval</span></code> выразительности, так что
придётся считать, что ей может быть передано любое значение. Следовательно, мы
не можем трогать ни одну глобальную переменную вообще, так как <em>всё</em>
потенциально может быть использовано и вызвано. Скомпилированное приложение
должно содержать все без исключения возможности языка, что для мощных языков
вроде <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> означает увеличение размеров получаемого приложения ещё на
один порядок.</p>

<!--\indexCS{eval}{и оптимизации}-->
<p>И это ещё далеко не самое ужасное. Если не предпринять никаких мер для строгого
контроля над использованием глобального окружения, как в <span class="cite">[<a href="z1_bibliography.html#qp91b">QP91b</a>]</span>, где
система модулей позволяет управлять доступом на чтение и модификацию глобальных
переменных, то <code><span class="func">eval</span></code>
убивает на корню многие возможности для оптимизации.
Рассмотрим следующий пример:</p>

<pre>(<span class="special">define</span> (<span class="func">fib</span> <span class="var">n</span>)
  (<span class="special">if</span> (<span class="func">&lt;</span> <span class="var">n</span> <span class="num">2</span>) (<span class="func">eval</span> (<span class="func">read</span>))
      (<span class="func">+</span> (<span class="func">fib</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)) (<span class="func">fib</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">2</span>))) ) )</pre>

<p>Не будем пока обращать внимание на другие возможные варианты поведения
<code><span class="func">eval</span></code>, сконцентрируемся на том, что она способна изменить значение
переменной <code><span class="var">fib</span></code>. Следовательно, при рекурсивном вызове потребуется заново
извлекать адрес функции из глобальной переменной <code><span class="var">fib</span></code>, а не просто вслепую
прыгать по <code><span class="func">GOTO</span></code>. Так как <code><span class="func">eval</span></code> может изменить любую переменную, нельзя
больше полагаться на привычные методы анализа неизменяемости глобального
окружения. Одно-единственное обращение к <code><span class="func">eval</span></code> может привести к абсолютно
непредсказуемым последствиям.</p>

<p>По всем перечисленным причинам <code><span class="func">eval</span></code> считается дорогим удовольствием. Тем
не менее, в большом приложении (где кода на несколько мегабайт) и во время
разработки, когда всё меняется и отбрасывается, <code><span class="func">eval</span></code> может быть весьма
полезной. Действительно, если понадобится динамически проводить несложные
вычисления, то часто проще и эффективнее (с точки зрения количества времени,
затраченного на разработку, умноженного на зарплату разработчика) использовать
для этого <code><span class="func">eval</span></code>, нежели писать и отлаживать с нуля свой собственный
интерпретатор. Лисп — удивительно расширяемый язык, и наличие <code><span class="func">eval</span></code>
в стандартной библиотеке — это его серьёзное преимущество.</p>


<h2 id="reflection/sect:interpreted-eval"><span class="wrap"><span class="seq">8.5.</span><span class="title">Интерпретируемая <code><span class="func">eval</span></code></span></span></h2>

<!--\indexCS{eval}{интерпретируемая}-->
<!--\indexR{интерпретатор!встроенный в язык}-->
<p>Судя по этой книге, написание интерпретатора Scheme не представляет особых
трудностей. Допустим, в лисп-системе нет <code><span class="func">eval</span></code>, может ли пользователь
реализовать её самостоятельно? В конце концов, существует огромный выбор
интерпретаторов, пользователю достаточно скачать понравившийся (или написать
самостоятельно) и включить его в свою программу, правда? Ну, и да, и нет.</p>

<p>Если интерпретатор пишется на Scheme, то это может только функция, так как
в Scheme нельзя определять новые специальные формы. Кроме того, возникают две
проблемы иного рода.</p>


<h3 id="reflection/interpreted-eval/ssect:interchange"><span class="wrap"><span class="seq">8.5.1.</span><span class="title">Взаимозаменимость представлений</span></span></h3>

<!--\indexR{протокол вызова функций!при явных вычислениях}-->
<!--\indexR{взаимозаменимость}-->
<p>Первая из упомянутых проблем касается взаимодействия между базовым языком и
написанным на нём интерпретатором. Дело в том, что интерпретатор не может
вводить новые типы данных, он вынужден пользоваться типами данных, которые ему
предоставляет базовый язык, чтобы программы могли понимать друг друга. Если
интерпретатор пользуется точечными парами, то они должны быть точечными парами
базового языка; логические значения и числа должны быть одними и теми же;
функции обоих языков должны соблюдать один и тот же протокол вызова. Результат
любых динамических вычислений должен быть пригоден для использования в основной
программе, как в следующем примере:</p>

<pre>((<span class="func">eval</span> '(<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">cons</span> <span class="var">x</span> <span class="var">x</span>)))
 <span class="num">33</span> )    <span class="math"><span class="rel">→</span></span> (<span class="num">33</span> . <span class="num">33</span>)</pre>

<p>И наоборот, интерпретатор тоже должен уметь пользоваться функциями базового
языка:</p>

<pre>(((<span class="func">eval</span> '(<span class="special">lambda</span> (<span class="var">f</span>)
           (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">f</span> <span class="var">x</span>)) ))
  <span class="var">list</span> )
 <span class="num">44</span> )    <span class="math"><span class="rel">→</span></span> (<span class="num">44</span>)</pre>

<p>Один из вариантов общего протокола вызова: всегда использовать функции
с произвольной арностью: <code>(<span class="special">lambda</span> <span class="var">values</span> ...)</code>, тогда достаточно научить
интерпретатор вынимать аргументы из списков. Для интерпретатора из первой главы,
к примеру, это делается соответственно его природе — элементарно и наивно:</p>

<!--\indexC{invoke}-->
<pre>(<span class="special">define</span> (<span class="func">invoke</span> <span class="var">fn</span> <span class="var">args</span>)
  (<span class="special">if</span> (<span class="func">procedure?</span> <span class="var">fn</span>)
      (<span class="func">apply</span> <span class="var">fn</span> <span class="var">args</span>)
      (<span class="func">wrong</span> <span class="string">"Not a function"</span> <span class="var">fn</span>) ) )

(<span class="special">define</span> (<span class="func">make-function</span> <span class="var">variables</span> <span class="var">body</span> <span class="var">env</span>)
  (<span class="special">lambda</span> <span class="var">values</span>
    (<span class="func">eprogn</span> <span class="var">body</span> (<span class="func">extend</span> <span class="var">env</span> <span class="var">variables</span> <span class="var">values</span>)) ) )</pre>

<p>Кроме того, необходимо позаботиться об ошибках: внешний интерпретатор должен
уметь понимать и обрабатывать ошибки, возникающие во внутреннем. Этот вопрос
мы обойдём стороной.</p>


<h3 id="reflection/interpreted-eval/ssect:global"><span class="wrap"><span class="seq">8.5.2.</span><span class="title">Глобальное окружение</span></span></h3>

<!--\indexR{глобальное окружение!динамическое расширение}-->
<p>Вторая проблема касается различия представлений глобального окружения. Каждый из
наших интерпретаторов определяет глобальное окружение по-своему, используя
макросы <code><span class="syntax">definitial</span></code>, <code><span class="syntax">defprimitive</span></code> и другие. Но теперь интерпретатор
обязан пользоваться глобальным окружением базового языка, или хотя бы обеспечить
корректную синхронизацию его состояния. Что бы там ни было, следующая программа
должна выполняться правильно и без ошибок:</p>

<pre>(<span class="special">begin</span> (<span class="special">set!</span> <span class="var">foo</span> <span class="num">128</span>)
       (<span class="func">eval</span> '(<span class="special">set!</span> <span class="var">bar</span> (<span class="func">+</span> <span class="var">foo</span> <span class="var">foo</span>)))
       <span class="var">bar</span> )                          <span class="math"><span class="rel">→</span></span> <span class="num">256</span></pre>

<h4 id="reflection/interpreted-eval/global/sssect:autonomous"><span class="wrap"><span class="title">Автономные скомпилированные приложения</span></span></h4>

<!--\indexR{глобальное окружение!и eval@и \protect<code><span class="func">eval</span></code>!в автономных приложениях}-->
<!--\indexR{автономные приложения}-->
<p>Компиляторы вроде Scheme<span class="math"><span class="rel">→</span></span>C <span class="cite">[<a href="z1_bibliography.html#bar89">Bar89</a>]</span> или Bigloo <span class="cite">[<a href="z1_bibliography.html#ser94">Ser94</a>]</span> работают
с файлами, в которых хранится фиксированный исходный код. Получаемые таким
образом автономные приложения принципиально не могут пользоваться переменными,
которые не были явно упомянуты в исходном коде. Следовательно, переменные,
создаваемые <code><span class="func">eval</span></code>, будут доступны только внутри <code><span class="func">eval</span></code>. В таких условиях
возможно лишь обеспечить интерпретатору доступ к глобальным переменным внешней
программы. Ответственной за это будет пара функций <code><span class="func">global-value</span></code> и
<code><span class="func">set-global-value!</span></code>. Компилятор автоматически формирует эти функции
в процессе чтения программы. <span class="see">[см. упр. <a href="ch07_compilation.html#compilation/ex:global-value">7.3</a>]</span> По окончании
обработки они будут содержать все используемые<a class="footref" href="zz_footnotes.html#foot8.6"><sup>6</sup></a> глобальные переменные. Этот список является
статическим, неизменным во время работы скомпилированного приложения.</p>

<!--\indexC{global-value}-->
<!--\indexC{set-global-value"!}-->
<pre>(<span class="special">define</span> (<span class="func">global-value</span> <span class="var">name</span>)
  (<span class="syntax">case</span> <span class="var">name</span>
    ((<span class="var">car</span>) <span class="var">car</span>)
    ...
    ((<span class="var">foo</span>) <span class="var">foo</span>)
    (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"No such global variable"</span> <span class="var">name</span>)) ) )

(<span class="special">define</span> (<span class="func">set-global-value!</span> <span class="var">name</span> <span class="var">value</span>)
  (<span class="syntax">case</span> <span class="var">name</span>
    ((<span class="var">foo</span>) (<span class="special">set!</span> <span class="var">foo</span> <span class="var">value</span>))
    ...
    (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"No such mutable global variable"</span> <span class="var">name</span>)) ) )</pre>

<p>Интерпретатор может создавать у себя внутри столько глобальных переменных,
сколько ему нужно, но ни одна из них не будет видна внешней программе. Тем
не менее, интерпретатор может общаться с внешней программой посредством тех
переменных, которые существовали в момент компиляции.</p>


<h4 id="reflection/interpreted-eval/global/sssect:interactive"><span class="wrap"><span class="title">Интерактивная система</span></span></h4>

<!--\indexR{глобальное окружение!и eval@и \protect<code><span class="func">eval</span></code>!в интерактивной сессии}-->
<p>Если же работа с лисп-системой происходит с помощью REPL, то и система,
и интерпретатор могут создавать новые переменные. Приведённая ранее программа
является хорошим примером такого взаимодействия: внешняя система запрашивает
значение переменной, созданной внутренним интерпретатором, который запросил
значение переменной, созданной системой:</p>

<pre>? (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">foo</span> <span class="num">128</span>)
         (<span class="func">eval</span> '(<span class="special">set!</span> <span class="var">bar</span> (<span class="func">+</span> <span class="var">foo</span> <span class="var">foo</span>)))
         <span class="num">2001</span> )
= <span class="num">2001</span>
? <span class="var">bar</span>
= <span class="num">256</span></pre>

<p>Есть несколько вариантов реализации подобного сотрудничества.</p>


<h4 id="reflection/interpreted-eval/global/sssect:symbols"><span class="wrap"><span class="title">Символы</span></span></h4>

<!--\indexR{символы!связь с переменными}-->
<p>Традиционное решение заключается в использовании символов. Одним из столпов
семантики Лиспа является тесная взаимосвязь понятий символа и переменной:
переменные записываются с помощью символов, а символы (как показано далее)
могут играть роль переменных.</p>

<!--\indexC{string->symbol}-->
<!--\indexR{хеш-таблицы}-->
<p>Символы — это составные структуры данных, имеющие как минимум одно поле:
строку с собственным именем. В Scheme символы можно создавать явно с помощью
функции <code><span class="func">string-&gt;symbol</span></code>. Имена символов уникальны. Обычно это гарантируется
хеш-таблицей, связывающей строки с символами. Функция <code><span class="func">string-&gt;symbol</span></code>
сначала пытается отыскать строку в данной хеш-таблице; если такая строка там
есть, то она возвращает соответствующий символ, а в противном случае
<code><span class="func">string-&gt;symbol</span></code> создаёт новый символ и заносит его в таблицу на будущее.
Иногда ради ускорения поиска используются различные вспомогательные скрытые
поля, связывающие группы символов между собой.</p>

<!--\indexR{символы!списки свойств}-->
<!--\indexR{списки свойств}-->
<p>Часто символы имеют также списки свойств. Обычно они реализуются в виде
P-списков, но нередко в этой роли можно встретить A-списки или хеш-таблицы. От
выбора внутренней структуры данных зависят потребление памяти и скорость доступа
к свойствам. Некоторые лисп-системы, например Le_Lisp, даже хранят в символах
специальные кеш-поля, служащие для ускорения доступа к часто используемым
свойствам вроде особенностей форматирования внешнего представления форм,
начинающихся с данного символа.</p>

<!--\indexR{глобальные переменные!как поля символов}-->
<!--\indexR{переменные!глобальные}-->
<!--\indexE{Cval}-->
<!--\indexE{Fval}-->
<p>Раз уж любой символ имеет столько полей, то почему бы не добавить туда ещё одно
для хранения значения одноимённой глобальной переменной? В случае Lisp<sub>2</sub>,
конечно, понадобятся два поля: для переменной и для функции. Ничто не ново под
солнцем, именно так часто и поступают при реализации (например,
<span class="cite">[<a href="z1_bibliography.html#cha80">Cha80</a>,
<a href="z1_bibliography.html#gp88">GP88</a>]</span>), называя эти поля Cval и Fval.
Вдобавок предоставляются функции для доступа к этим полям. В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>
они носят имена <code><span class="var">symbol-value</span></code> и
<code>(<span class="special">setf</span> <span class="var">symbol-value</span>)</code>, а также <code><span class="var">symbol-function</span></code>
и <code>(<span class="special">setf</span> <span class="var">symbol-function</span>)</code>.</p>

<p>Такое решение привлекательно своей стопроцентной гарантией правильной работы.
Каждый символ, используемый в программе, уже был создан <code><span class="func">string-&gt;symbol</span></code>,
которую вызвала <code><span class="func">read</span></code> в процессе чтения программы. Конечно, не всякий символ
используется для хранения значения глобальной переменной, но важно, что всякая
глобальная переменная гарантированно имеет соответствующий символ.</p>

<p>Поэтому достаточно предоставить всего две функции: <code><span class="func">global-value</span></code>
и <code><span class="func">set-global-value!</span></code>, позволяющие просматривать и изменять значения
глобальных переменных, ссылаясь на них по именам. Интерпретатор <code><span class="func">eval</span></code>
сможет воспользоваться глобальными переменными базового языка посредством этих
функций, а проблема корректного расширения глобального окружения пропадает
в принципе — она автомагически решается механизмом доступа к символам.</p>

<p>Покажем на примере интерпретатора из первой главы, как использовать эти функции.
Окружение <code><span class="var">env</span></code> теперь будет содержать только локальные переменные, а
глобальные будут использоваться напрямую — теперь они совпадают с глобальными
переменными того Scheme, на котором написан интерпретатор. Таким образом,
получаем:</p>

<!--\indexC{lookup}-->
<!--\indexC{update"!}-->
<pre>(<span class="special">define</span> (<span class="func">lookup</span> <span class="var">id</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">env</span>)
      (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">id</span> (<span class="func">caar</span> <span class="var">env</span>))
          (<span class="func">cdar</span> <span class="var">env</span>)
          (<span class="func">lookup</span> <span class="var">id</span> (<span class="func">cdr</span> <span class="var">env</span>)) )
      (<span class="func">global-value</span> <span class="var">id</span>) ) )

(<span class="special">define</span> (<span class="func">update!</span> <span class="var">id</span> <span class="var">env</span> <span class="var">value</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">env</span>)
      (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">id</span> (<span class="func">caar</span> <span class="var">env</span>))
          (<span class="special">begin</span> (<span class="func">set-cdr!</span> (<span class="func">car</span> <span class="var">env</span>) <span class="var">value</span>)
                 <span class="var">value</span> )
          (<span class="func">update!</span> <span class="var">id</span> (<span class="func">cdr</span> <span class="var">env</span>) <span class="var">value</span>) )
      (<span class="func">set-global-value!</span> <span class="var">id</span> <span class="var">value</span>) ) )</pre>

<!--\indexCS{global-value}{цена}-->
<!--\indexCS{set-global-value"!}{цена}-->
<p>Данное решение кажется элегантным, но эта элегантность приобретается за
внушительную цену: ведь теперь <em>любая</em> глобальная переменная доступна по
имени. В случае автономного приложения <code><span class="func">global-value</span></code> вынуждает нас включать
в приложение всю без исключения библиотеку функций, так как любое имя может быть
вычислено, а значит, любая функция может понадобиться. Это не особо критично для
среды разработки, так как она затем и существует, чтобы абсолютно всё было под
рукой, но вот с маленькими автономными приложениями такой подход сочетается
плохо. Более того, функция <code><span class="func">set-global-value!</span></code> может изменить значение любой
изменяемой глобальной переменной, что, конечно же, оказывает закономерный эффект
на оптимизации компилятора.</p>

<!--\indexC{symeval}-->
<p>Пару функций <code><span class="func">global-value</span></code> и <code><span class="func">set-global-value!</span></code> можно понимать как
специализированную версию <code><span class="func">eval</span></code> для переменных. Между прочим, в некоторых
старых лисп-системах так оно и было: этот специализированный вычислитель
назывался <code><span class="special">symeval</span></code>. Также можно их считать парой рефлексивных функций,
реифицирующих доступ к глобальным переменным. Написать «<code><span class="var">foo</span></code>», чтобы
получить значение глобальной переменной <code><span class="var">foo</span></code>, — это то же самое, что
неявно вычислить значение формы <code>(<span class="special">global</span> '<span class="var">foo</span>)</code>.</p>


<h4 id="reflection/interpreted-eval/global/sssect:first-class"><span class="wrap"><span class="title">Полноценные окружения</span></span></h4>

<p>Другой вариант решения проблемы окружений состоит в определении <code><span class="func">eval</span></code> как
функции двух переменных: выражения, которое необходимо вычислить, и окружения,
в котором будут проводиться вычисления. Бинарная <code><span class="func">eval</span></code> наивного
интерпретатора вроде как подходит по сигнатуре, но при этом упускается один
важный момент: аргументом функции может быть только значение. Внутри
интерпретатора окружения просто существуют, не являясь при этом полноценными
значениями языка. Следовательно, для реализации этой идеи необходимо определить
операцию реификации окружений, превращающую их в полноценные объекты. Кроме
того, было бы полезным иметь и другие возможности вроде модификации окружений
или хотя бы извлечения значений переменных из них. Наличие соответствующих
функций позволяет реализовать механизм взаимодействия окружений интерпретатора
с окружениями внешней системы. Такой подход поднимает множество специфичных
вопросов, которые мы сейчас и рассмотрим.</p>


<h2 id="reflection/sect:reify-env"><span class="wrap"><span class="seq">8.6.</span><span class="title">Реификация окружений</span></span></h2>

<!--\indexR{контекст вычислений}-->
<!--\indexR{окружение!как тип данных}-->
<!--\indexR{окружение!как полноценный объект}-->
<!--\indexR{полноценные объекты!окружения}-->
<!--\indexR{полноценные объекты!продолжения}-->
<!--\indexR{реификация}-->
<p>Денотационный интерпретатор чётко показал, что контекст вычислений в Scheme
является тройкой из окружения, продолжения и памяти. Отложив память в дальний
угол, сфокусируемся на оставшейся паре. Продолжения уже могут становиться
полноценными объектами языка благодаря <code><span class="func">call/cc</span></code>
или <code><span class="special">bind-exit</span></code>.
Окружениями же возможно пользоваться только неявно. В данном разделе мы
рассмотрим, как превратить их в объекты, допускающие явную программную
манипуляцию.</p>

<!--\indexR{окружение!операции}-->
<!--\indexR{захват привязок}-->
<!--\indexR{привязки (bindings)}-->
<p>Добиться этого можно различными способами, сохраняющими те или иные свойства,
допускающими те или иные операции. Подробную классификацию можно найти
в <span class="cite">[<a href="z1_bibliography.html#ra82">RA82</a>,
<a href="z1_bibliography.html#mr91">MR91</a>]</span>. Существуют
три фундаментальные операции над окружениями:
поиск значения переменной, изменение значения переменной и добавление новой
переменной в окружение. Реификация окружений фактически сводится к захвату
соответствующих привязок переменных к значениям. Привязки при этом становятся
явными, что позволяет реализовать вышеприведённые операции как обычные функции
языка.</p>


<h3 id="reflection/reify-env/ssect:export"><span class="wrap"><span class="seq">8.6.1.</span><span class="title">Специальная форма <code><span class="special">export</span></code></span></span></h3>

<!--\indexR{специальные формы!export@\protect<code><span class="func">export</span></code>}-->
<!--\indexC{export}-->
<!--\indexC{eval/b}-->
<p>Начнём со специальной формы, называемой <code><span class="special">export</span></code>: ей передаётся список имён
переменных, а в ответ она возвращает окружение с соответствующими привязками.
Полученное окружение можно будет впоследствии передать вторым аргументом
в бинарную функцию <code><span class="func">eval</span></code> (впредь будем называть её <code><span class="func">eval/b</span></code>). Например:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">r</span> (<span class="syntax">let</span> ((<span class="var">x</span> <span class="num">3</span>)) (<span class="special">export</span> <span class="var">x</span>))))
  (<span class="func">eval/b</span> '<span class="var">x</span> <span class="var">r</span>) )                    <span class="math"><span class="rel">→</span></span> <span class="num">3</span>

(<span class="syntax">let</span> ((<span class="var">f+r</span> (<span class="syntax">let</span> ((<span class="var">x</span> <span class="num">3</span>))
             (<span class="func">cons</span> (<span class="special">lambda</span> () <span class="var">x</span>) (<span class="special">export</span> <span class="var">x</span>)) )))
  (<span class="func">eval/b</span> '(<span class="special">set!</span> <span class="var">x</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">x</span>)) (<span class="func">cdr</span> <span class="var">f+r</span>))
  ((<span class="func">car</span> <span class="var">f+r</span>)) )                      <span class="math"><span class="rel">→</span></span> <span class="num">4</span>

(<span class="syntax">let</span> ((<span class="var">r</span> (<span class="special">export</span> <span class="var">car</span> <span class="var">cons</span>)))
  (<span class="syntax">let</span> ((<span class="var">car</span> <span class="var">cdr</span>))
    (<span class="func">eval/b</span> '(<span class="func">car</span> (<span class="func">cons</span> <span class="num">1</span> <span class="num">2</span>)) <span class="var">r</span>) ) ) <span class="math"><span class="rel">→</span></span> <span class="num">1</span></pre>

<p>Первый пример показывает, что объект-окружение, содержащий привязку
переменной <code><span class="var">x</span></code>, действительно создаётся, а <code><span class="func">eval/b</span></code> это окружение успешно
переваривает. Второй пример демонстрирует изменяемость переменной <code><span class="var">x</span></code> и
доказывает, что захватывается действительно привязка, так как иным способом
изменить значение свободной переменной замыкания невозможно. Третий пример
показывает, что можно захватывать и глобальные привязки.</p>

<!--\indexR{окружение!операции!создание}-->
<p>Специальная форма <code><span class="special">export</span></code> позволяет жонглировать окружениями по желанию:
захватить окружение в одном месте, а использовать в совершенно другом.
Реализация данной формы нетривиальна, так что её стоит рассмотреть подробнее.
Как обычно, начинаем с добавления новой формы в синтаксический анализатор
<code><span class="func">meaning</span></code>:</p>

<pre>... ((<span class="var">export</span>) (<span class="func">meaning-export</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>)) ...</pre>

<p>Естественно, захваченное окружение должно содержать не только список записей
активаций, но также полный перечень имён и адресов переменных. Та же информация
была нужна <code><span class="special">eval/ce</span></code>, как вы помните.
Поэтому реифицированные окружения будут
представляться объектами с двумя полями: списком записей активаций и списком пар
«имя — адрес», по которому программы смогут разобраться, что где находится.
(См. рисунок <a href="#reflection/reifiy-env/export/pic:reified-env">8.2</a>.)</p>

<!--\indexC{reified-environment}-->
<pre>(<span class="syntax">define-class</span> <span class="class">reified-environment</span> <span class="class">Object</span>
  ( <span class="var">sr</span> <span class="var">r</span> ) )</pre>

<div class="image" id="reflection/reifiy-env/export/pic:reified-env">
<img src="images/png13.png" alt="Изображение структуры реифицированных окружений в виде списка записей активаций" style="width: 5.52in">
<span class="caption">Рис. 8.2. Представление окружений.</span>
</div>

<p>Не особо (пока) углубляясь в детали, будем компилировать форму
<code><span class="special">export</span></code> следующим образом:</p>

<!--\indexC{meaning-export}-->
<!--\indexC{CREATE-1ST-CLASS-ENV}-->
<!--\indexC{create-first-class-environment}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-export</span> <span class="var">n*</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">unless</span> (<span class="func">every?</span> <span class="var">symbol?</span> <span class="var">n*</span>)
          (<span class="func">static-wrong</span> <span class="string">"Incorrect variables"</span> <span class="var">n*</span>) )
  (<span class="func">append</span> (<span class="func">CONSTANT</span> (<span class="func">extract-addresses</span> <span class="var">n*</span> <span class="var">r</span>)) (<span class="func">CREATE-1ST-CLASS-ENV</span>)) )

(<span class="special">define</span> (<span class="func">CREATE-1ST-CLASS-ENV</span>) (<span class="func">list</span> <span class="num">254</span>))

(<span class="syntax">define-instruction</span> (<span class="func">CREATE-1ST-CLASS-ENV</span>) <span class="num">254</span>
  (<span class="func">create-first-class-environment</span> <span class="var">*val*</span> <span class="var">*env*</span>) )

(<span class="special">define</span> (<span class="func">create-first-class-environment</span> <span class="var">r</span> <span class="var">sr</span>)
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">make-reified-environment</span> <span class="var">sr</span> <span class="var">r</span>)) )</pre>

<p>Список пар «имя — адрес» передаётся как цитата через регистр
<code><span class="var">*val*</span></code>, его оттуда забирает новая инструкция
<code><span class="func">CREATE-1ST-CLASS-ENV</span></code>, которая создаст
соответствующий объект.</p>

<!--\indexR{представление!лексических окружений}-->
<!--\indexR{лексическое окружение}-->
<p>Для упрощения вычислений мы немного изменим представление статической части
окружений (значений переменной <code><span class="var">r</span></code>).
Вместо «гирлянд» они теперь будут просто ассоциативными списками, как на
рисунке <a href="#reflection/reifiy-env/export/pic:reified-env">8.2</a>. Это небольшое
изменение, но упрощение <code><span class="func">compute-kind</span></code>
приобретается ценой усложнения <code><span class="func">r-extend*</span></code>:
теперь при каждом расширении окружения необходимо переносить
уже существующие переменные на один уровень глубже.</p>

<!--\indexC{compute-kind}-->
<!--\indexC{r-extend*}-->
<!--\indexC{bury-r}-->
<pre>(<span class="special">define</span> (<span class="func">compute-kind</span> <span class="var">r</span> <span class="var">n</span>)
  (<span class="syntax">or</span> (<span class="syntax">let</span> ((<span class="var">var</span> (<span class="func">assq</span> <span class="var">n</span> <span class="var">r</span>)))
        (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">var</span>) (<span class="func">cadr</span> <span class="var">var</span>)) )
      (<span class="func">global-variable?</span> <span class="var">g.current</span> <span class="var">n</span>)
      (<span class="func">global-variable?</span> <span class="var">g.init</span> <span class="var">n</span>)
      (<span class="func">adjoin-global-variable!</span> <span class="var">n</span>) ) )

(<span class="special">define</span> (<span class="func">r-extend*</span> <span class="var">r</span> <span class="var">n*</span>)
  (<span class="syntax">let</span> ((<span class="var">old-r</span> (<span class="func">bury-r</span> <span class="var">r</span> <span class="num">1</span>)))
    (<span class="syntax">let</span> <span class="func">scan</span> ((<span class="var">n*</span> <span class="var">n*</span>) (<span class="func">i</span> <span class="num">0</span>))
      (<span class="syntax">cond</span> ((<span class="func">pair?</span> <span class="var">n*</span>) (<span class="func">cons</span> (<span class="func">list</span> (<span class="func">car</span> <span class="var">n*</span>) `(<span class="var">local</span> <span class="num">0</span> . ,<span class="var">i</span>))
                              (<span class="func">scan</span> (<span class="func">cdr</span> <span class="var">n*</span>) (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>)) ))
            ((<span class="func">null?</span> <span class="var">n*</span>) <span class="var">old-r</span>)
            (<span class="syntax">else</span> (<span class="func">cons</span> (<span class="func">list</span> <span class="var">n*</span> `(<span class="var">local</span> <span class="num">0</span> . ,<span class="var">i</span>)) <span class="var">old-r</span>)) ) ) ) )

(<span class="special">define</span> (<span class="func">bury-r</span> <span class="var">r</span> <span class="var">offset</span>)
  (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">d</span>)
         (<span class="syntax">let</span> ((<span class="var">name</span> (<span class="func">car</span> <span class="var">d</span>))
               (<span class="var">type</span> (<span class="func">car</span> (<span class="func">cadr</span> <span class="var">d</span>))) )
           (<span class="syntax">case</span> <span class="var">type</span>
             ((<span class="var">local</span> <span class="var">checked-local</span>)
              (<span class="syntax">let*</span> ((<span class="var">addr</span> (<span class="func">cadr</span> <span class="var">d</span>))
                     (<span class="var">i</span> (<span class="func">cadr</span> <span class="var">addr</span>))
                     (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">addr</span>)) )
                `(,<span class="var">name</span> (,<span class="var">type</span> ,(<span class="func">+</span> <span class="var">i</span> <span class="var">offset</span>) . ,<span class="var">j</span>) . ,(<span class="func">cddr</span> <span class="var">d</span>)) ) )
             (<span class="syntax">else</span> <span class="var">d</span>) ) ) )
       <span class="var">r</span> ) )</pre>

<!--\indexCS{eval/ce}{определение через eval/b@определение через <code><span class="func">eval/b</span></code>}-->
<!--\indexC{the-environment}-->
<!--\indexCS{export}{всеобъемлющая}-->
<p>Помимо возможности создания окружения исключительно из упомянутых переменных,
мы также реализуем возможность захвата всего окружения целиком: форма
<code>(<span class="special">export</span>)</code> будет эквивалентна <code>(<span class="special">export</span> <i>переменные</i>...)</code>, где
перечислены все локальные переменные, созданные окружающими форму абстракциями.
Имея форму <code>(<span class="special">export</span>)</code>, часто именуемую
<code>(<span class="func">the-environment</span>)</code>, можно
проэмулировать <code><span class="special">eval/ce</span></code> с помощью
<code><span class="func">eval/b</span></code>:</p>

<blockquote class="equation math"><span class="ord normal"><code>(<span class="special">eval/ce</span> '<span class="math"><span class="ord var">π</span></span>)</code></span><span class="rel">≡</span><span class="ord normal"><code>(<span class="func">eval/b</span> '<span class="math"><span class="ord var">π</span></span> (<span class="special">export</span>))</code></span></blockquote>

<p>Реализовать эту возможность проще простого, так как теперь окружения изначально
имеют необходимую структуру.</p>

<!--\indexC{extract-addresses}-->
<pre>(<span class="special">define</span> (<span class="func">extract-addresses</span> <span class="var">n*</span> <span class="var">r</span>)
  (<span class="special">if</span> (<span class="func">null?</span> <span class="var">n*</span>) <span class="var">r</span>
      (<span class="syntax">let</span> <span class="func">scan</span> ((<span class="var">n*</span> <span class="var">n*</span>))
        (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">n*</span>)
            (<span class="func">cons</span> (<span class="func">list</span> (<span class="func">car</span> <span class="var">n*</span>) (<span class="func">compute-kind</span> <span class="var">r</span> (<span class="func">car</span> <span class="var">n*</span>)))
                  (<span class="func">scan</span> (<span class="func">cdr</span> <span class="var">n*</span>)) )
            <span class="hash">'()</span> ) ) ) )</pre>


<h3 id="reflection/reify-env/ssect:eval/b"><span class="wrap"><span class="seq">8.6.2.</span><span class="title">Функция <code><span class="func">eval/b</span></code></span></span></h3>

<p>На этом сходства <code><span class="func">eval/b</span></code> с <code><span class="special">eval/ce</span></code> не заканчиваются. Они похожи ещё
в том, как получают параметры и возвращают значения. Будет полезным сравнить
рассматриваемую далее реализацию <code><span class="func">eval</span></code> с предыдущими. Функция <code><span class="func">eval/b</span></code>
проверяет аргументы на корректность, после чего передаёт работу знакомой вам
функции <code><span class="func">compile-on-the-fly</span></code>, чтобы она скомпилировала выражение в окружении,
разместила результат в памяти и передала ему управление. Текущее окружение
сохранять не требуется, так как за это отвечает протокол вызова функций.</p>

<!--\indexC{eval/b}-->
<!--\indexC{compile-and-evaluate}-->
<pre>(<span class="syntax">definitial</span> <span class="var">eval/b</span>
  (<span class="syntax">let*</span> ((<span class="var">arity</span> <span class="num">2</span>)
         (<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
    (<span class="func">make-primitive</span>
      (<span class="special">lambda</span> ()
        (<span class="special">if</span> (<span class="func">=</span> <span class="var">arity+1</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>))
            (<span class="syntax">let</span> ((<span class="var">exp</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>))
                  (<span class="var">env</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">1</span>)) )
              (<span class="special">if</span> (<span class="func">program?</span> <span class="var">exp</span>)
                  (<span class="special">if</span> (<span class="func">reified-environment?</span> <span class="var">env</span>)
                      (<span class="func">compile-and-evaluate</span> <span class="var">exp</span> <span class="var">env</span>)
                      (<span class="func">signal-exception</span>
                       <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Not an environment"</span> <span class="var">env</span>) ) )
                  (<span class="func">signal-exception</span>
                   <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Illegal program"</span> <span class="var">exp</span>) ) ) )
            (<span class="func">signal-exception</span>
             <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">eval/b</span>) ) ) ) ) ) )

(<span class="special">define</span> (<span class="func">compile-and-evaluate</span> <span class="var">v</span> <span class="var">env</span>)
  (<span class="syntax">let</span> ((<span class="var">r</span> (<span class="func">reified-environment-r</span> <span class="var">env</span>))
        (<span class="var">sr</span> (<span class="func">reified-environment-sr</span> <span class="var">env</span>)) )
    (<span class="special">set!</span> <span class="var">*env*</span> <span class="var">sr</span>)
    (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">compile-on-the-fly</span> <span class="var">v</span> <span class="var">r</span>)) ) )</pre>


<h3 id="reflection/reify-env/ssect:enrich"><span class="wrap"><span class="seq">8.6.3.</span><span class="title">Расширяем окружения</span></span></h3>

<!--\indexC{letrec}-->
<!--\indexC{enrich}-->
<!--\indexR{окружение!операции!расширение}-->
<p>Так как окружения расширяются на каждом шагу, то будет нелишним дать такую
возможность и пользователям языка. Для этого мы определим функцию <code><span class="func">enrich</span></code>,
принимающую окружение и список добавляемых имён. Возвращаемым значением будет
<em>новое</em> расширенное окружение. <code><span class="func">enrich</span></code> — это чисто функциональный
модификатор, она не изменяет свои аргументы. Рассмотрим пример её использования
— ручную эмуляцию <code><span class="syntax">letrec</span></code>. Сначала захватывается глобальная привязка<a class="footref" href="zz_footnotes.html#foot8.7"><sup>7</sup></a>,
затем к ней добавляются привязки двух локальных переменных
<code><span class="var">odd?</span></code> и
<code><span class="var">even?</span></code>, после
чего определяется пара взаимно рекурсивных функций и, наконец, выполняются
вычисления с их помощью.</p>

<!--\indexC{odd"?}-->
<!--\indexC{even"?}-->
<pre>((<span class="special">lambda</span> (<span class="var">e</span>)
   (<span class="special">set!</span> <span class="var">e</span> (<span class="func">enrich</span> (<span class="special">export</span> <span class="var">*</span>) '<span class="var">even?</span> '<span class="var">odd?</span>))
   (<span class="func">eval/b</span> '(<span class="special">set!</span> <span class="var">even?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#t</span> (<span class="func">odd?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))) <span class="var">e</span>)
   (<span class="func">eval/b</span> '(<span class="special">set!</span> <span class="var">odd?</span> (<span class="special">lambda</span> (<span class="var">n</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) <span class="hash">#f</span> (<span class="func">even?</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))))) <span class="var">e</span>)
   (<span class="func">eval/b</span> '(<span class="func">even?</span> <span class="num">4</span>) <span class="var">e</span>) )
 '<span class="var">ee</span> )                     <span class="math"><span class="rel">→</span></span> <span class="hash">#t</span></pre>

<p>Структура используемых окружений показана на рисунке
<a href="#reflection/reify-env/enrich/pic:subj">8.3</a>. Вначале создаётся запись
активации для хранения новых переменных, затем создаётся окружение, связывающее
имена переменных с новыми адресами. Единственная проблема состоит в том, что
новые переменные объективно существуют, но ещё не имеют значений. С аналогичными
затруднениями при реализации формы <code><span class="syntax">letrec</span></code>
мы уже сталкивались ранее.
<span class="see">[см. раздел <a href="ch02_lisp_1_2_omega.html#lisp1-2-omega/recusion/ssect:uninitialized">2.6.5</a>]</span></p>

<div class="image" id="reflection/reify-env/enrich/pic:subj">
<img src="images/png14.png" alt="Структура расширенного реифицированного окружения" style="width: 5.04in">
<span class="caption">Рис. 8.3. Расширение окружения: <code>(<span class="func">enrich</span> <i>env</i> '<span class="var">x</span> '<span class="var">y</span>)</code>.</span>
</div>

<!--\indexC{checked-local}-->
<!--\indexR{привязки (bindings)!неинициализированные}-->
<p>Решением будет новый тип адресов: <code><span class="var">checked-local</span></code>,
являющийся локальным аналогом <code><span class="var">checked-global</span></code>.
Текущее определение <code><span class="func">enrich</span></code> допускает
существование локальных переменных, которые не имеют значений, что было
невозможным при использовании <code><span class="special">lambda</span></code>.
Поэтому нам потребуется специальная
разновидность привязок для данного случая. Конечно, как вариант можно было бы
разрешить расширять окружения исключительно инициализированными переменными.</p>

<p>Написать определение <code><span class="func">enrich</span></code> теперь не
составит большого труда, пусть оно и получилось весьма объёмным:</p>

<!--\indexC{enrich}-->
<!--\indexC{checked-r-extend*}-->
<pre>(<span class="syntax">definitial</span> <span class="var">enrich</span>
  (<span class="syntax">let</span> ((<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="num">1</span>)))
    (<span class="func">make-primitive</span>
     (<span class="special">lambda</span> ()
       (<span class="special">if</span> (<span class="func">>=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="var">arity+1</span>)
         (<span class="syntax">let</span> ((<span class="var">env</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>)))
           (<span class="func">listify!</span> <span class="var">*val*</span> <span class="num">1</span>)
           (<span class="special">if</span> (<span class="func">reified-environment?</span> <span class="var">env</span>)
             (<span class="syntax">let*</span> ((<span class="var">names</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">1</span>))
                    (<span class="var">len</span> (<span class="func">-</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>)
                            <span class="num">2</span> ))
                    (<span class="var">r</span> (<span class="func">reified-environment-r</span> <span class="var">env</span>))
                    (<span class="var">sr</span> (<span class="func">reified-environment-sr</span> <span class="var">env</span>))
                    (<span class="var">frame</span> (<span class="func">allocate-activation-frame</span>
                            (<span class="func">length</span> <span class="var">names</span>) )) )
               (<span class="func">set-activation-frame-next!</span> <span class="var">frame</span> <span class="var">sr</span>)
               (<span class="syntax">do</span> ((<span class="var">i</span> (<span class="func">-</span> <span class="var">len</span> <span class="num">1</span>) (<span class="func">-</span> <span class="var">i</span> <span class="num">1</span>)))
                   ((<span class="func">&lt;</span> <span class="var">i</span> <span class="num">0</span>))
                 (<span class="func">set-activation-frame-argument!</span> <span class="var">frame</span> <span class="var">i</span>
                                                 <span class="var">undefined-value</span> ) )
               (<span class="syntax">unless</span> (<span class="func">every?</span> <span class="var">symbol?</span> <span class="var">names</span>)
                 (<span class="func">signal-exception</span>
                  <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Incorrect variable names"</span> <span class="var">names</span>) ) )
               (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">make-reified-environment</span> <span class="var">frame</span>
                            (<span class="func">checked-r-extend*</span> <span class="var">r</span> <span class="var">names</span>) ))
               (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )
             (<span class="func">signal-exception</span>
              <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Not an environment"</span> <span class="var">env</span>) ) ) )
         (<span class="func">signal-exception</span>
          <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">enrich</span>) ) ) ) ) ) )

(<span class="special">define</span> (<span class="func">checked-r-extend*</span> <span class="var">r</span> <span class="var">n*</span>)
  (<span class="syntax">let</span> ((<span class="var">old-r</span> (<span class="func">bury-r</span> <span class="var">r</span> <span class="num">1</span>)))
    (<span class="syntax">let</span> <span class="func">scan</span> ((<span class="var">n*</span> <span class="var">n*</span>) (<span class="func">i</span> <span class="num">0</span>))
      (<span class="syntax">cond</span> ((<span class="func">pair?</span> <span class="var">n*</span>) (<span class="func">cons</span> (<span class="func">list</span> (<span class="func">car</span> <span class="var">n*</span>) <span class="var">`</span>(<span class="func">checked-local</span> <span class="num">0</span> . <span class="var">,i</span>))
                              (<span class="func">scan</span> (<span class="func">cdr</span> <span class="var">n*</span>) (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>)) ))
            ((<span class="func">null?</span> <span class="var">n*</span>) <span class="var">old-r</span>) ) ) ) )</pre>

<p>Также необходимо дополнить определения <code><span class="func">meaning-reference</span></code>
и <code><span class="func">meaning-assignment</span></code>, дабы они учитывали новый тип привязок
(<code><span class="var">checked-local</span></code>).</p>

<!--\indexC{meaning-reference}-->
<!--\indexC{meaning-assignment}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-reference</span> <span class="var">n</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">kind</span> (<span class="func">compute-kind</span> <span class="var">r</span> <span class="var">n</span>)))
    (<span class="special">if</span> <span class="var">kind</span> (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">kind</span>)
               ((<span class="var">checked-local</span>)
                (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
                      (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
                  (<span class="func">CHECKED-DEEP-REF</span> <span class="var">i</span> <span class="var">j</span>) ) )
               ((<span class="var">local</span>)
                (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
                      (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
                  (<span class="special">if</span> (<span class="func">=</span> <span class="var">i</span> <span class="num">0</span>)
                      (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="var">j</span>)
                      (<span class="func">DEEP-ARGUMENT-REF</span> <span class="var">i</span> <span class="var">j</span>) ) ) )
               ((<span class="var">global</span>)
                (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cdr</span> <span class="var">kind</span>)))
                  (<span class="func">CHECKED-GLOBAL-REF</span> <span class="var">i</span>) ) )
               ((<span class="var">predefined</span>)
                (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cdr</span> <span class="var">kind</span>)))
                  (<span class="func">PREDEFINED</span> <span class="var">i</span>) ) ) )
        (<span class="func">static-wrong</span> <span class="string">"No such variable"</span> <span class="var">n</span>) ) ) )

(<span class="special">define</span> (<span class="func">meaning-assignment</span> <span class="var">n</span> <span class="var">e</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">m</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r</span> <span class="hash">#f</span>))
        (<span class="var">kind</span> (<span class="func">compute-kind</span> <span class="var">r</span> <span class="var">n</span>)))
    (<span class="special">if</span> <span class="var">kind</span>
        (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">kind</span>)
          ((<span class="var">local</span> <span class="var">checked-local</span>)
           (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
                 (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
             (<span class="special">if</span> (<span class="func">=</span> <span class="var">i</span> <span class="num">0</span>)
                 (<span class="func">SHALLOW-ARGUMENT-SET!</span> <span class="var">j</span> <span class="var">m</span>)
                 (<span class="func">DEEP-ARGUMENT-SET!</span> <span class="var">i</span> <span class="var">j</span> <span class="var">m</span>) ) ) )
          ((<span class="var">global</span>)
           (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cdr</span> <span class="var">kind</span>)))
             (<span class="func">GLOBAL-SET!</span> <span class="var">i</span> <span class="var">m</span>) ) )
          ((<span class="var">predefined</span>)
           (<span class="func">static-wrong</span> <span class="string">"Immutable predefined variable"</span> <span class="var">n</span>) ) )
        (<span class="func">static-wrong</span> <span class="string">"No such variable"</span> <span class="var">n</span>) ) ) )</pre>

<p>И, конечно же, не забываем о новой инструкции <code><span class="func">CHECKED-DEEP-REF</span></code>:</p>

<!--\indexC{CHECKED-DEEP-REF}-->
<pre>(<span class="syntax">define-instruction</span> (<span class="func">CHECKED-DEEP-REF</span> <span class="var">i</span> <span class="var">j</span>) <span class="num">253</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">deep-fetch</span> <span class="var">*env*</span> <span class="var">i</span> <span class="var">j</span>))
  (<span class="syntax">when</span> (<span class="func">eq?</span> <span class="var">*val*</span> <span class="var">undefined-value</span>)
    (<span class="func">signal-exception</span> <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Uninitialized local variable"</span>)) ) )</pre>


<h3 id="reflection/reify-env/ssect:closed"><span class="wrap"><span class="seq">8.6.4.</span><span class="title">Анатомия замыканий</span></span></h3>

<!--\indexC{procedure->environment}-->
<!--\indexC{procedure->definition}-->
<!--\indexR{замыкания (closures)!структура}-->
<p>Некоторые интерпретаторы предоставляют примитивы, позволяющие извлечь из
замыкания хранимое в нём окружение. Кроме функции
<code><span class="func">procedure-&gt;environment</span></code>
также часто имеется и
<code><span class="func">procedure-&gt;definition</span></code>, которая возвращает код
замыкания. Эту пару функций довольно легко реализовать для интерпретатора,
но в случае компилятора задача уже не такая тривиальная и требует несколько
большего объёма памяти. Им необходимо сохранить определения функций (которые
занимают место в памяти), а также явно представить (в памяти) структуру
замкнутых окружений. Более того, функция
<code><span class="func">procedure-&gt;environment</span></code> пагубно
влияет на оптимизацию, так как теперь становится возможным добраться даже до
святая святых — замкнутых свободных переменных, прежде недоступных вообще никому,
кроме собственно замыканий. Функция <code><span class="func">procedure-&gt;environment</span></code>
в этом плане ещё хуже, чем <code><span class="special">export</span></code>: последняя хотя бы
ограничивает негативные последствия явно
указанными переменными.</p>

<!--\indexR{интроспекция}-->
<!--\indexR{трассировка}-->
<p>Функция <code><span class="func">procedure-&gt;definition</span></code> полезна
своими интроспективными возможностями. С её помощью можно создать отладчик, обладающий
полным контролем над отлаживаемыми программами. Например, рассмотрим функцию
<code><span class="func">trace-procedure1</span></code>, которая принимает унарную функцию,
разбирает её на части и собирает из них новую унарную функцию, аналогичную исходной,
но выводящую на экран свой аргумент и результат выполнения.</p>

<pre>(<span class="special">define</span> (<span class="func">trace-procedure1</span> <span class="var">f</span>)
  (<span class="syntax">let*</span> ((<span class="var">env</span> (<span class="func">procedure-&gt;environment</span> <span class="var">f</span>))
         (<span class="var">definition</span> (<span class="func">procedure-&gt;definition</span> <span class="var">f</span>))
         (<span class="var">variable</span> (<span class="func">car</span> (<span class="func">car</span> <span class="var">definition</span>)))
         (<span class="var">body</span> (<span class="func">cddr</span> <span class="var">definition</span>)) )
    (<span class="special">lambda</span> (<span class="var">variable</span>)
      (<span class="func">display</span> (<span class="func">list</span> '<span class="var">entering</span> <span class="var">f</span> '<span class="var">with</span> <span class="var">value</span>))
      (<span class="func">eval/b</span> `(<span class="special">begin</span> (<span class="special">set!</span> ,<span class="var">variable</span> ',<span class="var">value</span>)
                      (<span class="syntax">let</span> ((<span class="var">result</span> (<span class="special">begin</span> . ,<span class="var">body</span>)))
                        (<span class="func">display</span> (<span class="func">list</span> '<span class="var">result</span> '<span class="var">is</span> <span class="var">result</span>))
                        <span class="var">result</span> ) )
              (<span class="func">enrich</span> <span class="var">env</span> <span class="var">variable</span>) ) ) ) )</pre>

<p>Если быть честным, эта программа немного жульничает. Встраиваемая функция вроде
<code><span class="func">car</span></code> её сломает, а код, синтезируемый для <code><span class="func">eval/b</span></code>, не обязательно
является корректным, так как цитирует значение переменной <code><span class="var">value</span></code>, которое
может оказаться нецитируемым (к примеру, замыканием). Тем не менее,
<code><span class="func">trace-procedure1</span></code> является хорошим примером взаимодействия интроспекции,
полноценных окружений и динамических вычислений.</p>

<p>Давайте рассмотрим пример реализации данных функций, чтобы вы лучше представляли
себе их стоимость. Функция <code><span class="func">procedure-&gt;definition</span></code> более проста: ей надо
всего лишь связать замыкание с его определением, то есть с цитатой
соответствующей абстракции. Проблема состоит в том, куда поместить эту цитату,
так как несколько замыканий могут иметь одинаковое определение. Вспомним, что
замыкания ассоциируются с кодом, хранимым по определённому адресу. Все замыкания
данной абстракции ссылаются на один и тот же код, так что цитируемое определение
разумно разместить где-то поблизости. Подобное перемежение кода и данных хорошо
известно программистам на ассемблере. Иллюстрация идеи приведена на
рисунке <a href="#reflection/reify-env/closed/pic:subj">8.4</a>.</p>

<div class="image" id="reflection/reify-env/closed/pic:subj">
<img src="images/png15.png" alt="Расположение в памяти частей реифицированной рефлексивной абстракции" style="width: 4.48in">
<span class="caption">Рис. 8.4. Рефлексивная абстракция.</span>
</div>

<p>Реализация данной идеи тривиальна<a class="footref" href="zz_footnotes.html#foot8.8"><sup>8</sup></a>. Для нужд <code><span class="func">procedure-&gt;environment</span></code> и
<code><span class="func">procedure-&gt;definition</span></code> в кодогенераторы абстракций
необходимо передавать определения соответствующих функций и их окружения.
<i>n</i>-арный вариант данной функции легко написать по аналогии:</p>

<!--\indexC{meaning-fix-abstraction}-->
<!--\indexC{REFLECTIVE-FIX-CLOSURE}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-fix-abstraction</span> <span class="var">n*</span> <span class="var">e+</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let*</span> ((<span class="var">arity</span> (<span class="func">length</span> <span class="var">n*</span>))
         (<span class="var">r2</span> (<span class="func">r-extend*</span> <span class="var">r</span> <span class="var">n*</span>))
         (<span class="var">m+</span> (<span class="func">meaning-sequence</span> <span class="var">e+</span> <span class="var">r2</span> <span class="hash">#t</span>)) )
    (<span class="func">REFLECTIVE-FIX-CLOSURE</span> <span class="var">m+</span> <span class="var">arity</span>
      `(<span class="special">lambda</span> ,<span class="var">n*</span> . ,<span class="var">e+</span>) <span class="var">r</span> ) ) )

(<span class="special">define</span> (<span class="func">REFLECTIVE-FIX-CLOSURE</span> <span class="var">m+</span> <span class="var">arity</span> <span class="var">definition</span> <span class="var">r</span>)
  (<span class="syntax">let*</span> ((<span class="var">the-function</span> (<span class="func">append</span> (<span class="func">ARITY=?</span> (<span class="func">+</span> <span class="var">arity</span> <span class="num">1</span>)) (<span class="func">EXTEND-ENV</span>)
                               <span class="var">m+</span> (<span class="func">RETURN</span>) ))
         (<span class="var">the-env</span> (<span class="func">append</span> (<span class="func">EXPLICIT-CONSTANT</span> <span class="var">definition</span>)
                          (<span class="func">EXPLICIT-CONSTANT</span> <span class="var">r</span>) ))
         (<span class="var">the-goto</span> (<span class="func">GOTO</span> (<span class="func">+</span> (<span class="func">length</span> <span class="var">the-env</span>) (<span class="func">length</span> <span class="var">the-function</span>)))) )
    (<span class="func">append</span> (<span class="func">CREATE-CLOSURE</span> (<span class="func">+</span> (<span class="func">length</span> <span class="var">the-goto</span>) (<span class="func">length</span> <span class="var">the-env</span>)))
            <span class="var">the-goto</span> <span class="var">the-env</span> <span class="var">the-function</span> ) ) )</pre>

<p>Функция <code><span class="func">procedure-&gt;definition</span></code> извлекает определение
замыкания, расположенное на две инструкции позади его кода.</p>

<!--\indexC{procedure->definition}-->
<pre>(<span class="syntax">definitial</span> <span class="var">procedure-&gt;definition</span>
  (<span class="syntax">let*</span> ((<span class="var">arity</span> <span class="num">1</span>)
         (<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
    (<span class="func">make-primitive</span>
     (<span class="special">lambda</span> ()
       (<span class="special">if</span> (<span class="func">>=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="var">arity+1</span>)
           (<span class="syntax">let</span> ((<span class="var">proc</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>)))
             (<span class="special">if</span> (<span class="func">closure?</span> <span class="var">proc</span>)
                 (<span class="syntax">let</span> ((<span class="var">pc</span> (<span class="func">closure-code</span> <span class="var">proc</span>)))
                   (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">vector-ref</span> <span class="var">*constants*</span>
                                (<span class="func">vector-ref</span> <span class="var">*code*</span> (<span class="func">-</span> <span class="var">pc</span> <span class="num">2</span>)) ))
                   (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )
                 (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Not a procedure"</span> <span class="var">proc</span>)) ) )
           (<span class="func">signal-exception</span> <span class="hash">#t</span>
            (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">procedure-&gt;definition</span>) ) ) ) ) ) )</pre>

<p>Функция <code><span class="func">procedure-&gt;environment</span></code> извлекает замкнутое окружение и реифицирует
его, устанавливая в нём соответствия между именами переменных и их адресами.
Таблица символов хранится на одну инструкцию позади тела замыкания.</p>

<!--\indexC{procedure->environment}-->
<pre>(<span class="syntax">definitial</span> <span class="var">procedure-&gt;environment</span>
  (<span class="syntax">let*</span> ((<span class="var">arity</span> <span class="num">1</span>)
         (<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
    (<span class="func">make-primitive</span>
     (<span class="special">lambda</span> ()
       (<span class="special">if</span> (<span class="func">>=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="var">arity+1</span>)
           (<span class="syntax">let</span> ((<span class="func">proc</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>)))
             (<span class="special">if</span> (<span class="func">closure?</span> <span class="var">proc</span>)
                 (<span class="syntax">let*</span> ((<span class="var">pc</span> (<span class="func">closure-code</span> <span class="var">proc</span>))
                        (<span class="var">r</span> (<span class="func">vector-ref</span> <span class="var">*constants*</span>
                            (<span class="func">vector-ref</span> <span class="var">*code*</span> (<span class="func">-</span> <span class="var">pc</span> <span class="num">1</span>)) )) )
                   (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">make-reified-environment</span>
                                (<span class="func">closure-closed-environment</span> <span class="var">proc</span>)
                                <span class="var">r</span> ))
                   (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )
                 (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Not a procedure"</span> <span class="var">proc</span>)) ) )
           (<span class="func">signal-exception</span> <span class="hash">#t</span>
            (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">procedure-&gt;environment</span>) ) ) ) ) ) )</pre>

<p>Вкратце, <code><span class="func">procedure-&gt;definition</span></code> и <code><span class="func">procedure-&gt;environment</span></code> позволяют
программам осознавать свой собственный код. Также их возможности полезны для
написания интроспективных отладочных инструментов. Однако, нельзя забывать
о довольно высокой стоимости использования данных функций ввиду существенного
объёма сохраняемой ими информации. Более того, они отличаются полным
отсутствием такта: сохраняют и выставляют напоказ всё, что видят. Никакого
проприетарного кода, никакого сокрытия реализаций структур данных, и никаких
локальных оптимизаций, так как в подобных условиях неизменяемость и
недоступность чего-либо не гарантируется.</p>

<!--\indexR{рефлексивные абстракции}-->
<!--\indexR{абстракция!рефлексивная}-->
<p>Часть недостатков этих функций исправляется введением дополнительной
специальной формы, скажем, <code><span class="special">reflective-lambda</span></code>,
имеющей следующий синтаксис:</p>

<!--\indexC{reflective-lambda}-->
<pre>(<span class="special">reflective-lambda</span> (<i>переменные</i>) (<i>экспортируемые переменные</i>)
  <i>тело</i> )</pre>

<p>Подобно <code><span class="special">lambda</span></code>-абстракциям, которые она обобщает, первым аргументом ей
передаются локальные переменные, а в конце идёт тело функции, но между ними
расположен список экспортируемых переменных. Лишь перечисленные свободные
переменные будут видны для внешнего мира, если извлечь сохранённое окружение
из подобного замыкания. Обычной абстракции <code>(<span class="special">lambda</span> (<i>переменные</i>)
<i>тело</i>)</code> соответствует новая <code>(<span class="special">reflective-lambda</span> (<i>переменные</i>)
() <i>тело</i>)</code>, которая не экспортирует ничего. Такая специальная форма
позволяет контролировать доступ к привязкам, скрывая при необходимости
то, что должно быть личным.</p>

<p>Наконец, остаётся ещё один щекотливый вопрос, поднимаемый чрезмерно любопытной
функцией <code><span class="func">procedure-&gt;environment</span></code>. Какое именно окружение замыкает в себе
следующая абстракция?</p>

<pre>(<span class="syntax">let</span> ((<span class="var">x</span> <span class="num">1</span>) (<span class="var">y</span> <span class="num">2</span>))
  (<span class="special">lambda</span> (<span class="var">z</span>) <span class="var">x</span>) )</pre>

<p>Это окружение однозначно содержит <code><span class="var">x</span></code>, так как она является свободной в теле
абстракции. Но захватывается ли <code><span class="var">y</span></code>, которая тоже присутствует в лексическом
окружении? Для рассмотренной реализации это так, потому что функция
<code><span class="func">procedure-&gt;environment</span></code> вынуждена соблюдать контракт, который подразумевает,
что с помощью полученного окружения возможно вычислить любое выражение (в том
числе использующее переменную <code><span class="var">y</span></code>), как будто бы оно вычислялось внутри
соответствующего замыкания. Поэтому <code><span class="func">procedure-&gt;environment</span></code> и возвращает
целиком и полностью окружение, используемое при создании замыкания.</p>


<h3 id="reflection/reify-env/ssect:import"><span class="wrap"><span class="seq">8.6.5.</span><span class="title">Специальная форма <code><span class="special">import</span></code></span></span></h3>

<!--\indexR{динамические вычисления!неизменяемый код}-->
<p>Часто форма, передаваемая динамическому вычислителю, является по сути
статической. Например, такая ситуация наблюдается в функции
<code><span class="func">trace-procedure1</span></code>. Вместо полной компиляции на лету здесь бы отлично подошла
предкомпиляция вычисляемой формы, оставляющая динамическим только выбор
окружения, в котором будут проходить вычисления. Введём для этих целей новую
специальную форму <code><span class="special">import</span></code> со следующим синтаксисом:</p>


<!--\indexR{специальные формы!import@\protect<code><span class="func">import</span></code>}-->
<!--\indexC{import}-->
<pre>(<span class="special">import</span> (<i>переменные</i>...) <i>окружение</i>
  <i>формы</i>... )</pre>

<p><i>Формы</i>, составляющие тело <code><span class="special">import</span></code>, вычисляются в специальном окружении.
Свободные <i>переменные</i>, присутствующие<a class="footref" href="zz_footnotes.html#foot8.9"><sup>9</sup></a> в переданном списке,
берутся из <i>окружения</i>, а остальные, как обычно, извлекаются из лексического
окружения самой формы <code><span class="special">import</span></code>. Список заменяемых переменных статический,
их имена не могут быть вычислены; сначала вычисляется <i>окружение</i>, затем
<i>формы</i>.</p>


<!--\indexR{представление!обобщённых функций}-->
<!--\indexR{замыкания (closures)!и объекты}-->
<p>Рассмотрим пример её использования, вдохновлённый <span class="sc">M<span class="c">eroonet</span></span>.
Там возникли затруднения с представлением обобщённых функций, которые одновременно должны
быть и функциями, и объектами. Если разрешить доступ к замкнутым свободным
переменным извне, то замыкания можно считать объектами, полями которых являются
свободные переменные. На этой идее основывается<a class="footref" href="zz_footnotes.html#foot8.10"><sup>10</sup></a> отождествление замыканий с объектами. В <span class="sc">M<span class="c">eroonet</span></span> для
добавления метода обобщённой функции его необходимо разместить по определённому
индексу в векторе методов. Если обобщённая функция замыкает в себе этот вектор
под именем <code><span class="var">methods</span></code>,
то данное действие можно записать прямо:</p>

<!--\indexC{add-method"!}-->
<pre>(<span class="special">define</span> (<span class="func">add-method!</span> <span class="var">generic</span> <span class="var">class</span> <span class="var">method</span>)
  (<span class="special">import</span> (<span class="var">methods</span>) (<span class="func">procedure-&gt;environment</span> <span class="var">generic</span>)
    (<span class="func">vector-set!</span> <span class="var">methods</span> (<span class="func">Class-number</span> <span class="var">class</span>) <span class="var">method</span>) ) )</pre>

<!--\indexR{квазистатические привязки}-->
<!--\indexR{привязки (bindings)!квазистатические}-->
<!--\indexR{связывание!квазистатическое}-->
<!--\indexR{модули!как полноценные объекты}-->
<!--\indexR{полноценные объекты!модули}-->
<p>Здесь отлично видно преимущество <code><span class="special">import</span></code> над <code><span class="func">eval/b</span></code>. Переменные
<code><span class="var">class</span></code> и <code><span class="var">method</span></code> внутри функции известны статически, поэтому компилятор
не может сразу же подставить лишь адрес переменной <code><span class="var">methods</span></code> — он станет
известным только после вычисления второго аргумента <code><span class="special">import</span></code>. В итоге мы
получаем динамическую компиляцию наподобие <code><span class="func">eval/b</span></code>, но выполняем статически
большую часть работы: собственно синтез исполнимого кода. Фактически, форме
<code><span class="special">import</span></code> остаётся только связать определённые переменные с вычисленными
значениями. Подобное связывание в <span class="cite">[<a href="z1_bibliography.html#lf93">LF93</a>]</span> и <span class="cite">[<a href="z1_bibliography.html#nq89">NQ89</a>]</span> называется
<em class="term">квазистатическим</em>. Помимо этого, само слово <code><span class="special">import</span></code> намекает на
тесную связь с <code><span class="special">export</span></code>: одна форма производит окружения, которыми
пользуется другая. С их помощью уже можно соорудить простую, но полноценную
(в обоих смыслах) систему модулей.</p>

<p>Итак, как же реализуется специальная форма <code><span class="special">import</span></code>? Прежде всего,
конечно, в синтаксическом анализаторе <code><span class="func">meaning</span></code> появляется новая строка:</p>

<pre>...
((<span class="var">import</span>) (<span class="func">meaning-import</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) (<span class="func">cdddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>)) ...</pre>

<!--\indexR{плавающие переменные}-->
<!--\indexR{переменные!плавающие}-->
<!--\indexR{привязки (bindings)!плавающие}-->
<p>Генерируемый байт-код сохраняет список несвязанных переменных (назовём их
<em class="term">плавающими</em>) в стеке, вычисляет переданное окружение и сохраняет результат
в <code><span class="var">*val*</span></code>, после чего выполняет новую инструкцию <code><span class="func">CREATE-PSEUDO-ENV</span></code> и
передаёт управление телу формы <code><span class="special">import</span></code>, принимая во внимание <code><span class="var">tail?</span></code>.</p>

<!--\indexC{meaning-import}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-import</span> <span class="var">n*</span> <span class="var">e</span> <span class="var">e+</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let*</span> ((<span class="var">m</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r</span> <span class="hash">#f</span>))
         (<span class="var">r2</span> (<span class="func">shadow-extend*</span> <span class="var">r</span> <span class="var">n*</span>))
         (<span class="var">m+</span> (<span class="func">meaning-sequence</span> <span class="var">e+</span> <span class="var">r2</span> <span class="hash">#f</span>)) )
    (<span class="func">append</span> (<span class="func">CONSTANT</span> <span class="var">n*</span>) (<span class="func">PUSH-VALUE</span>)
            <span class="var">m</span> (<span class="func">CREATE-PSEUDO-ENV</span>)
            (<span class="special">if</span> <span class="var">tail?</span> <span class="var">m+</span> (<span class="func">append</span> <span class="var">m+</span> (<span class="func">UNLINK-ENV</span>))) ) ) )</pre>

<!--\indexR{записи активации!псевдозаписи активации}-->
<!--\indexR{псевдозаписи активации}-->
<p>Перед вычислением тела специальной формы <code><span class="special">import</span></code> текущее окружение
расширяется псевдозаписью активации (объектом класса
<code><span class="class">pseudo-activation-frame</span></code>), хранящей информацию о плавающих переменных.
Она может свободно связываться в цепочку с другими записями активаций, но внутри
себя содержит не значения переменных, а их адреса вместе с окружением,
относительно которого они вычислены. При создании псевдозаписи активации для
выяснения адресов переменных используется функция <code><span class="func">compute-kind</span></code>.</p>

<!--\indexC{CREATE-PSEUDO-ENV}-->
<!--\indexC{pseudo-activation-frame}-->
<!--\indexC{create-pseudo-environment}-->
<pre>(<span class="syntax">define-instruction</span> (<span class="func">CREATE-PSEUDO-ENV</span>) <span class="num">252</span>
  (<span class="func">create-pseudo-environment</span> (<span class="func">stack-pop</span>) <span class="var">*val*</span> <span class="var">*env*</span>) )

(<span class="syntax">define-class</span> <span class="class">pseudo-activation-frame</span> <span class="class">environment</span>
  ( <span class="var">sr</span> (<span class="syntax">*</span> <span class="var">address</span>) ) )

(<span class="special">define</span> (<span class="func">create-pseudo-environment</span> <span class="var">n*</span> <span class="var">env</span> <span class="var">sr</span>)
  (<span class="syntax">unless</span> (<span class="func">reified-environment?</span> <span class="var">env</span>)
    (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Not an environment"</span> <span class="var">env</span>)) )
  (<span class="syntax">let*</span> ((<span class="var">len</span> (<span class="func">length</span> <span class="var">n*</span>))
         (<span class="var">frame</span> (<span class="func">allocate-pseudo-activation-frame</span> <span class="var">len</span>)) )
    (<span class="syntax">let</span> <span class="func">setup</span> ((<span class="var">n*</span> <span class="var">n*</span>) (<span class="var">i</span> <span class="num">0</span>))
      (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">n*</span>)
        (<span class="func">set-pseudo-activation-frame-address!</span>
         <span class="var">frame</span> <span class="var">i</span> (<span class="func">compute-kind</span> (<span class="func">reified-environment-r</span> <span class="var">env</span>) (<span class="func">car</span> <span class="var">n*</span>)) )
        (<span class="func">setup</span> (<span class="func">cdr</span> <span class="var">n*</span>) (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>)) ) )
    (<span class="func">set-pseudo-activation-frame-sr!</span> <span class="var">frame</span>
     (<span class="func">reified-environment-sr</span> <span class="var">env</span>) )
    (<span class="func">set-pseudo-activation-frame-next!</span> <span class="var">frame</span> <span class="var">sr</span>)
    (<span class="special">set!</span> <span class="var">*env*</span> <span class="var">frame</span>) ) )</pre>

<p>Тело специальной формы <code><span class="special">import</span></code> следует компилировать с учётом новых
плавающих переменных. Они помещаются в окружение компиляции <code><span class="var">r</span></code> с помощью
функции <code><span class="func">shadow-extend*</span></code>. Как известно, есть только одна проблема, которую
нельзя решить введением дополнительного уровня косвенности. Поэтому значения
плавающих переменных определяются с помощью косвенной адресации: сначала из
псевдозаписи активации извлекается адрес, а затем в соответствующем
окружении ищется необходимое значение. На
рисунке <a href="#reflection/reify-env/import/pic:env-struct">8.5</a> приведена иллюстрация
структуры окружений для следующей программы:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">x</span> <span class="num">11</span>))
  (<span class="syntax">let</span> ((<span class="var">z</span> <span class="num">22</span>)
        (<span class="var">env</span> (<span class="syntax">let</span> ((<span class="var">z</span> <span class="num">33</span>)) (<span class="special">export</span>))) )
    (<span class="special">import</span> (<span class="var">x</span> <span class="var">y</span>) <span class="var">env</span>
      (<span class="func">list</span> (<span class="special">set!</span> <span class="var">x</span> <span class="var">y</span>) <span class="var">z</span>) ) ) )</pre>

<div class="image" id="reflection/reify-env/import/pic:env-struct">
<img src="images/png16.png" alt="Структура окружений и псевдоокружений после исполнения специальной формы import" style="width: 5.72in">
<span class="caption">Рис. 8.5. Принцип работы <code><span class="special">import</span></code>.</span>
</div>

<p>Плавающие переменные должны компилироваться по-своему, так что они помечаются
для компилятора специальной функцией <code><span class="func">shadow-extend*</span></code>:</p>

<!--\indexC{shadow-extend*}-->
<pre>(<span class="special">define</span> (<span class="func">shadow-extend*</span> <span class="var">r</span> <span class="var">n*</span>)
  (<span class="syntax">let</span> <span class="func">enum</span> ((<span class="var">n*</span> <span class="var">n*</span>) (<span class="var">j</span> <span class="num">0</span>))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">n*</span>)
        (<span class="func">cons</span> (<span class="func">list</span> (<span class="func">car</span> <span class="var">n*</span>) `(<span class="var">shadowable</span> <span class="num">0</span> . ,<span class="var">j</span>))
              (<span class="func">enum</span> (<span class="func">cdr</span> <span class="var">n*</span>) (<span class="func">+</span> <span class="var">j</span> <span class="num">1</span>)) )
        (<span class="func">bury-r</span> <span class="var">r</span> <span class="num">1</span>) ) ) )</pre>

<p>Также необходимо дополнить определения <code><span class="func">meaning-reference</span></code> и
<code><span class="func">meaning-assignment</span></code> предобработкой нового типа переменных. Помимо этого ещё
потребуется ввести две новые инструкции: <code><span class="func">SHADOW-REF</span></code> и <code><span class="func">SHADOW-SET!</span></code>,
отвечающие за взаимодействие с подобными переменными на машинном уровне.</p>

<!--\indexC{meaning-reference}-->
<!--\indexC{SHADOW-REF}-->
<!--\indexC{shadowable-fetch}-->
<!--\indexC{variable-value-lookup}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-reference</span> <span class="var">n</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">kind</span> (<span class="func">compute-kind</span> <span class="var">r</span> <span class="var">n</span>)))
    (<span class="special">if</span> <span class="var">kind</span>
        (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">kind</span>)
          ((<span class="var">checked-local</span>)
           (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
                 (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
             (<span class="func">CHECKED-DEEP-REF</span> <span class="var">i</span> <span class="var">j</span>) ) )
          ((<span class="var">local</span>)
           (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
                 (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
             (<span class="special">if</span> (<span class="func">=</span> <span class="var">i</span> <span class="num">0</span>)
                 (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="var">j</span>)
                 (<span class="func">DEEP-ARGUMENT-REF</span> <span class="var">i</span> <span class="var">j</span>) ) ) )
          ((<span class="var">shadowable</span>)
           (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
                 (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
             (<span class="func">SHADOW-REF</span> <span class="var">i</span> <span class="var">j</span>) ) )
          ((<span class="var">global</span>)
           (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cdr</span> <span class="var">kind</span>)))
             (<span class="func">CHECKED-GLOBAL-REF</span> <span class="var">i</span>) ) )
          ((<span class="var">predefined</span>)
           (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cdr</span> <span class="var">kind</span>)))
             (<span class="func">PREDEFINED</span> <span class="var">i</span>) ) ) )
        (<span class="func">static-wrong</span> <span class="string">"No such variable"</span> <span class="var">n</span>) ) ) )

(<span class="syntax">define-instruction</span> (<span class="func">SHADOW-REF</span> <span class="var">i</span> <span class="var">j</span>) <span class="num">231</span>
  (<span class="func">shadowable-fetch</span> <span class="var">*env*</span> <span class="var">i</span> <span class="var">j</span>) )

(<span class="special">define</span> (<span class="func">shadowable-fetch</span> <span class="var">sr</span> <span class="var">i</span> <span class="var">j</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">i</span> <span class="num">0</span>)
      (<span class="syntax">let</span> ((<span class="var">kind</span> (<span class="func">pseudo-activation-frame-address</span> <span class="var">sr</span> <span class="var">j</span>))
            (<span class="var">sr</span> (<span class="func">pseudo-activation-frame-sr</span> <span class="var">sr</span>)) )
        (<span class="func">variable-value-lookup</span> <span class="var">kind</span> <span class="var">sr</span>) )
      (<span class="func">shadowable-fetch</span> (<span class="func">environment-next</span> <span class="var">sr</span>) (<span class="func">-</span> <span class="var">i</span> <span class="num">1</span>) <span class="var">j</span>) ) )

(<span class="special">define</span> (<span class="func">variable-value-lookup</span> <span class="var">kind</span> <span class="var">sr</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">kind</span>)
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">kind</span>)
        ((<span class="var">checked-local</span>)
         (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
               (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
           (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">deep-fetch</span> <span class="var">sr</span> <span class="var">i</span> <span class="var">j</span>))
           (<span class="syntax">when</span> (<span class="func">eq?</span> <span class="var">*val*</span> <span class="var">undefined-value</span>)
             (<span class="func">signal-exception</span> <span class="hash">#t</span>
               (<span class="func">list</span> <span class="string">"Uninitialized local variable"</span>) ) ) ) )
        ((<span class="var">local</span>)
         (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
               (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
           (<span class="special">set!</span> <span class="var">*val*</span>
            (<span class="special">if</span> (<span class="func">=</span> <span class="var">i</span> <span class="num">0</span>)
                (<span class="func">activation-frame-argument</span> <span class="var">sr</span> <span class="var">j</span>)
                (<span class="func">deep-fetch</span> <span class="var">sr</span> <span class="var">i</span> <span class="var">j</span>) ) ) ) )
        ((<span class="var">shadowable</span>)
         (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cadr</span> <span class="var">kind</span>))
               (<span class="var">j</span> (<span class="func">cddr</span> <span class="var">kind</span>)) )
           (<span class="func">shadowable-fetch</span> <span class="var">sr</span> <span class="var">i</span> <span class="var">j</span>) ) )
        ((<span class="var">global</span>)
         (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cdr</span> <span class="var">kind</span>)))
           (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">global-fetch</span> <span class="var">i</span>))
           (<span class="syntax">when</span> (<span class="func">eq?</span> <span class="var">*val*</span> <span class="var">undefined-value</span>)
             (<span class="func">signal-exception</span> <span class="hash">#t</span>
               (<span class="func">list</span> <span class="string">"Uninitialized global variable"</span>) ) ) ) )
        ((<span class="var">predefined</span>)
         (<span class="syntax">let</span> ((<span class="var">i</span> (<span class="func">cdr</span> <span class="var">kind</span>)))
           (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">predefined-fetch</span> <span class="var">i</span>)) ) ) )
      (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"No such variable"</span>)) ) )</pre>

<!--\indexCS{import}{как макрос}-->
<p>Функция <code><span class="func">shadowable-fetch</span></code> использует статически известный промежуточный
адрес, чтобы получить динамический адрес, по которому фактически располагается
искомая переменная. При этом необходимо различать все возможные типы фактических
адресов, а именно: <code><span class="var">local</span></code> и <code><span class="var">checked-local</span></code>, <code><span class="var">global</span></code> и
<code><span class="var">predefined</span></code>, и даже <code><span class="var">shadowable</span></code>, ведь это вполне возможный вариант.
Функция <code><span class="func">variable-value-lookup</span></code> выполняет эту работу. В некотором смысле
<code><span class="special">import</span></code> можно понимать как макрос, преобразующий ссылки на плавающие
переменные в вызовы <code><span class="func">eval/b</span></code>. Например, форма <code>(<span class="special">import</span> (<span class="var">x</span> <span class="var">y</span>) <span class="var">env</span> (<span class="func">list</span>
(<span class="special">set!</span> <span class="var">x</span> <span class="var">y</span>) <span class="var">z</span>))</code> из предыдущего примера эквивалентна<a class="footref" href="zz_footnotes.html#foot8.11"><sup>11</sup></a> следующей:</p>

<pre>(<span class="func">list</span> ((<span class="func">eval/b</span> '(<span class="special">lambda</span> (<span class="var">v</span>) (<span class="special">set!</span> <span class="var">x</span> <span class="var">v</span>)) <span class="var">env</span>)
       (<span class="func">eval/b</span> '<span class="var">y</span> <span class="var">env</span>) )
      <span class="var">z</span> )</pre>

<p>Подведём некоторый итог, ещё раз взглянув на все типы привязок, с которыми мы
встречались.</p>

<!--\indexR{лексическое связывание}-->
<!--\indexR{связывание!лексическое}-->
<!--\indexR{привязки (bindings)!лексические}-->
<!--\indexC{lambda}-->
<p>Форма <code><span class="special">lambda</span></code> создаёт лексические привязки — коробки для хранения
значений переменных. Коробки имеют имена, позволяющие ссылаться на них. Время жизни
коробок не ограничено: они исчезают лишь тогда, когда никто больше не сможет
ими воспользоваться. Область видимости имён коробок ограничивается телом
<code><span class="special">lambda</span></code>-формы, которая их создала.</p>

<!--\indexR{динамическое связывание}-->
<!--\indexR{привязки (bindings)!динамические}-->
<!--\indexR{связывание!динамическое}-->
<!--\indexC{dynamic-let}-->
<!--\indexC{dynamic-set"!}-->
<p>Форма <code><span class="special">dynamic-let</span></code> создаёт динамические привязки —
связи имён со значениями<a class="footref" href="zz_footnotes.html#foot8.12"><sup>12</sup></a>,
устанавливая их на время определённых вычислений. Область
видимости данных привязок не ограничена, однако они перестают существовать
с окончанием соответствующих вычислений.</p>

<!--\indexR{привязки (bindings)!квазистатические}-->
<!--\indexR{квазистатические привязки}-->
<!--\indexR{связывание!квазистатическое}-->
<!--\indexC{reflective-lambda}-->
<!--\indexR{альфа@$\alpha$-конверсия}-->
<p>Квазистатические привязки являются альтернативными именами уже существующих
привязок. Подобная множественность имён несовместима с <span class="math"><span class="ord var">α</span></span>-конверсией<a class="footref" href="zz_footnotes.html#foot8.tr-1"><sup>*</sup></a>. Почему? Потому что даже ограниченные способы<a class="footref" href="zz_footnotes.html#foot8.13"><sup>13</sup></a> реификации окружений,
не такие всеобъемлющие, как <code><span class="func">procedure-&gt;environment</span></code>,
дают возможность пользоваться привязками в совершенно произвольных местах, без учёта их
нормальной области видимости и изначального имени.</p>


<h3 id="reflection/reify-env/ssect:simplified"><span class="wrap"><span class="seq">8.6.6.</span><span class="title">Упрощённый доступ к окружениям</span></span></h3>

<!--\indexR{окружение!реификация}-->
<!--\indexR{окружение!операции!чтение}-->
<!--\indexR{реификация}-->
<p>Предыдущие разделы показали, что реифицированные окружения отлично сочетаются
с явными вычислениями. Единственным исключением, которое пока не удалось
выразить с их помощью, остаются программы, использующие глобальное окружение.
Раз уж сами по себе явные объекты-окружения не способны унифицировать обращения
к переменным, то попробуем зайти с другой стороны: обобщим функции
<code><span class="func">global-value</span></code> и <code><span class="func">set-global-value!</span></code> на случай любых переменных, получая
<code><span class="func">variable-value</span></code>, <code><span class="func">set-variable-value!</span></code> и <code><span class="func">variable-defined?</span></code>.</p>


<!--\indexC{variable-value}-->
<!--\indexC{set-variable-value"!}-->
<!--\indexC{variable-defined"?}-->
<p>Функция <code><span class="func">variable-value</span></code> используется для поиска значения переменной
в переданном ей окружении; <code><span class="func">set-variable-value!</span></code> изменяет данное значение;
<code><span class="func">variable-defined?</span></code> проверяет наличие переменной в окружении. Все они
извлекают фактический адрес искомой переменной аналогично <code><span class="func">shadowable-fetch</span></code>:
в обход функции <code><span class="func">compute-kind</span></code>, так как она создаёт глобальные переменные
на лету, если не может их найти в локальном окружении. Определение
<code><span class="func">set-variable-value!</span></code> не приводится для краткости, но его довольно легко
восстановить по имеющимся.</p>

<pre>(<span class="syntax">definitial</span> <span class="var">variable-value</span>
  (<span class="syntax">let*</span> ((<span class="var">arity</span> <span class="num">2</span>)
         (<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
    (<span class="func">make-primitive</span>
     (<span class="special">lambda</span> ()
       (<span class="special">if</span> (<span class="func">=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="var">arity+1</span>)
           (<span class="syntax">let</span> ((<span class="var">name</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>))
                 (<span class="var">env</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">1</span>)) )
             (<span class="special">if</span> (<span class="func">reified-environment?</span> <span class="var">env</span>)
                 (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">name</span>)
                     (<span class="syntax">let*</span> ((<span class="var">r</span> (<span class="func">reified-environment-r</span> <span class="var">env</span>))
                            (<span class="var">sr</span> (<span class="func">reified-environment-sr</span> <span class="var">env</span>))
                            (<span class="var">kind</span>
                             (<span class="syntax">or</span> (<span class="syntax">let</span> ((<span class="var">var</span> (<span class="func">assq</span> <span class="var">name</span> <span class="var">r</span>)))
                                   (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">var</span>) (<span class="func">cadr</span> <span class="var">var</span>)) )
                                 (<span class="func">global-variable?</span> <span class="var">g.current</span> <span class="var">name</span>)
                                 (<span class="func">global-variable?</span> <span class="var">g.init</span> <span class="var">name</span>) ) ) )
                       (<span class="func">variable-value-lookup</span> <span class="var">kind</span> <span class="var">sr</span>)
                       (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )
                     (<span class="func">signal-exception</span>
                      <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Not a variable name"</span> <span class="var">name</span>) ) )
                 (<span class="func">signal-exception</span>
                  <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Not an environment"</span> <span class="var">env</span>) ) ) )
           (<span class="func">signal-exception</span>
            <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">variable-value</span>) ) ) ) ) ) )

(<span class="syntax">definitial</span> <span class="var">variable-defined?</span>
  (<span class="syntax">let*</span> ((<span class="var">arity</span> <span class="num">2</span>)
         (<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
    (<span class="func">make-primitive</span>
     (<span class="special">lambda</span> ()
       (<span class="special">if</span> (<span class="func">=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="var">arity+1</span>)
           (<span class="syntax">let</span> ((<span class="var">name</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>))
                 (<span class="var">env</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">1</span>)) )
             (<span class="special">if</span> (<span class="func">reified-environment?</span> <span class="var">env</span>)
                 (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">name</span>)
                     (<span class="syntax">let*</span> ((<span class="var">r</span> (<span class="func">reified-environment-r</span> <span class="var">env</span>))
                            (<span class="var">sr</span> (<span class="func">reified-environment-sr</span> <span class="var">env</span>)) )
                       (<span class="special">set!</span> <span class="var">*val*</span>
                             (<span class="special">if</span> (<span class="syntax">or</span> (<span class="syntax">let</span> ((<span class="var">var</span> (<span class="func">assq</span> <span class="var">name</span> <span class="var">r</span>)))
                                       (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">var</span>) (<span class="func">cadr</span> <span class="var">var</span>)) )
                                     (<span class="func">global-variable?</span> <span class="var">g.current</span> <span class="var">name</span>)
                                     (<span class="func">global-variable?</span> <span class="var">g.init</span> <span class="var">name</span>) )
                                 <span class="hash">#t</span> <span class="hash">#f</span> ) )
                       (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )
                     (<span class="func">signal-exception</span>
                      <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Not a variable name"</span> <span class="var">name</span>) ) )
                 (<span class="func">signal-exception</span>
                  <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Not an environment"</span> <span class="var">env</span>) ) ) )
           (<span class="func">signal-exception</span>
            <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">variable-value</span>) ) ) ) ) ) )</pre>

<p>Функция <code><span class="func">variable-defined?</span></code> служит для исследования реифицированных
окружений. Она определяет, можно ли пользоваться какой-либо переменной в данном
окружении. Этот вопрос не такой простой, каким кажется, так как если локальные
окружения однозначно можно расширять, то для глобального окружения это не всегда
так. Если глобальное окружение неизменяемо, то эта функция является чистой: ведь
если переменной нет в глобальном окружении сейчас, то она не появится и потом.
Однако, если глобальное окружение может измениться, то точно так же может
измениться и ответ <code><span class="func">variable-defined?</span></code>.</p>


<h2 id="reflection/sect:reflective-interpreter"><span class="wrap"><span class="seq">8.7</span><span class="title">Рефлексивный интерпретатор</span></span></h2>

<!--\indexR{интерпретатор!рефлексивный}-->
<!--\indexR{рефлексивный интерпретатор}-->
<p>В середине восьмидесятых годов весьма модной была тема рефлексивных
интерпретаторов — околобезумная фантазия исследователей, подарившая миру
термин «рефлексивные башни». Представьте себе топь, укрытую туманом, а
посреди неё тянущуюся ввысь башню, вершина которой растворяется в сером
пасмурном небе, — прямо как у Рэкхема! Подобные мистические ассоциации
проистекают из первых экспериментов с продолжениями, реификацией окружений и
<span class="sc"><span class="c">fexpr</span></span> диалекта Interlisp (над последними Кент Питман
в <span class="cite">[<a href="z1_bibliography.html#pit80">Pit80</a>]</span>
провёл хорошую расстановку точек).</p>

<!--\indexR{переопределение!всего}-->
<p>Ну кто из нас не мечтал создать (или хотя бы иметь) язык, где возможно
переопределить всё, где нет предела воображению, где любые идеи могут свободно
скакать по райским садам, не встречая помех и преград? К сожалению, сладкие
грёзы уступают место суровой реальности, где мы получаем невыносимо медлительные
системы, практически не поддающиеся компиляции и лишённые каких-либо твёрдых
законов функционирования.</p>

<p>Как бы то ни было, в этом разделе рассматривается небольшой рефлексивный
интерпретатор, мало что оставляющий недоступным или неявным. Естественно, он
является далеко не первым в своём роде, например: <span class="cite">[<a href="z1_bibliography.html#drs84">dRS84</a>]</span>, <span class="cite">[<a href="z1_bibliography.html#fw84">FW84</a>]</span>,
<span class="cite">[<a href="z1_bibliography.html#wan86">Wan86</a>]</span>, <span class="cite">[<a href="z1_bibliography.html#dm88">DM88</a>]</span>, <span class="cite">[<a href="z1_bibliography.html#baw88">Baw88</a>]</span>, <span class="cite">[<a href="z1_bibliography.html#que89">Que89</a>]</span>, <span class="cite">[<a href="z1_bibliography.html#imy92">IMY92</a>]</span>, <span class="cite">[<a href="z1_bibliography.html#jf92">JF92</a>]</span>
и множество других. Все эти интерпретаторы отличаются друг от друга конкретными
аспектами рефлексии и принципами реализации.</p>

<!--\indexC{call/cc}-->
<!--\indexC{the-environment}-->
<!--\indexR{реификация}-->
<!--\indexR{реификация|seealso{полноценные объекты}}-->
<!--\indexR{интроспекция}-->
<p>Рефлексивный интерпретатор обязан позволять интроспекцию, то есть давать
программам возможность в любой момент времени захватывать контекст вычислений.
Под контекстом вычислений здесь понимаются продолжение и лексическое окружение.
Текущее продолжение можно получить с помощью знакомой вам функции <code><span class="func">call/cc</span></code>.
Для получения требуемого окружения давайте используем рассмотренную ранее форму
<code>(<span class="special">export</span>)</code>, также известную как функция <code><span class="func">the-environment</span></code>, которая
реифицирует текущее лексическое окружение. Реификация, осознание понятий
является необходимым требованием рефлексии, но существует множество способов её
проведения, и выбор способа влияет на доступные в будущем возможности.</p>


<!--\indexE{fexpr@\textsc{fexpr}}-->
<!--\indexR{специальные формы!fexpr@\protect<code><span class="func">fexpr</span></code>}-->
<p>Как сказано в <span class="cite">[<a href="z1_bibliography.html#chr95">Chr95</a>]</span>: «Puisqu’une fois la borne franchie, il n’est plus de limite». И правда, ограничения бессмысленны
для тех, кто уже вышел за пределы дозволенного, поэтому мы дадим пользователям возможность
определять собственные специальные формы. Interlisp экспериментировал
с механизмом, присутствовавшим в <span class="sc">L<span class="c">isp</span> 1.5</span> под названием
<span class="sc"><span class="c">fexpr</span></span>. При вызове эта форма получала не значения аргументов,
а буквально их текст вместе с текущим лексическим окружением. После этого она могла
вычислять их в любом необходимом порядке, или, обобщая, делать с ними вообще всё, что ей
заблагорассудится. Мы введём подобную ей специальную форму
<code><span class="special">flambda</span></code> со следующим синтаксисом:</p>

<!--\indexC{flambda}-->
<pre>(<span class="special">flambda</span> (<i>переменные</i>...) <i>формы</i>...)</pre>

<p>Первая переменная связывается с текущим лексическим окружением, а все остальные
— с текстом аргументов, переданных при вызове. Например, вот так через
<code><span class="special">flambda</span></code> определяется цитирование:</p>

<pre>(<span class="special">set!</span> <span class="var">quote</span> (<span class="special">flambda</span> (<span class="var">r</span> <span class="var">quotation</span>) <span class="var">quotation</span>))</pre>

<p>Естественно, рефлексивный интерпретатор должен позволять изменение и самого себя
(захватывающая возможность, несомненно), поэтому мы сделаем все его внутренние
функции доступными интерпретируемым программам. Функция <code><span class="func">the-environment</span></code>
будет ответственной за помещение данных функций в глобальное окружение.</p>

<p>Итак, вот он — рефлексивный интерпретатор. Он занимает всего лишь 1362 байта<a class="footref" href="zz_footnotes.html#foot8.14"><sup>14</sup></a> —
достаточно мало, чтобы с лёгкостью поместиться в стандартную библиотеку.
Интерпретатор написан языком, доступным нашему компилятору в байт-код.</p>

<pre>(<span class="func">apply</span>
 (<span class="special">lambda</span> (<span class="var">make-toplevel</span> <span class="var">make-flambda</span> <span class="var">flambda?</span> <span class="var">flambda-apply</span>)
   (<span class="special">set!</span> <span class="var">make-toplevel</span>
     (<span class="special">lambda</span> (<span class="var">prompt-in</span> <span class="var">prompt-out</span>)
       (<span class="func">call/cc</span>
        (<span class="special">lambda</span> (<span class="var">exit</span>)
          (<span class="special">monitor</span> (<span class="special">lambda</span> (<span class="var">c</span> <span class="var">b</span>) (<span class="func">exit</span> <span class="var">b</span>))
            ((<span class="special">lambda</span> (<span class="var">it</span> <span class="var">extend</span> <span class="var">error</span> <span class="var">global-env</span> <span class="var">toplevel</span>
                      <span class="var">eval</span> <span class="var">evlis</span> <span class="var">eprogn</span> <span class="var">reference</span> )
               (<span class="special">set!</span> <span class="var">extend</span>
                     (<span class="special">lambda</span> (<span class="var">env</span> <span class="var">names</span> <span class="var">values</span>)
                       (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">names</span>)
                           (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">values</span>)
                               ((<span class="special">lambda</span> (<span class="var">newenv</span>)
                                  (<span class="special">begin</span>
                                   (<span class="func">set-variable-value!</span>
                                    (<span class="func">car</span> <span class="var">names</span>) <span class="var">newenv</span> (<span class="func">car</span> <span class="var">values</span>) )
                                   (<span class="func">extend</span> <span class="var">newenv</span> (<span class="func">cdr</span> <span class="var">names</span>)
                                           (<span class="func">cdr</span> <span class="var">values</span>) ) ) )
                                (<span class="func">enrich</span> <span class="var">env</span> (<span class="func">car</span> <span class="var">names</span>)) )
                               (<span class="func">error</span> <span class="string">"Too few arguments"</span> <span class="var">names</span>) )
                           (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">names</span>)
                               ((<span class="special">lambda</span> (<span class="var">newenv</span>)
                                  (<span class="special">begin</span>
                                   (<span class="func">set-variable-value!</span>
                                    <span class="var">names</span> <span class="var">newenv</span> <span class="var">values</span> )
                                   <span class="var">newenv</span> ) )
                                (<span class="func">enrich</span> <span class="var">env</span> <span class="var">names</span>) )
                               (<span class="special">if</span> (<span class="func">null?</span> <span class="var">names</span>)
                                   (<span class="special">if</span> (<span class="func">null?</span> <span class="var">values</span>) <span class="var">env</span>
                                       (<span class="func">error</span> <span class="string">"Too many arguments"</span>
                                              <span class="var">values</span> ) )
                                   <span class="var">env</span> ) ) ) ) )
               (<span class="special">set!</span> <span class="var">error</span>
                     (<span class="special">lambda</span> (<span class="var">msg</span> <span class="var">hint</span>)
                       (<span class="func">exit</span> (<span class="func">list</span> <span class="var">msg</span> <span class="var">hint</span>)) ) )
               (<span class="special">set!</span> <span class="var">toplevel</span>
                     (<span class="special">lambda</span> (<span class="var">genv</span>)
                       (<span class="special">set!</span> <span class="var">global-env</span> <span class="var">genv</span>)
                       (<span class="func">display</span> <span class="var">prompt-in</span>)
                       ((<span class="special">lambda</span> (<span class="var">result</span>)
                          (<span class="special">set!</span> <span class="var">it</span> <span class="var">result</span>)
                          (<span class="func">display</span> <span class="var">prompt-out</span>)
                          (<span class="func">display</span> <span class="var">result</span>) (<span class="func">newline</span>) )
                        ((<span class="special">lambda</span> (<span class="var">e</span>)
                           (<span class="special">if</span> (<span class="func">eof-object?</span> <span class="var">e</span>) (<span class="func">exit</span> <span class="var">e</span>)
                               (<span class="func">eval</span> <span class="var">e</span> <span class="var">global-env</span>) ) )
                         (<span class="func">read</span>) ) )
                       (<span class="func">toplevel</span> <span class="var">global-env</span>) ) )
               (<span class="special">set!</span> <span class="var">eval</span>
                     (<span class="special">lambda</span> (<span class="var">e</span> <span class="var">r</span>)
                       (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e</span>)
                           ((<span class="special">lambda</span> (<span class="var">f</span>)
                              (<span class="special">if</span> (<span class="func">flambda?</span> <span class="var">f</span>)
                                  (<span class="func">flambda-apply</span> <span class="var">f</span> <span class="var">r</span> (<span class="func">cdr</span> <span class="var">e</span>))
                                  (<span class="func">apply</span> <span class="var">f</span> (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span>)) ) )
                            (<span class="func">eval</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">r</span>) )
                           (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">reference</span> <span class="var">e</span> <span class="var">r</span>) <span class="var">e</span>) ) ) )
               (<span class="special">set!</span> <span class="var">evlis</span>
                     (<span class="special">lambda</span> (<span class="var">e*</span> <span class="var">r</span>)
                       (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
                           ((<span class="special">lambda</span> (<span class="var">v</span>)
                              (<span class="func">cons</span> <span class="var">v</span> (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">e*</span>) <span class="var">r</span>)) )
                            (<span class="func">eval</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span>) )
                           <span class="hash">'()</span> ) ) )
               (<span class="special">set!</span> <span class="var">eprogn</span>
                     (<span class="special">lambda</span> (<span class="var">e+</span> <span class="var">r</span>)
                       (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e+</span>))
                           (<span class="special">begin</span> (<span class="func">eval</span> (<span class="func">car</span> <span class="var">e+</span>) <span class="var">r</span>)
                                  (<span class="func">eprogn</span> (<span class="func">cdr</span> <span class="var">e+</span>) <span class="var">r</span>) )
                           (<span class="func">eval</span> (<span class="func">car</span> <span class="var">e+</span>) <span class="var">r</span>) ) ) )
               (<span class="special">set!</span> <span class="var">reference</span>
                     (<span class="special">lambda</span> (<span class="var">name</span> <span class="var">r</span>)
                       (<span class="special">if</span> (<span class="func">variable-defined?</span> <span class="var">name</span> <span class="var">r</span>)
                           (<span class="func">variable-value</span> <span class="var">name</span> <span class="var">r</span>)
                           (<span class="special">if</span> (<span class="func">variable-defined?</span> <span class="var">name</span> <span class="var">global-env</span>)
                               (<span class="func">variable-value</span> <span class="var">name</span> <span class="var">global-env</span>)
                               (<span class="func">error</span> <span class="string">"No such variable"</span> <span class="var">name</span>) ) ) ) )
               ((<span class="special">lambda</span> (<span class="var">quote</span> <span class="var">if</span> <span class="var">set!</span> <span class="var">lambda</span> <span class="var">flambda</span> <span class="var">monitor</span>)
                  (<span class="func">toplevel</span> (<span class="func">the-environment</span>)) )
                (<span class="func">make-flambda</span>
                 (<span class="special">lambda</span> (<span class="var">r</span> <span class="var">quotation</span>) <span class="var">quotation</span>) )
                (<span class="func">make-flambda</span>
                 (<span class="special">lambda</span> (<span class="var">r</span> <span class="var">condition</span> <span class="var">then</span> <span class="var">else</span>)
                   (<span class="func">eval</span> (<span class="special">if</span> (<span class="func">eval</span> <span class="var">condition</span> <span class="var">r</span>) <span class="var">then</span> <span class="var">else</span>) <span class="var">r</span>) ) )
                (<span class="func">make-flambda</span>
                 (<span class="special">lambda</span> (<span class="var">r</span> <span class="var">name</span> <span class="var">form</span>)
                   ((<span class="special">lambda</span> (<span class="var">v</span>)
                      (<span class="special">if</span> (<span class="func">variable-defined?</span> <span class="var">name</span> <span class="var">r</span>)
                          (<span class="func">set-variable-value!</span> <span class="var">name</span> <span class="var">r</span> <span class="var">v</span>)
                          (<span class="special">if</span> (<span class="func">variable-defined?</span> <span class="var">name</span> <span class="var">global-env</span>)
                              (<span class="func">set-variable-value!</span> <span class="var">name</span> <span class="var">global-env</span> <span class="var">v</span>)
                              (<span class="func">error</span> <span class="string">"No such variable"</span> <span class="var">name</span>) ) ) )
                    (<span class="func">eval</span> <span class="var">form</span> <span class="var">r</span>) ) ) )
                (<span class="func">make-flambda</span>
                 (<span class="special">lambda</span> (<span class="var">r</span> <span class="var">variables</span> . <span class="var">body</span>)
                   (<span class="special">lambda</span> <span class="var">values</span>
                     (<span class="func">eprogn</span> <span class="var">body</span> (<span class="func">extend</span> <span class="var">r</span> <span class="var">variables</span> <span class="var">values</span>)) ) ) )
                (<span class="func">make-flambda</span>
                 (<span class="special">lambda</span> (<span class="var">r</span> <span class="var">variables</span> . <span class="var">body</span>)
                   (<span class="func">make-flambda</span>
                    (<span class="special">lambda</span> (<span class="var">rr</span> . <span class="var">parameters</span>)
                      (<span class="func">eprogn</span> <span class="var">body</span>
                              (<span class="func">extend</span> <span class="var">r</span> <span class="var">variables</span>
                                      (<span class="func">cons</span> <span class="var">rr</span> <span class="var">parameters</span>) ) ) ) ) ) )
                (<span class="func">make-flambda</span>
                 (<span class="special">lambda</span> (<span class="var">r</span> <span class="var">handler</span> . <span class="var">body</span>)
                   (<span class="special">monitor</span> (<span class="func">eval</span> <span class="var">handler</span> <span class="var">r</span>)
                     (<span class="func">eprogn</span> <span class="var">body</span> <span class="var">r</span>) ) ) ) ) )
             '<span class="var">it</span> '<span class="var">extend</span> '<span class="var">error</span> '<span class="var">global-env</span> '<span class="var">toplevel</span>
             '<span class="var">eval</span> '<span class="var">evlis</span> '<span class="var">eprogn</span> '<span class="var">reference</span> ) ) ) ) ) )
   (<span class="func">make-toplevel</span> <span class="string">"?? "</span> <span class="string">"== "</span>) )
 '<span class="var">make-toplevel</span>
 ((<span class="special">lambda</span> (<span class="var">flambda-tag</span>)
    (<span class="func">list</span> (<span class="special">lambda</span> (<span class="var">behavior</span>) (<span class="func">cons</span> <span class="var">flambda-tag</span> <span class="var">behavior</span>))
          (<span class="special">lambda</span> (<span class="var">o</span>) (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">o</span>) (<span class="func">=</span> (<span class="func">car</span> <span class="var">o</span>) <span class="var">flambda-tag</span>) <span class="hash">#f</span>))
          (<span class="special">lambda</span> (<span class="var">f</span> <span class="var">r</span> <span class="var">params</span>) (<span class="func">apply</span> (<span class="func">cdr</span> <span class="var">f</span>) <span class="var">r</span> <span class="var">params</span>)) ) )
  <span class="num">98127634</span> ) )</pre>

<p>Как сказала бы Юлия Кристева<a class="footref" href="zz_footnotes.html#8.15"><sup>15</sup></a>,
данное определение пропитано изощрённостью как минимум в плане используемых обозначений.
Вероятно, вам придётся сначала немного поработать с этим интерпретатором,
прежде чем вы уверуете в него.</p>

<!--\indexC{==}-->
<!--\indexC{??}-->
<p>Внешняя форма <code><span class="func">apply</span></code> создаёт четыре локальные переменные.
Последние три из них отвечают за рефлексивные абстракции,
<code><span class="special">flambda</span></code>-формы, а именно:
<code><span class="func">make-flambda</span></code> создаёт их; <code><span class="func">flambda?</span></code> опознаёт их; <code><span class="func">flambda-apply</span></code>
применяет их. Эти абстракции обладают весьма своеобразным протоколом вызова, так
что у вас может уйти некоторое время на его понимание. Первая переменная,
<code><span class="func">make-toplevel</span></code>,
инициализируется в теле применяемой функции, дабы она могла
сделать доступными пользователям все четыре локальные переменные. По завершении
инициализации она запускает интерактивную сессию с настраиваемыми приглашениями
ко вводу. Изначально это <code>??</code> и <code>==</code>.</p>

<!--\indexC{it}-->
<!--\indexC{extend}-->
<!--\indexC{exit}-->
<p>Перед началом инициализации захватывается продолжение — оно будет
активировано в случае возникновения ошибки или при прямом вызове функции
<code><span class="func">exit</span></code>.<a class="footref" href="zz_footnotes.html#foot8.16"><sup>16</sup></a> Данное продолжение также доступно
интерпретируемым программам. Цикл, реализующий интерактивную сессию, защищён от
необработанных исключений формой <code><span class="special">monitor</span></code>.
<span class="see">[см. раздел <a href="ch07_compilation.html#compilation/exception/par:monitor">7.9</a>]</span>
Далее следуют объявление и инициализация служебных переменных и функций, которые, естественно,
будут доступны и пользователям. Переменная <code><span class="var">it</span></code> связывается
со значением последней вычисленной формы. Функция <code><span class="func">extend</span></code>,
конечно же, расширяет окружение новыми привязками. Функция
<code><span class="func">error</span></code> печатает сообщение об ошибке и завершает работу
программы, вызывая <code><span class="func">exit</span></code>.</p>

<!--\indexC{toplevel}-->
<!--\indexC{eval}-->
<!--\indexC{evlis}-->
<!--\indexC{eprogn}-->
<!--\indexC{reference}-->
<p>Функция <code><span class="func">toplevel</span></code>, как обычно, отвечает за диалог с пользователем.
Вспомогательные для <code><span class="func">eval</span></code> функции (<code><span class="func">evlis</span></code>, <code><span class="func">eprogn</span></code> и <code><span class="func">reference</span></code>)
имеют стандартные определения, разве что теперь они доступны пользователям.
Функция <code><span class="func">eval</span></code> сейчас — сама простота. Вычисляемое выражение может быть
или переменной, или неявно цитированным значением, или формой. В последнем
случае вычисляется первый элемент списка и, если он оказался рефлексивной
функцией, то ей передаётся текущее окружение вместе с параметрами вызова;
если же это обычная функция, то она и вызывается как обычная функция.</p>

<!--\indexC{stammer}-->
<!--\indexR{компиляция!рефлексивная}-->
<!--\indexR{рефлексивный интерпретатор}-->
<p>Язык, определяемый данным интерпретатором, невозможно эффективно компилировать
из-за его невероятной гибкости. Предположим, мы определили следующую нормальную
функцию:</p>

<pre>(<span class="special">set!</span> <span class="var">stammer</span> (<span class="special">lambda</span> (<span class="var">f</span> <span class="var">x</span>) (<span class="func">f</span> <span class="var">f</span> <span class="var">x</span>)))</pre>

<p>Теперь посмотрим, как она себя ведёт с рефлексивными абстракциями:</p>

<pre>(<span class="func">stammer</span> (<span class="special">lambda</span> (<span class="var">ff</span> <span class="var">yy</span>) <span class="var">yy</span>) <span class="num">33</span>)  <span class="math"><span class="rel">→</span></span> <span class="num">33</span>
(<span class="func">stammer</span> (<span class="special">flambda</span> (<span class="var">ff</span> <span class="var">yy</span>) <span class="var">yy</span>) <span class="num">33</span>) <span class="math"><span class="rel">→</span></span> <span class="var">x</span></pre>

<p>Получается, что первый вызов <code><span class="func">stammer</span></code> применяет переданную функцию саму
к себе, а второй — реифицирует своё собственное тело и применяет функцию
<em>к самому себе</em>. Следовательно, в присутствии <code><span class="special">flambda</span></code> необходимо
компилировать все аппликации каждой абстракции двумя различными способами:
рефлексивным и обычным. И это касается не только функций, но и всех обращений
к специальным формам — ведь теперь они тоже являются абстракциями, которые
можно переопределить. Короче говоря, мы отобрали у компилятора практически все
инварианты, на которые он может полагаться при оптимизации генерируемого кода,
а в таких условиях интерпретация оказывается ничем не хуже.</p>

<p>Перед запуском главного цикла определяются несколько рефлексивных функций,
просто потому, что их проще определить именно там. Таким образом получаются
<code><span class="special">quote</span></code>, <code><span class="special">if</span></code>, <code><span class="special">set!</span></code>, <code><span class="special">lambda</span></code>, <code><span class="special">flambda</span></code> и <code><span class="special">monitor</span></code>. Все
остальные можно добавить потом:</p>

<pre>(<span class="special">set!</span> <span class="var">global-env</span>
      (<span class="func">enrich</span> <span class="var">global-env</span> '<span class="var">begin</span> '<span class="var">the-environment</span>) )
(<span class="special">set!</span> <span class="var">the-environment</span>
      (<span class="special">flambda</span> (<span class="var">r</span>) <span class="var">r</span>) )
(<span class="special">set!</span> <span class="var">begin</span>
      (<span class="special">flambda</span> (<span class="var">r</span> . <span class="var">forms</span>)
        (<span class="func">eprogn</span> <span class="var">forms</span> <span class="var">r</span>) ) )</pre>


<!--\indexC{global-env}-->
<p>Переменная <code><span class="var">global-env</span></code> связана с реифицированным окружением, содержащим все
предшествующие определения, включая саму себя, — и это её главное
достоинство. Глобальное окружение не только доступно интерпретируемым
программам, но и произведённые ими изменения имеют обратную силу. Интерпретатор
и исполняемые им программы пользуются одной и той же <code><span class="var">global-env</span></code>. Действия
любой стороны имеют одинаковые последствия, приносят те же радости и печали.
Предыдущий пример работает именно благодаря этой взаимосвязи. Давайте рассмотрим
ещё один, определяющий новую специальную форму <code><span class="special">when</span></code>.</p>

<!--\indexC{when}-->
<pre>(<span class="special">set!</span> <span class="var">global-env</span> (<span class="func">enrich</span> <span class="var">global-env</span> '<span class="var">when</span>))
(<span class="special">set!</span> <span class="var">when</span>
      (<span class="special">flambda</span> (<span class="var">r</span> <span class="var">condition</span> . <span class="var">body</span>)
        (<span class="special">if</span> (<span class="func">eval</span> <span class="var">condition</span> <span class="var">r</span>) (<span class="func">eprogn</span> <span class="var">body</span> <span class="var">r</span>) <span class="hash">#f</span>) ) )</pre>

<p>Сначала глобальное окружение расширяется новой переменной, которая, конечно же,
пока не имеет никакого значения. Сразу же после этого она инициализируется
рефлексивной функцией. Так как глобальное окружение общее, то новая переменная
видна в том числе и интерпретатору, и функция <code><span class="func">eval</span></code> отныне будет вести себя
с ней так же, как и с любой другой специальной формой.</p>

<div class="bigskip"></div>

<!--\indexR{абстракция!рефлексивная}-->
<!--\indexR{рефлексивные абстракции}-->
<!--\indexR{интерпретация!самоинтерпретация}-->
<!--\indexR{самоинтерпретация}-->
<!--\indexR{уровни интерпретации}-->
<!--\indexR{интерпретация!уровневая}-->
<p>Вероятно, вас всё ещё мучает вопрос: «Ну и при чём здесь та укрытая туманом
башня, о которой говорилось в начале?» Просто представьте, что каждый её этаж
— это рефлексивный интерпретатор. Программы, исполняемые интерпретаторами,
могут пристраивать к башне новые этажи, создавать новые уровни интерпретации
с помощью функции <code><span class="func">make-toplevel</span></code>. Также они могут передать явному
вычислителю своё собственное определение, добившись таким образом поразительного
замедления работы, что скорее всего переносит подобные вещи в разряд мысленных
экспериментов. Самоинтерпретация немного отличается от рефлексии; она требует
строгого следования двум правилам. Во-первых, нельзя напрямую использовать
специальные формы для определения других специальных форм. Надеюсь, вам понятно,
что перестраивать фундамент башни, сидя при этом в ней же, — не самая хорошая
идея. Именно поэтому абстракция, связывающая переменные вроде <code><span class="var">quote</span></code> и
<code><span class="var">set!</span></code> с их определениями, имеет такое простое тело: <code>(<span class="func">toplevel</span>
(<span class="func">the-environment</span>))</code>. Во-вторых, <code><span class="special">flambda</span></code>-замыкания должны быть понятны всем
уровням интерпретации (вернее, любым двум соседним уровням). Поэтому
соответствующие функции определяются отдельно и используют для идентификации
специальную уникальную метку <code><span class="var">flambda-tag</span></code>. Хотя, конечно же, при таком
определении их легко можно обмануть.</p>


<!--\indexR{рефлексия}-->
<!--\indexR{интроспекция}-->
<p>В итоге программы получают возможность осознания собственных действий (включая
их продолжение и окружение, в котором они выполняются), далее они могут
проанализировать своё поведение, запрограммировать себя на что-то другое и
продолжить работу по новому плану. Интроспекция такого уровня предоставляет
поистине захватывающие возможности. Анализ и модификация контекста вычислений
рассмотрены, например, в <span class="cite">[<a href="z1_bibliography.html#que93a">Que93a</a>]</span>. Именно благодаря подобным возможностям
эти интерпретаторы и называются <em>рефлексивными</em>, а Лисп сыскал славу языка
искусственного интеллекта.</p>


<h4 id="reflection/reflective-interpreter/sssect:define"><span class="wrap"><span class="title">Форма <code><span class="special">define</span></code></span></span></h4>

<!--\indexC{define}-->
<!--\indexR{синтаксис!define@\protect<code><span class="func">define</span></code>}-->
<p>Забавно, но предыдущий рефлексивный интерпретатор позволяет весьма просто
определить довольно сложную форму — <code><span class="special">define</span></code>. Как было сказано ранее,
<code><span class="special">define</span></code> — это <em>очень</em> специальная форма: она ведёт себя одновременно
как определение и как присваивание. С одной стороны, после выполнения
<code><span class="special">define</span></code> переменная имеет чётко определённое значение. С другой стороны, ещё
до выполнения тела <code><span class="special">define</span></code> в окружении магическим образом появляется новая
переменная, известная как внутри самой <code><span class="special">define</span></code>, так и повсюду после неё. Все
эти аспекты семантики специальной формы <code><span class="special">define</span></code> хорошо видны в приведённом
определении. Для краткости мы не стали реализовывать её чисто синтаксические
возможности, позволяющие писать выражения вроде <code>(<span class="special">define</span> (<span class="func">foo</span> <span class="var">x</span>) (<span class="special">define</span>
(<span class="func">bar</span>) ...) ...)</code>, а также остальные правила преобразования вложенных форм
<code><span class="special">define</span></code>. (Серьёзно, <code><span class="special">define</span></code> — это сложно.)</p>

<pre>(<span class="special">set!</span> <span class="var">global-env</span> (<span class="func">enrich</span> <span class="var">global-env</span> '<span class="var">define</span>))
(<span class="special">set!</span> <span class="var">define</span>
      (<span class="special">flambda</span> (<span class="var">r</span> <span class="var">name</span> <span class="var">form</span>)
        (<span class="special">if</span> (<span class="func">variable-defined?</span> <span class="var">name</span> <span class="var">r</span>)
            (<span class="func">set-variable-value!</span> <span class="var">name</span> <span class="var">r</span> (<span class="func">eval</span> <span class="var">form</span> <span class="var">r</span>))
            ((<span class="special">lambda</span> (<span class="var">rr</span>)
               (<span class="special">set!</span> <span class="var">global-env</span> <span class="var">rr</span>)
               (<span class="func">set-variable-value!</span> <span class="var">name</span> <span class="var">rr</span> (<span class="func">eval</span> <span class="var">form</span> <span class="var">rr</span>)) )
             (<span class="func">enrich</span> <span class="var">r</span> <span class="var">name</span>) ) ) ) )</pre>

<p>Прежде всего <code><span class="special">define</span></code> проверяет, существует ли уже переменная. Если это так,
то её (пере)определение, в соответствии с R<sup>5</sup>RS, сводится к присваиванию нового
значения. В противном случае в глобальном окружении создаётся новая переменная,
и её начальное значение вычисляется в новом, расширенном окружении, позволяющем
рекурсивные определения.</p>


<h2 id="reflection/sect:conclusions"><span class="wrap"><span class="seq">8.8.</span><span class="title">Заключение</span></span></h2>

<p>В этой главе были рассмотрены различные аспекты использования явного
вычислителя, касающиеся как обычных функций, так и специальных форм.
В зависимости от желаемых качеств встроенного языка, возможны различные варианты
реализации вычислителя, в частности, использующие полноценные окружения или
квазистатические привязки. Это прекрасная иллюстрация того, что проектирование
языков программирования действительно является искусством, предоставляющим
истинно неограниченные возможности решения возникающих в процессе задач.</p>

<p>Также данная глава показывает, насколько повезло Лиспу (вернее, насколько
удачные решения были приняты его автором, Джоном Маккарти) с представлением
программ и данных, сближающим понятия языка и метаязыка, благодаря чему
открывается широчайшее поле для экспериментов.</p>


<h2 id="reflection/sect:exercises"><span class="wrap"><span class="seq">8.9.</span><span class="title">Упражнения</span></span></h2>

<h5 class="exercise" id="reflection/ex:no-cycles">Упражнение <span class="seq">8.1</span></h5>
<p>Почему функция <code><span class="func">variables-list?</span></code> ничего не предпринимает во избежание
зацикливания при обработке списка переменных?</p>


<h5 class="exercise" id="reflection/ex:optimize-ce">Упражнение <span class="seq">8.2</span></h5>
<!--\indexCS{eval/ce}{оптимизация}-->
<!--\indexR{мемоизация}-->
<p>Специальная форма <code><span class="special">eval/ce</span></code> компилирует на лету передаваемые ей выражения.
Но она делает это каждый раз заново, что не особо эффективно, если требуется
вычислить одно и то же выражение несколько раз. Придумайте, как исправить этот
недостаток.</p>


<h5 class="exercise" id="reflection/ex:no-capture">Упражнение <span class="seq">8.3</span></h5>
<p>Улучшите определение <code><span class="func">eval/at</span></code> через <code><span class="special">eval/ce</span></code>, избавившись от нечаянно
захватываемой переменной. Подсказка: <code><span class="func">gens...</span></code></p>


<h5 class="exercise" id="reflection/ex:defined">Упражнение <span class="seq">8.4</span></h5>
<p>Может ли пользователь определить <code><span class="func">variable-defined?</span></code> самостоятельно?
Почему нет/как именно?</p>


<h5 class="exercise" id="reflection/ex:rnrs">Упражнение <span class="seq">8.5</span></h5>
<p>Переведите определение рефлексивного интерпретатора на стандартный Scheme.</p>


<h2><span class="wrap"><span class="title">Рекомендуемая литература</span></span></h2>

<p>Статья <span class="cite">[<a href="z1_bibliography.html#dr87">dR87</a>]</span> отлично показывает, насколько всё же Лисп рефлексивен.
В <span class="cite">[<a href="z1_bibliography.html#mul92">Mul92</a>]</span> рассматривается алгебраическая семантика его рефлексивных
возможностей. Также стоит взглянуть на работы <span class="cite">[<a href="z1_bibliography.html#jf92">JF92</a>]</span> и <span class="cite">[<a href="z1_bibliography.html#imy92">IMY92</a>]</span>,
затрагивающие рефлексию в общем.</p>

</div>
</div>

</body>
</html>
