<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru">

<head>
    <title>7 – Компиляция</title>
    <link rel="stylesheet" type="text/css" href="zz_lisp.css"/>
    <link rel="stylesheet" type="text/css" href="zz_fontsize.css"/>
</head>

<body>

<h1 id="chapter:compilation"><span class="wrap"><span class="seq">Глава 7.</span><span class="title">Компиляция</span></span></h1>

<p class="noindent"><span class="initial">В</span><span class="sc"><span class="c">предыдущей главе</span></span>
был изложен метод перевода
программ со Scheme на древовидный язык, содержащий около двадцати инструкций.
В этой главе мы покажем, как преобразовать результат данной предварительной
обработки в последовательность байтов — специализированный
машинный язык. По пути будут рассмотрены следующие темы: создание виртуальной
машины, компиляция в её внутренний язык, реализация различных расширений Scheme
вроде переходов, динамических переменных, исключений.</p>

<table id="ch7-interm-instruction-list" class="instruction-list">
<tbody>
<tr><td><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <i>j</i>)</code></td>
<td><code>(<span class="func">PREDEFINED</span> <i>i</i>)</code></td></tr>
<tr><td><code>(<span class="func">DEEP-ARGUMENT-REF</span> <i>i</i> <i>j</i>)</code></td>
<td><code>(<span class="func">SHALLOW-ARGUMENT-SET!</span> <i>j</i> <i>m</i>)</code></td></tr>
<tr><td><code>(<span class="func">DEEP-ARGUMENT-SET!</span> <i>i</i> <i>j</i> <i>m</i>)</code></td>
<td><code>(<span class="func">GLOBAL-REF</span> <i>i</i>)</code></td></tr>
<tr><td><code>(<span class="func">CHECKED-GLOBAL-REF</span> <i>i</i>)</code></td>
<td><code>(<span class="func">GLOBAL-SET</span>! <i>i</i> <i>m</i>)</code></td></tr>
<tr><td><code>(<span class="func">CONSTANT</span> <i>v</i>)</code></td>
<td><code>(<span class="func">ALTERNATIVE</span> <i>m<sub><span class="normal">1</span></sub></i> <i>m<sub><span class="normal">2</span></sub></i> <i>m<sub><span class="normal">3</span></sub></i>)</code></td></tr>
<tr><td><code>(<span class="func">SEQUENCE</span> <i>m</i> <i>m<span class="normal">+</span></i>)</code></td>
<td><code>(<span class="func">TR-FIX-LET</span> <i>m<span class="normal">*</span></i> <i>m<span class="normal">+</span></i>)</code></td></tr>
<tr><td><code>(<span class="func">FIX-LET</span> <i>m<span class="normal">*</span></i> <i>m<span class="normal">+</span></i>)</code></td>
<td><code>(<span class="func">CALL0</span> <i>адрес</i>)</code></td></tr>
<tr><td><code>(<span class="func">CALL1</span> <i>адрес</i> <i>m<sub><span class="normal">1</span></sub></i>)</code></td>
<td><code>(<span class="func">CALL2</span> <i>адрес</i> <i>m<sub><span class="normal">1</span></sub></i> <i>m<sub><span class="normal">2</span></sub></i>)</code></td></tr>
<tr><td><code>(<span class="func">CALL3</span> <i>адрес</i> <i>m<sub><span class="normal">1</span></sub></i> <i>m<sub><span class="normal">2</span></sub></i> <i>m<sub><span class="normal">3</span></sub></i>)</code></td>
<td><code>(<span class="func">FIX-CLOSURE</span> <i>m<span class="normal">+</span></i> <i>арность</i>)</code></td></tr>
<tr><td><code>(<span class="func">NARY-CLOSURE</span> <i>m<span class="normal">+</span></i> <i>арность</i>)</code></td>
<td><code>(<span class="func">TR-REGULAR-CALL</span> <i>m</i> <i>m<span class="normal">*</span></i>)</code></td></tr>
<tr><td><code>(<span class="func">REGULAR-CALL</span> <i>m</i> <i>m<span class="normal">*</span></i>)</code></td>
<td><code>(<span class="func">STORE-ARGUMENT</span> <i>m</i> <i>m<span class="normal">*</span></i> <i>индекс</i>)</code></td></tr>
<tr><td><code>(<span class="func">CONS-ARGUMENT</span> <i>m</i> <i>m<span class="normal">*</span></i> <i>арность</i>)</code></td>
<td><code>(<span class="func">ALLOCATE-FRAME</span> <i>размер</i>)</code></td></tr>
<tr><td><code>(<span class="func">ALLOCATE-DOTTED-FRAME</span> <i>арность</i>)</code></td>
<td/></tr>
</tbody></table>
<span class="caption">Таблица 7.1. Все 25 инструкций промежуточного языка. <i>m</i>, <i>m<sub><span class="normal">1</span></sub></i>, <i>m<sub><span class="normal">2</span></sub></i>, <i>m<sub><span class="normal">3</span></sub></i>,
<i>m<span class="normal">+</span></i> и <i>v</i> — значения; <i>m<span class="normal">*</span></i> — запись активации; <i>индекс</i>, <i>арность</i>, <i>размер</i>,
<i>i</i> и <i>j</i> — натуральные числа (с нулём); <i>адрес</i> представляет примитивную
функцию, принимающую и возвращающую значения.</span>

<!--\indexR{язык!промежуточный}-->
<!--\indexR{промежуточное представление}-->
<p id="compilation/par:disasm">В результате компиляции обычно получается последовательность весьма
низкоуровневых инструкций. Это отнюдь не так для нашего предобработчика: мы
получаем на выходе структурированную древовидную программу. Рассмотрим
следующий красноречивый пример. Пусть у нас есть программа:</p>

<!--\indexC{fact}-->
<pre>((<span class="special">lambda</span> (<span class="var">fact</span>) (<span class="func">fact</span> <span class="num">5</span> <span class="var">fact</span> (<span class="special">lambda</span> (<span class="var">x</span>) <span class="var">x</span>)))
 (<span class="special">lambda</span> (<span class="var">n</span> <span class="var">f</span> <span class="var">k</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">k</span> <span class="num">1</span>)
                     (<span class="func">f</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">f</span> (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>)))) )) )</pre>

<p class="noindent">После обработки она превращается в следующую:</p>

<pre>(<span class="func">TR-FIX-LET</span>
 (<span class="func">STORE-ARGUMENT</span>
  (<span class="func">FIX-CLOSURE</span>
   (<span class="func">ALTERNATIVE</span>
    (<span class="func">CALL2</span> <span class="hash">#&lt;=&gt;</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>) (<span class="func">CONSTANT</span> <span class="num">0</span>))
    (<span class="func">TR-REGULAR-CALL</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">2</span>)
                     (<span class="func">STORE-ARGUMENT</span> (<span class="func">CONSTANT</span> <span class="num">1</span>)
                                     (<span class="func">ALLOCATE-FRAME</span> <span class="num">1</span>) <span class="num">0</span>) )
    (<span class="func">TR-REGULAR-CALL</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">1</span>)
     (<span class="func">STORE-ARGUMENT</span> (<span class="func">CALL2</span> <span class="hash">#&lt;-&gt;</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>) (<span class="func">CONSTANT</span> <span class="num">1</span>))
      (<span class="func">STORE-ARGUMENT</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">1</span>)
       (<span class="func">STORE-ARGUMENT</span> (<span class="func">FIX-CLOSURE</span>
                        (<span class="func">TR-REGULAR-CALL</span> (<span class="func">DEEP-ARGUMENT-REF</span> <span class="num">1</span> <span class="num">2</span>)
                         (<span class="func">STORE-ARGUMENT</span> (<span class="func">CALL2</span> <span class="hash">#&lt;*&gt;</span>
                                          (<span class="func">DEEP-ARGUMENT-REF</span> <span class="num">1</span> <span class="num">0</span>)
                                          (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>) )
                          (<span class="func">ALLOCATE-FRAME</span> <span class="num">1</span>)
                          <span class="num">0</span> ) )
                        <span class="num">1</span> )
        (<span class="func">ALLOCATE-FRAME</span> <span class="num">3</span>)
        <span class="num">2</span> )
       <span class="num">1</span> )
      <span class="num">0</span> ) ) )
   <span class="num">3</span> )
  (<span class="func">ALLOCATE-FRAME</span> <span class="num">1</span>)
  <span class="num">0</span> )
 (<span class="func">TR-REGULAR-CALL</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)
  (<span class="func">STORE-ARGUMENT</span> (<span class="func">CONSTANT</span> <span class="num">5</span>)
   (<span class="func">STORE-ARGUMENT</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)
    (<span class="func">STORE-ARGUMENT</span> (<span class="func">FIX-CLOSURE</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>) <span class="num">1</span>)
     (<span class="func">ALLOCATE-FRAME</span> <span class="num">3</span>)
     <span class="num">2</span> )
    <span class="num">1</span> )
   <span class="num">0</span> ) ) )</pre>

<p>Не шедевр удобочитаемости, но очень точно выражает необходимые действия.
Цель данной главы — показать, что данная форма ещё далека от окончательной.
Даже не форма — после выполнения преобразований вроде линеаризации и
байт-кодирования мы получим совершенно новый язык. Тот же язык,
инструкции-генераторы которого собраны
в таблице <a href="#ch7-interm-instruction-list">7.1</a>, на самом деле будет служить
нам лишь промежуточным этапом, трамплином, от которого мы оттолкнёмся,
чтобы улететь в дальние миры.</p>

<p>Предварительная обработка (выполняемая третьим интерпретатором из предыдущей
главы) будет первым проходом компилятора. Соответственно, компилятор должен
понимать лишь эти двадцать пять инструкций. На самом деле, мы их даже немного
улучшим, заточив под целевой язык виртуальной машины. Подобное разделение труда
возможно благодаря тому, что промежуточный язык уже является исполнимым. Это
позволяет протестировать предобработчик отдельно и полностью сконцентрироваться
на второй фазе компиляции.</p>

<!--\indexR{байт-код}-->
<p>Для начала мы займёмся собственно компиляцией под виртуальную машину. Это будет
простая, но типичная виртуальная машина, программируемая с помощью машинного
языка. Её инструкции представляются байтами, целыми числами от 0 до 255. Такой
способ представления программ называется <em class="term">байт-кодом</em>. Изобретён он был
незадолго до 1980 года, судя по <span class="cite">[<a href="z1_bibliography.xhtml#deu80">Deu80</a>, <a href="z1_bibliography.xhtml#row80">Row80</a>]</span>. С тех пор байт-код нередко
используется для иллюстрации процесса компиляции; как пример: <span class="cite">[<a href="z1_bibliography.xhtml#hen80">Hen80</a>]</span>.
Получаемый код является довольно компактным — качество, очень полезное на
машинах с ограниченной памятью или кешем. Именно компиляция в байт-код
применяется для PC-Scheme <span class="cite">[<a href="z1_bibliography.xhtml#bj86">BJ86</a>]</span> и Caml Light <span class="cite">[<a href="z1_bibliography.xhtml#lw93">LW93</a>]</span>.</p>

<p>Концептуально байт-кодирование устроено довольно просто: прошедшая предобработку
программа компилируется в последовательность байт-кодов, которая уже исполняется
интерпретатором, эмулирующим виртуальную машину на реальной. Так как байт-коды
проще, чем высокоуровневые языки, то интерпретатор тратит значительно меньше
времени на их разбор и в итоге работает быстрее.</p>


<h2 id="compilation/sect:bytes"><span class="wrap"><span class="seq">7.1.</span><span class="title">Компиляция в байт-код</span></span></h2>

<p>Задача на сейчас: шаг за шагом разработать специализированную машину,
исполняющую байт-коды. Мы определим эту машину, определив для неё смысл
(операционную семантику) двадцати пяти инструкций промежуточного языка.
Часть из них трактуются очевидным образом, другие потребуют некоторой
изобретательности. К счастью, виртуальная машина и её язык создаются
одновременно, что даёт неоценимую гибкость разработки. Для нас не будет
проблемой в любой момент добавить ещё один регистр или, например, дополнить
архитектуру стеком.</p>

<!--\indexR{линеаризация}-->
<p>Чтобы получить желаемую последовательность байт-кодов, потребуется вытянуть
в прямую линию изначальное дерево инструкций промежуточного языка,
<em class="term">линеаризовать</em> его. В данный момент эти инструкции обмениваются
информацией через аргументы и возвращаемые значения, но возможности передачи
информации между машинным инструкциями ограничены регистрами и стеком. Сейчас
наша машина имеет лишь один регистр: <code><span class="var">*env*</span></code>,
содержащий текущее состояние лексического окружения, но вскоре эта слегка спартанская
архитектура обрастёт жирком.</p>


<h3 id="compilation/bytes/ssect:*val*"><span class="wrap"><span class="seq">7.1.1.</span><span class="title">Знакомьтесь, регистр <code><span class="var">*val*</span></code></span></span></h3>

<!--\indexR{инструкции!производители}-->
<!--\indexR{инструкции!потребители}-->
<p>Некоторые инструкции промежуточного языка производят значения, например,
<code><span class="func">SHALLOW-ARGUMENT-REF</span></code> или <code><span class="func">CONSTANT</span></code>. Другие же, подобные <code><span class="func">FIX-LET</span></code>
или <code><span class="func">ALTERNATIVE</span></code>, только управляют ходом вычислений. Помимо них есть и
третья разновидность инструкций, которые потребляют значения, производимые
первыми. Давайте внимательно рассмотрим инструкцию <code><span class="func">GLOBAL-SET!</span></code>,
определяемую следующим образом:</p>

<pre>(<span class="special">define</span> (<span class="func">GLOBAL-SET!</span> <span class="var">i</span> <span class="var">m</span>)
  (<span class="special">lambda</span> () (<span class="func">global-update!</span> <span class="var">i</span> (<span class="func">m</span>))) )</pre>

<!--\indexC*{val}{*val*}-->
<!--\indexR{регистры!val@\protect<code><span class="func">*val*</span></code>}-->
<p>Для того, чтобы передать инструкции <code><span class="func">global-update!</span></code> результат
вычисления <code>(<span class="func">m</span>)</code>, необходим дополнительный регистр. Назовём его <code><span class="var">*val*</span></code>.
Инструкции-производители, соответственно, кладут возвращаемые значения в этот
регистр, а инструкции-потребители — забирают их оттуда. В итоге, типичный
производитель <code><span class="func">CONSTANT</span></code> теперь записывается вот так:</p>

<!--\indexC{CONSTANT}-->
<pre>(<span class="special">define</span> (<span class="func">CONSTANT</span> <span class="var">value</span>)
  (<span class="special">lambda</span> ()
    (<span class="special">set!</span> <span class="var">*val*</span> <span class="var">value</span>) ) )</pre>

<p class="noindent">а потребители значений вроде <code><span class="func">GLOBAL-SET!</span></code> становятся такими:</p>

<!--\indexC{GLOBAL-SET"!}-->
<pre>(<span class="special">define</span> (<span class="func">GLOBAL-SET!</span> <span class="var">i</span> <span class="var">m</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m</span>)
    (<span class="func">global-update!</span> <span class="var">i</span> <span class="var">*val*</span>) ) )</pre>

<p>Итого, форма <code>(<span class="func">m</span>)</code> размещает новое значение переменной в регистре <code><span class="var">*val*</span></code>,
затем его оттуда забирает <code><span class="func">global-update!</span></code> и переносит в глобальное
окружение. Заметьте, что <code><span class="func">global-update!</span></code> не изменяет значение регистра
<code><span class="var">*val*</span></code>, ведь это потребовало бы как минимум одной лишней инструкции.
Следовательно, возвращаемым значением этой формы присваивания является только
что присвоенное глобальной переменной значение.</p>

<p>По этому примеру довольно легко догадаться, как преобразовать остальные
инструкции. Например, <code><span class="func">SEQUENCE</span></code> вообще не требует изменений:</p>

<!--\indexC{SEQUENCE}-->
<pre>(<span class="special">define</span> (<span class="func">SEQUENCE</span> <span class="var">m</span> <span class="var">m+</span>)
  (<span class="special">lambda</span> () (<span class="func">m</span>) (<span class="func">m+</span>)) )</pre>

<p class="noindent">а <code><span class="func">FIX-LET</span></code> принимает следующий вид:</p>

<!--\indexC{FIX-LET}-->
<pre>(<span class="special">define</span> (<span class="func">FIX-LET</span> <span class="var">m*</span> <span class="var">m+</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m*</span>)
    (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">sr-extend*</span> <span class="var">*env*</span> <span class="var">*val*</span>))
    (<span class="func">m+</span>)
    (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">activation-frame-next</span> <span class="var">*env*</span>)) ) )</pre>


<h3 id="compilation/bytes/ssect:stack"><span class="wrap"><span class="seq">7.1.2.</span><span class="title">Изобретение стека</span></span></h3>

<p>На данный момент часть инструкций уже линеаризована с помощью регистра
<code><span class="var">*val*</span></code>, но некоторые из них так просто не поддаются. Например,
<code><span class="func">STORE-ARGUMENT</span></code> сейчас имеет такое определение:</p>

<!--\indexC{STORE-ARGUMENT}-->
<pre>(<span class="special">define</span> (<span class="func">STORE-ARGUMENT</span> <span class="var">m</span> <span class="var">m*</span> <span class="var">index</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m</span>)
    (<span class="syntax">let</span> ((<span class="var">v</span> <span class="var">*val*</span>))
      (<span class="func">m*</span>)
      (<span class="func">set-activation-frame-argument!</span> <span class="var">*val*</span> <span class="var">index</span> <span class="var">v</span>) ) ) )</pre>

<!--\indexR{стек}-->
<p>Эта инструкция использует <code><span class="syntax">let</span></code>, чтобы сохранить, а затем восстановить
значение регистра <code><span class="var">*val*</span></code>. Форма <code><span class="syntax">let</span></code> сохраняет значение в «анонимном
регистре» <code><span class="var">v</span></code> на время, пока вычисляется <code>(<span class="func">m*</span>)</code>. Под <code><span class="var">v</span></code> не получится
выделить реальный машинный регистр, так как нам может потребоваться произвольное
количество таких <code><span class="var">v</span></code> одновременно — ведь, например, внутри <code><span class="func">m*</span></code> вполне
может быть ещё несколько вложенных <code><span class="func">STORE-ARGUMENT</span></code>. Следовательно, здесь
необходимо нечто, где можно хранить несколько значений между инструкциями. Для
этой цели уместно будет использовать стек, так как он прекрасно отображает идею
сбалансированных сохранений-восстановлений. Определяется он элементарно:</p>

<!--\indexC*{stack}{*stack*}-->
<!--\indexC*{stack-push}{*stack-push*}-->
<!--\indexC*{stack-pop}{*stack-pop*}-->
<!--\indexC*{stack-index}{*stack-index*}-->
<pre>(<span class="special">define</span> <span class="var">*stack*</span> (<span class="func">make-vector</span> <span class="num">1000</span>))
(<span class="special">define</span> <span class="var">*stack-index*</span> <span class="num">0</span>)

(<span class="special">define</span> (<span class="func">stack-push</span> <span class="var">v</span>)
  (<span class="func">vector-set!</span> <span class="var">*stack*</span> <span class="var">*stack-index*</span> <span class="var">v</span>)
  (<span class="special">set!</span> <span class="var">*stack-index*</span> (<span class="func">+</span> <span class="var">*stack-index*</span> <span class="num">1</span>)) )

(<span class="special">define</span> (<span class="func">stack-pop</span>)
  (<span class="special">set!</span> <span class="var">*stack-index*</span> (<span class="func">-</span> <span class="var">*stack-index*</span> <span class="num">1</span>))
  (<span class="func">vector-ref</span> <span class="var">*stack*</span> <span class="var">*stack-index*</span>) )</pre>

<p>Обретя данную революционную технологию, мы тут же используем её для радикального
преобразования инструкции <code><span class="func">STORE-ARGUMENT</span></code>. Теперь временные значения можно
сохранить в стеке перед началом других вычислений, чтобы после их окончания
достать оттуда всё в целости и сохранности. Правда, это сработает только при
условии, что форма <code>(<span class="func">m*</span>)</code> оставит стек в том же состоянии, в каком он был до
её исполнения. Следовательно, необходимо быть аккуратным и везде следить за
соблюдением данного инварианта.</p>

<!--\indexC{STORE-ARGUMENT}-->
<pre>(<span class="special">define</span> (<span class="func">STORE-ARGUMENT</span> <span class="var">m</span> <span class="var">m*</span> <span class="var">index</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m</span>)
    (<span class="func">stack-push</span> <span class="var">*val*</span>)
    (<span class="func">m*</span>)
    (<span class="func">set-activation-frame-argument!</span> <span class="var">*val*</span> <span class="var">index</span> (<span class="func">stack-pop</span>)) ) )</pre>

<p>Модификация <code><span class="func">REGULAR-CALL</span></code> аналогична, только здесь требуется хранить сразу
два значения: саму функцию на время вычисления аргументов, а также текущее
окружение на время выполнения функции. Сейчас эта инструкция выглядит так:</p>

<pre>(<span class="special">define</span> (<span class="func">REGULAR-CALL</span> <span class="var">m</span> <span class="var">m*</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m</span>)
    (<span class="syntax">let</span> ((<span class="var">f</span> <span class="var">*val*</span>))
      (<span class="func">m*</span>)
      (<span class="syntax">let</span> ((<span class="var">sr</span> <span class="var">*env*</span>))
        (<span class="func">invoke</span> <span class="var">f</span> <span class="var">*val*</span>)
        (<span class="special">set!</span> <span class="var">*env*</span> <span class="var">sr</span>) ) ) ) )</pre>

<!--\indexC*{fun}{*fun*}-->
<!--\indexR{регистры!fun@\protect<code><span class="func">*fun*</span></code>}-->
<p>После добавления нового регистра для функций — <code><span class="var">*fun*</span></code>, — определение
преобразуется в следующее:</p>

<!--\indexC{REGULAR-CALL}-->
<pre>(<span class="special">define</span> (<span class="func">REGULAR-CALL</span> <span class="var">m</span> <span class="var">m*</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m</span>)
    (<span class="func">stack-push</span> <span class="var">*val*</span>)
    (<span class="func">m*</span>)
    (<span class="special">set!</span> <span class="var">*fun*</span> (<span class="func">stack-pop</span>))
    (<span class="func">stack-push</span> <span class="var">*env*</span>)
    (<span class="func">invoke</span> <span class="var">*fun*</span>)
    (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">stack-pop</span>)) ) )</pre>

<p>Заигравшись, мы мимоходом изменили протокол вызова функций. Теперь функции
принимают свою запись активации не через аргумент, а ожидают её в регистре
<code><span class="var">*val*</span></code>. Это поведение закрепляется в определении <code><span class="func">FIX-CLOSURE</span></code>:</p>

<!--\indexC{FIX-CLOSURE}-->
<pre>(<span class="special">define</span> (<span class="func">FIX-CLOSURE</span> <span class="var">m+</span> <span class="var">arity</span>)
  (<span class="syntax">let</span> ((<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)))
    (<span class="special">lambda</span> ()
      (<span class="special">define</span> (<span class="func">the-function</span> <span class="var">sr</span>)
        (<span class="special">if</span> (<span class="func">=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="var">arity+1</span>)
            (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">sr-extend*</span> <span class="var">sr</span> <span class="var">*val*</span>))
                   (<span class="func">m+</span>) )
            (<span class="func">wrong</span> <span class="string">"Incorrect arity"</span>) ) )
      (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">make-closure</span> <span class="var">the-function</span> <span class="var">*env*</span>)) ) ) )</pre>

<!--\indexC*{arg1}{*arg1*}-->
<!--\indexC*{arg2}{*arg2*}-->
<!--\indexR{регистры!arg1@\protect<code><span class="func">*arg1*</span></code>}-->
<!--\indexR{регистры!arg2@\protect<code><span class="func">*arg2*</span></code>}-->
<p>Добавив ещё регистров, мы сможем линеаризовать и вызовы примитивов. Введём два
новых регистра: <code><span class="var">*arg1*</span></code> и <code><span class="var">*arg2*</span></code>. Один из них может физически совпадать
с <code><span class="var">*fun*</span></code>, который всё равно не используется одновременно с ними. Эти
регистры позволяет определить <code><span class="func">CALL3</span></code> следующим образом:</p>

<!--\indexC*{CALL0}{CALL\protect<i>n</i>}-->
<pre>(<span class="special">define</span> (<span class="func">CALL3</span> <span class="var">address</span> <span class="var">m1</span> <span class="var">m2</span> <span class="var">m3</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m1</span>)
    (<span class="func">stack-push</span> <span class="var">*val*</span>)
    (<span class="func">m2</span>)
    (<span class="func">stack-push</span> <span class="var">*val*</span>)
    (<span class="func">m3</span>)
    (<span class="special">set!</span> <span class="var">*arg2*</span> (<span class="func">stack-pop</span>))
    (<span class="special">set!</span> <span class="var">*arg1*</span> (<span class="func">stack-pop</span>))
    (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">address</span> <span class="var">*arg1*</span> <span class="var">*arg2*</span> <span class="var">*val*</span>)) ) )</pre>


<h3 id="compilation/bytes/ssect:customize"><span class="wrap"><span class="seq">7.1.3.</span><span class="title">Дорабатываем инструкции</span></span></h3>

<!--\indexR{счётчик команд}-->
<!--\indexR{инструкции!сложность}-->
<p>В данный момент рассмотренные двадцать пять инструкций генерируют замыкания,
внутри которых находятся последовательности составных операций над регистрами.
Такие сложные инструкции нам не подходят — машине нужны маленькие и
однозначные инструкции, выполняющие простые действия: изменить один регистр,
положить одно значение в стек и т. п. Поэтому мы развернём большие инструкции,
превратив их в последовательности из маленьких. Так как в такой куче команд
легко запутаться, то давайте введём специализированный регистр для хранения
следующей инструкции  — <em class="term">счётчик команд</em>. Заодно он позволит нам
в дальнейшем точнее определить протокол вызова функций, а также всевозможные
управляющие формы, в том числе и <code><span class="func">call/cc</span></code>.</p>


<h4 id="compilation/bytes/customize/sssect:lin-assignment"><span class="wrap"><span class="title">Линеаризация присваиваний</span></span></h4>

<p>Рассмотрим для примера инструкцию <code><span class="func">SHALLOW-ARGUMENT-SET!</span></code>. Определялась она
вот так:</p>

<pre>(<span class="special">define</span> (<span class="func">SHALLOW-ARGUMENT-SET!</span> <span class="var">j</span> <span class="var">m</span>)
  (<span class="special">lambda</span> ()
    (<span class="func">m</span>)
    (<span class="func">set-activation-frame-argument!</span> <span class="var">*env*</span> <span class="var">j</span> <span class="var">*val*</span>) ) )</pre>

<p>Чтобы разбить её на последовательность операций, введём вспомогательную функцию:</p>

<!--\indexC{SHALLOW-ARGUMENT-SET"!}-->
<!--\indexC{SET-SHALLOW-ARGUMENT"!}-->
<pre>(<span class="special">define</span> (<span class="func">SHALLOW-ARGUMENT-SET!</span> <span class="var">j</span> <span class="var">m</span>)
  (<span class="func">append</span> <span class="var">m</span> (<span class="func">SET-SHALLOW-ARGUMENT!</span> <span class="var">j</span>)) )

(<span class="special">define</span> (<span class="func">SET-SHALLOW-ARGUMENT!</span> <span class="var">j</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="func">set-activation-frame-argument!</span> <span class="var">*env*</span> <span class="var">j</span> <span class="var">*val*</span>))) )</pre>

<p>Главная функция только возвращает список необходимых операций, расположенных
в правильной последовательности. Вспомогательная же возвращает замыкание,
выполняющее простую операцию изменения записи активации.</p>


<h4 id="compilation/bytes/customize/sssect:lin-invocation"><span class="wrap"><span class="title">Линеаризация вызовов функций</span></span></h4>

<p><code><span class="func">REGULAR-CALL</span></code> является весьма показательной инструкцией в этом плане. Для её
линеаризации потребуются следующие машинные команды: <code><span class="func">PRESERVE-ENV</span></code>,
<code><span class="func">RESTORE-ENV</span></code>, <code><span class="func">PUSH-VALUE</span></code>, <code><span class="func">POP-FUNCTION</span></code> и <code><span class="func">FUNCTION-INVOKE</span></code>.</p>

<p>Вот их определения:</p>

<!--\indexC{REGULAR-CALL}-->
<!--\indexC{PUSH-VALUE}-->
<!--\indexC{POP-FUNCTION}-->
<!--\indexC{PRESERVE-ENV}-->
<!--\indexC{FUNCTION-INVOKE}-->
<!--\indexC{RESTORE-ENV}-->
<pre>(<span class="special">define</span> (<span class="func">REGULAR-CALL</span> <span class="var">m</span> <span class="var">m*</span>)
  (<span class="func">append</span> <span class="var">m</span> (<span class="func">PUSH-VALUE</span>)
          <span class="var">m*</span> (<span class="func">POP-FUNCTION</span>) (<span class="func">PRESERVE-ENV</span>)
             (<span class="func">FUNCTION-INVOKE</span>) (<span class="func">RESTORE-ENV</span>) ) )

(<span class="special">define</span> (<span class="func">PUSH-VALUE</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="func">stack-push</span> <span class="var">*val*</span>))) )

(<span class="special">define</span> (<span class="func">POP-FUNCTION</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="special">set!</span> <span class="var">*fun*</span> (<span class="func">stack-pop</span>)))) )

(<span class="special">define</span> (<span class="func">PRESERVE-ENV</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="func">stack-push</span> <span class="var">*env*</span>))) )

(<span class="special">define</span> (<span class="func">FUNCTION-INVOKE</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="func">invoke</span> <span class="var">*fun*</span>))) )

(<span class="special">define</span> (<span class="func">RESTORE-ENV</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">stack-pop</span>)))) )</pre>

<!--\indexR{исполнитель (\protect<code><span class="func">run</span></code>)}-->
<p>Как мы и хотели, результатом компиляции теперь является список элементарных
машинных инструкций. Его, однако, нельзя непосредственно исполнить, для этого
придётся написать исполнитель самостоятельно. Назовём его <code><span class="func">run</span></code>.</p>

<!--\indexC{run}-->
<pre>(<span class="special">define</span> (<span class="func">run</span>)
  (<span class="syntax">let</span> ((<span class="var">instruction</span> (<span class="func">car</span> <span class="var">*pc*</span>)))
    (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">cdr</span> <span class="var">*pc*</span>))
    (<span class="func">instruction</span>)
    (<span class="func">run</span>) ) )</pre>

<!--\indexE{pc@\protect<code><span class="func">*pc*</span></code>}-->
<!--\indexR{регистры!pc@\protect<code><span class="func">*pc*</span></code>}-->
<p>Полученный в результате компиляции список команд должен быть помещён
в регистр <code><span class="var">*pc*</span></code> — это наш счётчик команд (program counter).
Функция <code><span class="func">run</span></code> олицетворяет процессор виртуальной машины, который считывает
команду, сдвигает счётчик на следующую, исполняет считанную команду и повторяет
всё сначала. Кстати, именно поэтому все машинные инструкции представляются
замыканиями вида <code>(<span class="special">lambda</span> () ...)</code>.</p>


<h4 id="compilation/bytes/customize/sssect:lin-conditional"><span class="wrap"><span class="title">Линеаризация ветвлений</span></span></h4>

<!--\indexR{линеаризация!ветвлений}-->
<!--\indexR{переходы (jumps)!машинные инструкции}-->
<p>Способ линеаризации ветвления не так очевиден, ведь из него возможны два выхода.
Как же представить такое поведение последовательностью? Для этого мы
(пере)изобретём две важные машинные инструкции, позволяющие влиять на счётчик
команд: <code><span class="func">JUMP-FALSE</span></code> и <code><span class="func">GOTO</span></code>. Всем известная <code><span class="func">GOTO</span></code> выполняет
безусловный переход. В свою очередь, <code><span class="func">JUMP-FALSE</span></code> переход выполняет лишь
в случае, когда в регистре <code><span class="var">*val*</span></code> находится ложь. Обе эти инструкции
изменяют исключительно <code><span class="var">*pc*</span></code> и ничего другого.</p>

<!--\indexC{JUMP-FALSE}-->
<!--\indexC{GOTO}-->
<pre>(<span class="special">define</span> (<span class="func">JUMP-FALSE</span> <span class="var">i</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="special">if</span> (<span class="func">not</span> <span class="var">*val*</span>) (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">list-tail</span> <span class="var">*pc*</span> <span class="var">i</span>))))) )

(<span class="special">define</span> (<span class="func">GOTO</span> <span class="var">i</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">list-tail</span> <span class="var">*pc*</span> <span class="var">i</span>)))) )</pre>

<div class="image" id="compilation/bytes/customize/lin-conditional/pic:subj">
<img src="images/png06.png" alt="Расположение в памяти байт-кода оператора ветвления" style="width: 3.75in"/>
<span class="caption">Рис. 7.1. Линеаризованное ветвление.</span>
</div>

<p>С использованием этих двух инструкций ветвление линеаризуется следующим
образом. (На рисунке <a href="#compilation/bytes/customize/lin-conditional/pic:subj">7.1</a>
показано нагляднее.)</p>

<!--\indexC{ALTERNATIVE}-->
<pre>(<span class="special">define</span> (<span class="func">ALTERNATIVE</span> <span class="var">m1</span> <span class="var">m2</span> <span class="var">m3</span>)
  (<span class="func">append</span> <span class="var">m1</span> (<span class="func">JUMP-FALSE</span> (<span class="func">+</span> <span class="num">1</span> (<span class="func">length</span> <span class="var">m2</span>))) <span class="var">m2</span> (<span class="func">GOTO</span> (<span class="func">length</span> <span class="var">m3</span>)) <span class="var">m3</span>) )</pre>

<p>Условие вычисляется, а затем проверяется <code><span class="func">JUMP-FALSE</span></code>. Если оно оказалось
истиной, то выполняются инструкции, непосредственно следующие за
<code><span class="func">JUMP-FALSE</span></code>, после чего <code><span class="func">GOTO</span></code> перебрасывает управление через
альтернативную ветку к коду, следующему за ветвлением. Если же условие ложно,
то управление просто передаётся альтернативной ветке. Как видим, для реализации
ветвления нам пришлось опуститься до уровня ассемблера. Кстати, обратите
внимание, что переходы выполняются относительно текущего значения счётчика
команд, а не по абсолютным адресам.</p>


<h4 id="compilation/bytes/customize/sssect:lin-abstraction"><span class="wrap"><span class="title">Линеаризация абстракций</span></span></h4>

<!--\indexR{линеаризация!абстракций}-->
<!--\indexR{представление!замыканий!в машинном коде}-->
<p>Последней из инструкций с нетривиальной линеаризацией остаётся конструктор
замыканий. Проблема здесь в том, как разместить код собственно функции и код,
замыкающий текущее окружение. Причём функцию не надо сразу же исполнять после
создания замыкания. Для реализации такого поведения снова используются переходы
(см. рисунок <a href="#compilation/bytes/customize/lin-abstraction/pic:subj">7.2</a>). Вот
так создаются замыкания с переменной арностью:</p>

<!--\indexC{NARY-CLOSURE}-->
<!--\indexC{CREATE-CLOSURE}-->
<!--\indexC{PACK-FRAME"!}-->
<pre>(<span class="special">define</span> (<span class="func">NARY-CLOSURE</span> <span class="var">m+</span> <span class="var">arity</span>)
  (<span class="special">define</span> <span class="var">the-function</span>
    (<span class="func">append</span> (<span class="func">ARITY>=?</span> (<span class="func">+</span> <span class="var">arity</span> <span class="num">1</span>)) (<span class="func">PACK-FRAME!</span> <span class="var">arity</span>)
            (<span class="func">EXTEND-ENV</span>) <span class="var">m+</span> (<span class="func">RETURN</span>) ) )
  (<span class="func">append</span> (<span class="func">CREATE-CLOSURE</span> <span class="num">1</span>) (<span class="func">GOTO</span> (<span class="func">length</span> <span class="var">the-function</span>))
          <span class="var">the-function</span> ) )

(<span class="special">define</span> (<span class="func">CREATE-CLOSURE</span> <span class="var">offset</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">make-closure</span> (<span class="func">list-tail</span> <span class="var">*pc*</span> <span class="var">offset</span>)
                                             <span class="var">*env*</span> )))) )
(<span class="special">define</span> (<span class="func">PACK-FRAME!</span> <span class="var">arity</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="func">listify!</span> <span class="var">*val*</span> <span class="var">arity</span>))) )</pre>

<div class="image" id="compilation/bytes/customize/lin-abstraction/pic:subj">
<img src="images/png07.png" alt="Расположение в памяти байт-кода абстракции" style="width: 3.75in"/>
<span class="caption">Рис. 7.2. Линеаризованная абстракция.</span>
</div>

<p>Новая машинная инструкция <code><span class="func">CREATE-CLOSURE</span></code> создаёт замыкание с телом,
расположенным сразу же за <code><span class="func">GOTO</span></code>. Созданное замыкание кладётся в регистр
<code><span class="var">*val*</span></code>, после чего мы перепрыгиваем через его код к следующей инструкции
программы.</p>


<h3 id="compilation/bytes/ssect:call-proto"><span class="wrap"><span class="seq">7.1.4.</span><span class="title">Протокол вызова функций</span></span></h3>

<!--\indexR{протокол вызова функций}-->
<!--\indexR{функции!протокол вызова}-->
<p>Вызовы функций выполняются с помощью инструкций <code><span class="func">TR-REGULAR-CALL</span></code> и
<code><span class="func">REGULAR-CALL</span></code>, рассмотренных ранее.
<span class="see">[см. раздел <a href="#compilation/bytes/customize/sssect:lin-invocation">7.1.3</a>]</span>
Функция <code><span class="func">invoke</span></code> реализует протокол вызова функций:</p>

<!--\indexC{invoke}-->
<pre>(<span class="special">define</span> (<span class="func">invoke</span> <span class="var">f</span>)
  (<span class="syntax">cond</span> ((<span class="func">closure?</span> <span class="var">f</span>)
         (<span class="func">stack-push</span> <span class="var">*pc*</span>)
         (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">closure-closed-environment</span> <span class="var">f</span>))
         (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">closure-code</span> <span class="var">f</span>)) )
        ... ) )</pre>

<p>Перед вызовом функции в стек заталкивается адрес инструкции, следующей за
<code>(<span class="func">FUNCTION-INVOKE</span>)</code>. Затем извлекается сохранённое в замыкании окружение и
устанавливается в регистр <code><span class="var">*env*</span></code>. Наконец, в регистр <code><span class="var">*pc*</span></code> заносится
адрес первой инструкции тела замыкания, что передаёт ему управление. Текущее
окружение здесь не сохраняется: за управление ним отвечают непосредственно
<code><span class="func">REGULAR-CALL</span></code> и <code><span class="func">TR-REGULAR-CALL</span></code>.</p>

<p>Следующей инструкцией, исполненной <code><span class="func">run</span></code>, будет первая инструкция вызванной
функции. Она проверяет арность и, в случае успеха, расширяет текущее окружение
записью активации функции, в тот момент уже находящейся в регистре <code><span class="var">*val*</span></code>.
Теперь всё готово для исполнения тела функции. После его завершения в регистре
<code><span class="var">*val*</span></code> будет находиться значение, которое требуется передать тому, кто
вызывал эту функцию. Возврат управления выполняет инструкция <code><span class="func">RETURN</span></code>. Ей
надо лишь восстановить значение <code><span class="var">*pc*</span></code>, ранее сохранённое в стеке.</p>

<!--\indexC{RETURN}-->
<pre>(<span class="special">define</span> (<span class="func">RETURN</span>)
  (<span class="func">list</span> (<span class="special">lambda</span> () (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)))) )</pre>


<h4 id="compilation/bytes/sssect:jumps"><span class="wrap"><span class="title">О переходах</span></span></h4>

<!--\indexR{позиционно-независимый код}-->
<p>Если вы знакомы с программированием на языке ассемблера, то наверняка обратили
внимание на то, что все переходы выполняются только вперёд по коду. Более того,
переходы являются относительными, равно как и адресация при создании замыканий.
Следовательно, получаемый машинный код никак не зависит от своего фактического
расположения в памяти, он <em class="term">позиционно-независим</em>.</p>


<h2 id="compilation/sect:lang-and-target"><span class="wrap"><span class="seq">7.2.</span><span class="title">Язык и целевая машина</span></span></h2>

<!--\indexR{виртуальная машина!архитектура}-->
<p>Пришло время зафиксировать архитектуру целевой виртуальной машины, под которую
будут компилироваться программы, а также машинный язык, с помощью которого ей
можно управлять. Как видно из
рисунка <a href="#compilation/lang-and-target/pic:subj">7.3</a>, машина имеет пять регистров:
<code><span class="var">*env*</span></code>, <code><span class="var">*val*</span></code>, <code><span class="var">*fun*</span></code>, <code><span class="var">*arg1*</span></code> и <code><span class="var">*arg2*</span></code>, счётчик команд
<code><span class="var">*pc*</span></code>, а также стек.</p>

<div class="image" id="compilation/lang-and-target/pic:subj">
<img src="images/png08.png" alt="Архитектура целевой виртуальной машины" style="width: 5.19in"/>
<span class="caption">Рис. 7.3. Архитектура целевой виртуальной машины.</span>
</div>

<!--\indexC{FINISH}-->
<p>Машинный язык состоит из тридцати четырёх инструкций. Все они собраны
в таблице <a href="#ch7-vm-instruction-list">7.2</a>. Вдобавок к ранее
рассмотренным, мы ввели инструкцию <code><span class="func">FINISH</span></code>, которая завершает исполнение
программы (фактически, выходит из функции <code><span class="func">run</span></code>) и возвращает управление
тому, кто запустил нашу виртуальную машину.</p>

<!--\indexR{инструкции!простые и составные}-->
<p>Все двадцать пять инструкций-генераторов промежуточного языка можно разделить
на две группы: простые инструкции и составные. Простые инструкции имеют
непосредственные аналоги в машинном языке, они отмечены звёздочками
в таблице <a href="#ch7-vm-instruction-list">7.2</a>.
В противоположность им, шестнадцать составных инструкций промежуточного языка
определяются через оставшиеся двадцать пять машинных. Мы могли бы разбивать
инструкции на машинные команды более агрессивно, например, разделив
<code><span class="func">CHECKED-GLOBAL-REF</span></code> на <code><span class="func">GLOBAL-REF</span></code> и отдельную инструкцию, проверяющую,
действительно ли в <code><span class="var">*val*</span></code> лежит значение инициализированной переменной, но
это бы замедлило интерпретацию. Так что скорее наоборот, некоторые инструкции
имеет смысл объединить, например: <code><span class="func">POP-ARG2</span></code> используется только
в <code><span class="func">CALL3</span></code>, причём за <code><span class="func">POP-ARG2</span></code> всегда следует <code><span class="func">POP-ARG1</span></code>, поэтому
данную пару вполне можно превратить в отдельную инструкцию.</p>

<table id="ch7-vm-instruction-list" class="instruction-list">
<!--\indexR{виртуальная машина!язык}%-->
<!--\indexR{язык!машинный}%-->
<tbody>
<tr><td><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <i>j</i>)</code><sub>*</sub></td>
<td><code>(<span class="func">PREDEFINED</span> <i>i</i>)</code><sub>*</sub></td></tr>
<tr><td><code>(<span class="func">DEEP-ARGUMENT-REF</span> <i>i</i> <i>j</i>)</code><sub>*</sub></td>
<td><code>(<span class="func">SET-SHALLOW-ARGUMENT!</span> <i>j</i>)</code></td></tr>
<tr><td><code>(<span class="func">SET-DEEP-ARGUMENT!</span> <i>i</i> <i>j</i>)</code></td>
<td><code>(<span class="func">GLOBAL-REF</span> <i>i</i>)</code><sub>*</sub></td></tr>
<tr><td><code>(<span class="func">CHECKED-GLOBAL-REF</span> <i>i</i>)</code><sub>*</sub></td>
<td><code>(<span class="func">SET-GLOBAL!</span> <i>i</i>)</code></td></tr>
<tr><td><code>(<span class="func">CONSTANT</span> <i>v</i>)</code><sub>*</sub></td>
<td><code>(<span class="func">JUMP-FALSE</span> <i>смещение</i>)</code></td></tr>
<tr><td><code>(<span class="func">GOTO</span> <i>смещение</i>)</code></td>
<td><code>(<span class="func">EXTEND-ENV</span>)</code></td></tr>
<tr><td><code>(<span class="func">UNLINK-ENV</span>)</code></td>
<td><code>(<span class="func">CALL0</span> <i>адрес</i>)</code><sub>*</sub></td></tr>
<tr><td><code>(<span class="func">INVOKE1</span> <i>адрес</i>)</code></td>
<td><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td><code>(<span class="func">INVOKE2</span> <i>адрес</i>)</code></td>
<td><code>(<span class="func">POP-ARG1</span>)</code></td></tr>
<tr><td><code>(<span class="func">INVOKE3</span> <i>адрес</i>)</code></td>
<td><code>(<span class="func">POP-ARG2</span>)</code></td></tr>
<tr><td><code>(<span class="func">CREATE-CLOSURE</span> <i>смещение</i>)</code></td>
<td><code>(<span class="func">ARITY=?</span> <i>арность</i><span class="normal">+1</span>)</code></td></tr>
<tr><td><code>(<span class="func">RETURN</span>)</code></td>
<td><code>(<span class="func">ARITY&gt;=?</span> <i>арность</i><span class="normal">+1</span>)</code></td></tr>
<tr><td><code>(<span class="func">PACK-FRAME!</span> <i>арность</i>)</code></td>
<td><code>(<span class="func">POP-FUNCTION</span>)</code></td></tr>
<tr><td><code>(<span class="func">FUNCTION-INVOKE</span>)</code></td>
<td><code>(<span class="func">PRESERVE-ENV</span>)</code></td></tr>
<tr><td><code>(<span class="func">RESTORE-ENV</span>)</code></td>
<td><code>(<span class="func">POP-FRAME!</span> <i>индекс</i>)</code></td></tr>
<tr><td><code>(<span class="func">POP-CONS-FRAME!</span> <i>арность</i>)</code></td>
<td><code>(<span class="func">ALLOCATE-FRAME</span> <i>размер</i>)</code><sub>*</sub></td></tr>
<tr><td><code>(<span class="func">ALLOCATE-DOTTED-FRAME</span> <i>арность</i>)</code><sub>*</sub></td>
<td><code>(<span class="func">FINISH</span>)</code></td></tr>
</tbody></table>
<span class="caption">Таблица 7.2. Символьная форма машинных инструкций.</span>

<p>Тривиальной части составных инструкций мы не касались, но их определения
на машинном языке всё же стоит привести. Они собраны ниже, без каких-либо
пояснений. Некоторые из машинных инструкций из
таблицы <a href="#ch7-vm-instruction-list">7.2</a> тоже не были
определены, ими мы займёмся чуть позже.</p>

<!--\indexC{DEEP-ARGUMENT-SET"!}-->
<!--\indexC{GLOBAL-SET"!}-->
<!--\indexC{SEQUENCE}-->
<!--\indexC{TR-FIX-LET}-->
<!--\indexC{FIX-LET}-->
<!--\indexC*{CALL0}{CALL\protect<i>n</i>}-->
<!--\indexC{FIX-CLOSURE}-->
<!--\indexC{TR-REGULAR-CALL}-->
<!--\indexC{STORE-ARGUMENT}-->
<!--\indexC{CONS-ARGUMENT}-->
<pre>(<span class="special">define</span> (<span class="func">DEEP-ARGUMENT-SET!</span> <span class="var">i</span> <span class="var">j</span> <span class="var">m</span>)
  (<span class="func">append</span> <span class="var">m</span> (<span class="func">SET-DEEP-ARGUMENT!</span> <span class="var">i</span> <span class="var">j</span>)) )

(<span class="special">define</span> (<span class="func">GLOBAL-SET!</span> <span class="var">i</span> <span class="var">m</span>)
  (<span class="func">append</span> <span class="var">m</span> (<span class="func">SET-GLOBAL!</span> <span class="var">i</span>)) )

(<span class="special">define</span> (<span class="func">SEQUENCE</span> <span class="var">m</span> <span class="var">m+</span>)
  (<span class="func">append</span> <span class="var">m</span> <span class="var">m+</span>) )

(<span class="special">define</span> (<span class="func">TR-FIX-LET</span> <span class="var">m*</span> <span class="var">m+</span>)
  (<span class="func">append</span> <span class="var">m*</span> (<span class="func">EXTEND-ENV</span>) <span class="var">m+</span>) )

(<span class="special">define</span> (<span class="func">FIX-LET</span> <span class="var">m*</span> <span class="var">m+</span>)
  (<span class="func">append</span> <span class="var">m*</span> (<span class="func">EXTEND-ENV</span>)
          <span class="var">m+</span> (<span class="func">UNLINK-ENV</span>) ) )

(<span class="special">define</span> (<span class="func">CALL1</span> <span class="var">address</span> <span class="var">m1</span>)
  (<span class="func">append</span> <span class="var">m1</span> (<span class="func">INVOKE1</span> <span class="var">address</span>)) )

(<span class="special">define</span> (<span class="func">CALL2</span> <span class="var">address</span> <span class="var">m1</span> <span class="var">m2</span>)
  (<span class="func">append</span> <span class="var">m1</span> (<span class="func">PUSH-VALUE</span>)
          <span class="var">m2</span> (<span class="func">POP-ARG1</span>)
          (<span class="func">INVOKE2</span> <span class="var">address</span>) ) )

(<span class="special">define</span> (<span class="func">CALL3</span> <span class="var">address</span> <span class="var">m1</span> <span class="var">m2</span> <span class="var">m3</span>)
  (<span class="func">append</span> <span class="var">m1</span> (<span class="func">PUSH-VALUE</span>)
          <span class="var">m2</span> (<span class="func">PUSH-VALUE</span>)
          <span class="var">m3</span> (<span class="func">POP-ARG2</span>) (<span class="func">POP-ARG1</span>)
          (<span class="func">INVOKE3</span> <span class="var">address</span>) ) )

(<span class="special">define</span> (<span class="func">FIX-CLOSURE</span> <span class="var">m+</span> <span class="var">arity</span>)
  (<span class="special">define</span> <span class="var">the-function</span>
    (<span class="func">append</span> (<span class="func">ARITY=?</span> (<span class="func">+</span> <span class="var">arity</span> <span class="num">1</span>))
            (<span class="func">EXTEND-ENV</span>) <span class="var">m+</span>
            (<span class="func">RETURN</span>) ) )
  (<span class="func">append</span> (<span class="func">CREATE-CLOSURE</span> <span class="num">1</span>)
          (<span class="func">GOTO</span> (<span class="func">length</span> <span class="var">the-function</span>))
          <span class="var">the-function</span> ) )

(<span class="special">define</span> (<span class="func">TR-REGULAR-CALL</span> <span class="var">m</span> <span class="var">m*</span>)
  (<span class="func">append</span> <span class="var">m</span> (<span class="func">PUSH-VALUE</span>)
          <span class="var">m*</span> (<span class="func">POP-FUNCTION</span>)
          (<span class="func">FUNCTION-INVOKE</span>) ) )

(<span class="special">define</span> (<span class="func">STORE-ARGUMENT</span> <span class="var">m</span> <span class="var">m*</span> <span class="var">index</span>)
  (<span class="func">append</span> <span class="var">m</span> (<span class="func">PUSH-VALUE</span>)
          <span class="var">m*</span> (<span class="func">POP-FRAME!</span> <span class="var">index</span>) ) )

(<span class="special">define</span> (<span class="func">CONS-ARGUMENT</span> <span class="var">m</span> <span class="var">m*</span> <span class="var">arity</span>)
  (<span class="func">append</span> <span class="var">m</span> (<span class="func">PUSH-VALUE</span>)
          <span class="var">m*</span> (<span class="func">POP-CONS-FRAME!</span> <span class="var">arity</span>) ) )</pre>

<!--\indexR{однопроходная компиляция}-->
<!--\indexR{компиляция!однопроходная}-->
<!--\indexR{линеаризация!кодогенерации}-->
<p id="compilation/lang-and-target/par:slowpoke">Вызовы
<code><span class="func">append</span></code>, коими кишат наши определения, довольно ощутимо замедляют
кодогенерацию. Хорошим решением будет собирать машинные инструкции
в последовательность за один проход. Именно так мы и поступим при разработке
компилятора в Си. <span class="see">[см. раздел <a href="ch10_compiling_into_c.xhtml#cc/gen/ssect:exprs">10.8.4</a>]</span> Для реализации подобного подхода
потребуется вдобавок к линеаризации самого машинного кода также линеаризовать и
его генераторы. Например, <code><span class="func">CALL2</span></code>
должна работать в такой последовательности:</p>

<ol>
  <li>сгенерировать и вывести код <code><span class="var">m1</span></code>;</li>
  <li>вывести код <code>(<span class="func">PUSH-VALUE</span>)</code>;</li>
  <li>сгенерировать и вывести код <code><span class="var">m2</span></code>;</li>
  <li>вывести код <code>(<span class="func">POP-ARG1</span>)</code>;</li>
  <li>вывести код <code>(<span class="func">INVOKE2</span> <i>адрес</i>)</code>.</li>
</ol>

<!--\indexCS{GOTO}{правки задним числом}-->
<!--\indexCS{JUMP-FALSE}{правки задним числом}-->
<!--\indexE{backpatching}-->
<p id="compilation/lang-and-target/par:backtracking">Подобные изменения легко
сделать всюду, кроме <code><span class="func">GOTO</span></code> и
<code><span class="func">JUMP-FALSE</span></code>, так
как теперь не получится заранее вычислить смещения при генерации кода для
<code><span class="func">ALTERNATIVE</span></code>, <code><span class="func">FIX-CLOSURE</span></code> и <code><span class="func">NARY-CLOSURE</span></code>. Это затруднение
можно решить правкой смещений задним числом (такой приём называется
<em class="term">backpatching</em>). Например, для <code><span class="func">FIX-CLOSURE</span></code> следует делать так:</p>

<ol>
  <li>вывести инструкцию <code><span class="func">CREATE-CLOSURE</span></code>;</li>

  <li>вывести инструкцию <code><span class="func">GOTO</span></code>,
    но без смещения, запомнив при этом текущее состояние счётчика команд;</li>

  <li>сгенерировать и вывести код тела функции;</li>

  <li>зная текущее значение счётчика команд и помня сохранённое ранее,
    вычислить величину смещения для <code><span class="func">GOTO</span></code>;</li>

  <li>записать это число на зарезервированное<a class="footref"
    href="zz_footnotes.xhtml#foot7.1"><sup>1</sup></a> внутри
    <code><span class="func">GOTO</span></code> место.</li>
</ol>

<p>В результате получится более аккуратная и эффективная процедура генерации кода,
чем есть сейчас, но пока мы всё же оставим текущий вариант из-за его простоты.</p>


<h3 id="compilation/lang-and-target/ssect:disassembly"><span class="wrap"><span class="seq">7.2.1.</span><span class="title">Дизассемблирование</span></span></h3>

<p>В <a href="#compilation/par:disasm">начале этой главы</a> была показана промежуточная
форма следующей небольшой программки:</p>

<!--\indexC{fact}-->
<pre>((<span class="special">lambda</span> (<span class="var">fact</span>) (<span class="func">fact</span> <span class="num">5</span> <span class="var">fact</span> (<span class="special">lambda</span> (<span class="var">x</span>) <span class="var">x</span>)))
 (<span class="special">lambda</span> (<span class="var">n</span> <span class="var">f</span> <span class="var">k</span>) (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">k</span> <span class="num">1</span>)
                     (<span class="func">f</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">f</span> (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>)))) )) )</pre>

<p>Теперь, наконец, мы сможем увидеть, как она выглядит на настоящем машинном
языке. Сложно не заметить сходство таблицы <a href="#ch7-disasm-1">7.3</a> с ассемблерным
листингом.</p>

<table id="ch7-disasm-1" class="disasm">
<tbody>
<tr><td class="col1"><code>(<span class="func">CREATE-CLOSURE</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">INVOKE2</span> <span class="hash">#&lt;*&gt;</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">GOTO</span> <span class="num">82</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">ARITY=?</span> <span class="num">4</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME</span> <span class="num">1</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">EXTEND-ENV</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FUNCTION</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">FUNCTION-INVOKE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CONSTANT</span> <span class="num">0</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-ARG1</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">INVOKE2</span> <span class="hash">#&lt;=&gt;</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME</span> <span class="num">3</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">JUMP-FALSE</span> <span class="num">13</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">1</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CONSTANT</span> <span class="num">1</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FUNCTION</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">FUNCTION-INVOKE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">ALLOCATE-FRAME</span> <span class="num">1</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-FRAME!</span> <span class="num">0</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-FUNCTION</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME</span> <span class="num">1</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">FUNCTION-INVOKE</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">GOTO</span> <span class="num">54</span>)</code></td>
    <td class="col2"><code>(<span class="func">EXTEND-ENV</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">1</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)</code></td>
    <td class="col2"><code>(<span class="func">CONSTANT</span> <span class="num">5</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CONSTANT</span> <span class="num">1</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-ARG1</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">INVOKE2</span> <span class="hash">#&lt;-&gt;</span>)</code></td>
    <td class="col2"><code>(<span class="func">CREATE-CLOSURE</span> <span class="num">2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">GOTO</span> <span class="num">6</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">1</span>)</code></td>
    <td class="col2"><code>(<span class="func">ARITY=?</span> <span class="num">2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">EXTEND-ENV</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CREATE-CLOSURE</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">GOTO</span> <span class="num">24</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">ARITY=?</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">EXTEND-ENV</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME</span> <span class="num">3</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">DEEP-ARGUMENT-REF</span> <span class="num">1</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">1</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">DEEP-ARGUMENT-REF</span> <span class="num">1</span> <span class="num">0</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!</span> <span class="num">0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FUNCTION</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="num">0</span>)</code></td>
    <td class="col2"><code>(<span class="func">FUNCTION-INVOKE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-ARG1</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
</tbody></table>
<span class="caption">Таблица 7.3. Результат компиляции.</span>


<h2 id="compilation/sect:coding"><span class="wrap"><span class="seq">7.3.</span><span class="title">Кодирование инструкций</span></span></h2>

<!--\indexR{байт-код}-->
<p>Почти на каждой странице этой главы упоминаются байты, но до сих пор мы
не видели ни одного из них живьём. К счастью, чтобы они появились, достаточно
лишь по-другому понимать инструкции
таблицы <a href="#ch7-vm-instruction-list">7.2</a>: теперь это
не непосредственно исполнимые команды, а генераторы последовательностей байтов
— исходного кода для другой, более быстрой функции <code><span class="func">run</span></code>. Сейчас мы
сконцентрируемся именно на этом аспекте байт-кода: его компактности и скорости
интерпретации.</p>

<!--\indexR{макросы!применения}-->
<p>Байт-кодирование требует особой осторожности: за каждой инструкцией должно быть
закреплено уникальное число, по которому определяется её поведение внутри
<code><span class="func">run</span></code>, длина операндов этой инструкции, а также многое другое. Поэтому, чтобы
в процессе ничего не напутать, инструкции будут определяться с помощью макроса
<code><span class="syntax">define-instruction</span></code>. При этом предполагается, что все определения машинных
инструкций на самом деле обёрнуты в макрос <code><span class="syntax">define-instruction-set</span></code>, который
кроме собственно формы <code><span class="syntax">define-instruction</span></code> определяет также несколько
вспомогательных функций.</p>

<!--\indexC{define-instruction-set}-->
<!--\indexC{run}-->
<!--\indexC{instruction-size}-->
<!--\indexC{instruction-decode}-->
<!--\indexC{run-clause}-->
<!--\indexC{size-clause}-->
<pre>(<span class="special">define-syntax</span> <span class="var">define-instruction-set</span>
  (<span class="syntax">syntax-rules</span> (<span class="syntax">define-instruction</span>)
    ((<span class="syntax">define-instruction-set</span>
       (<span class="syntax">define-instruction</span> (<span class="var">name</span> . <span class="var">args</span>) <span class="var">n</span> . <span class="var">body</span>) ... )
     (<span class="special">begin</span>
       (<span class="special">define</span> (<span class="func">run</span>)
         (<span class="syntax">let</span> ((<span class="var">instruction</span> (<span class="func">fetch-byte</span>)))
           (<span class="syntax">case</span> <span class="var">instruction</span>
             ((<span class="var">n</span>) (<span class="syntax">run-clause</span> <span class="var">args</span> <span class="var">body</span>)) ... ) )
         (<span class="func">run</span>) )

       (<span class="special">define</span> (<span class="func">instruction-size</span> <span class="var">code</span> <span class="var">pc</span>)
         (<span class="syntax">let</span> ((<span class="var">instruction</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
           (<span class="syntax">case</span> <span class="var">instruction</span>
             ((<span class="var">n</span>) (<span class="syntax">size-clause</span> <span class="var">args</span>)) ... ) ) )

       (<span class="special">define</span> (<span class="func">instruction-decode</span> <span class="var">code</span> <span class="var">pc</span>)
         (<span class="special">define</span> (<span class="func">fetch-byte</span>)
           (<span class="syntax">let</span> ((<span class="var">byte</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
             (<span class="special">set!</span> <span class="var">pc</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>))
             <span class="var">byte</span> ) )
         (<span class="special">let-syntax</span>
             ((<span class="var">decode-clause</span>
               (<span class="syntax">syntax-rules</span> ()
                 ((<span class="syntax">decode-clause</span> <span class="var">iname</span> ())
                  '(<span class="var">iname</span>) )
                 ((<span class="syntax">decode-clause</span> <span class="var">iname</span> (<span class="var">a</span>))
                  (<span class="syntax">let</span> ((<span class="var">a</span> (<span class="func">fetch-byte</span>)))
                    (<span class="func">list</span> '<span class="var">iname</span> <span class="var">a</span>) ) )
                 ((<span class="syntax">decode-clause</span> <span class="var">iname</span> (<span class="var">a</span> <span class="var">b</span>))
                  (<span class="syntax">let*</span> ((<span class="var">a</span> (<span class="func">fetch-byte</span>))
                         (<span class="var">b</span> (<span class="func">fetch-byte</span>)) )
                    (<span class="func">list</span> '<span class="var">iname</span> <span class="var">a</span> <span class="var">b</span>) ) ) ) ))
           (<span class="syntax">let</span> ((<span class="var">instruction</span> (<span class="func">fetch-byte</span>)))
             (<span class="syntax">case</span> <span class="var">instruction</span>
               ((<span class="var">n</span>) (<span class="syntax">decode-clause</span> <span class="var">name</span> <span class="var">args</span>)) ... ) ) ) ) ) ) ) )

(<span class="special">define-syntax</span> <span class="var">run-clause</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">run-clause</span> () <span class="var">body</span>)
     (<span class="special">begin</span> . <span class="var">body</span>) )
    ((<span class="syntax">run-clause</span> (<span class="var">a</span>) <span class="var">body</span>)
     (<span class="syntax">let</span> ((<span class="var">a</span> (<span class="func">fetch-byte</span>)))
       . <span class="var">body</span> ) )
    ((<span class="syntax">run-clause</span> (<span class="var">a</span> <span class="var">b</span>) <span class="var">body</span>)
     (<span class="syntax">let*</span> ((<span class="var">a</span> (<span class="func">fetch-byte</span>))
            (<span class="var">b</span> (<span class="func">fetch-byte</span>)) )
       . <span class="var">body</span> ) ) ) )

(<span class="special">define-syntax</span> <span class="var">size-clause</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">size-clause</span> ())    <span class="num">1</span>)
    ((<span class="syntax">size-clause</span> (<span class="var">a</span>))   <span class="num">2</span>)
    ((<span class="syntax">size-clause</span> (<span class="var">a</span> <span class="var">b</span>)) <span class="num">3</span>) ) )</pre>

<p>Макрос <code><span class="syntax">define-instruction</span></code> одновременно определяет сразу три функции:
функцию <code><span class="func">run</span></code>, исполняющую байт-коды; функцию <code><span class="func">instruction-size</span></code>,
возвращающую размер инструкций; и функцию <code><span class="func">instruction-decode</span></code>,
переводящую байт-код обратно в символьную форму. Очевидно,
<code><span class="func">instruction-decode</span></code>, будет весьма полезной при отладке. Рассмотрим пример:</p>

<pre>(<span class="syntax">define-instruction</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="var">j</span>) <span class="num">5</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*env*</span> <span class="var">j</span>)) )</pre>

<p>Эта форма добавляет в определение <code><span class="func">run</span></code> обработку инструкции, кодируемой
числом <code><span class="func">5</span></code>:</p>

<pre>(<span class="special">define</span> (<span class="func">run</span>)
  (<span class="syntax">let</span> ((<span class="var">instruction</span> (<span class="func">fetch-byte</span>)))
    (<span class="syntax">case</span> <span class="var">instruction</span>
      ...
      ((<span class="num">5</span>) (<span class="syntax">let</span> ((<span class="var">j</span> (<span class="func">fetch-byte</span>)))
             (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*env*</span> <span class="var">j</span>)) ))
      ... ) )
  (<span class="func">run</span>) )</pre>

<!--\indexC{fetch-byte}-->
<p>Функция <code><span class="func">fetch-byte</span></code> используется для извлечения операндов инструкции из
потока байтов. Она очень просто определяется и имеет один побочный эффект: сдвиг
<code><span class="var">*pc*</span></code> на одну позицию вперёд.</p>

<pre>(<span class="special">define</span> (<span class="func">fetch-byte</span>)
  (<span class="syntax">let</span> ((<span class="var">byte</span> (<span class="func">vector-ref</span> <span class="var">*code*</span> <span class="var">*pc*</span>)))
    (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">*pc*</span>))
    <span class="var">byte</span> ) )</pre>

<!--\indexR{счётчик команд}-->
<p>Также <code><span class="func">fetch-byte</span></code> используется функцией <code><span class="func">run</span></code> для считывания следующей
инструкции. Кстати, обратите внимание, что счётчик команд всегда указывает на
<em>следующую</em> инструкцию, а не на текущую исполняемую. Точно такое же решение
применяется и во многих настоящих процессорах.</p>

<!--\indexCS{case}{таблица переходов}-->
<p>Для достижения действительно высокой скорости интерпретации (другими словами,
чтобы получить быструю <code><span class="func">run</span></code>) следует уделить особое внимание используемой
здесь форме <code><span class="syntax">case</span></code>. Благодаря тому, что дискриминант <code><span class="syntax">case</span></code> может быть
только числом от 0 до 255, становится возможным реализовать <code><span class="syntax">case</span></code> через
таблицу переходов, что позволит выполнять выбор нужной ветви за постоянное
время. Если же <code><span class="syntax">case</span></code> раскрывается в цепочку <code>(<span class="special">if</span> (<span class="func">eqv?</span> ...) ...)</code>, то
выбор выполняется за линейное время — прощай, производительность! Лишь
некоторые из компиляторов Лиспа умеют выполнять такую оптимизацию автоматически
(среди них Sqil <span class="cite">[<a href="z1_bibliography.xhtml#sen91">Sén91</a>]</span> и Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#ser93">Ser93</a>]</span>).</p>

<p><code><span class="syntax">define-instruction</span></code> также принимает участие в определении функции
<code><span class="func">instruction-size</span></code>: туда она добавляет информацию о том, что инструкция
<code><span class="func">SHALLOW-ARGUMENT-REF</span></code> занимает два байта. Аналогично, здесь <code><span class="syntax">case</span></code> можно
заменить вектором, хранящим те же самые числа.</p>

<pre>(<span class="special">define</span> (<span class="func">instruction-size</span> <span class="var">code</span> <span class="var">pc</span>)
  (<span class="syntax">let</span> ((<span class="var">instruction</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
    (<span class="syntax">case</span> <span class="var">instruction</span>
      ...
      ((<span class="num">5</span>) <span class="num">2</span>)
      ... ) ) )</pre>

<!--\indexC{fetch-byte}-->
<p>Наконец, <code><span class="syntax">define-instruction</span></code> добавляет в <code><span class="func">instruction-decode</span></code>,
ветку для обработки инструкции <code><span class="func">SHALLOW-ARGUMENT-REF</span></code>. Функция
<code><span class="func">instruction-decode</span></code> использует свою личную реализацию <code><span class="func">fetch-byte</span></code>,
чтобы вести себя подобно <code><span class="func">run</span></code>, но не влиять на глобальный счётчик команд.</p>

<pre>(<span class="special">define</span> (<span class="func">instruction-decode</span> <span class="var">code</span> <span class="var">pc</span>)
  (<span class="special">define</span> (<span class="func">fetch-byte</span>)
    (<span class="syntax">let</span> ((<span class="var">byte</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
      (<span class="special">set!</span> <span class="var">pc</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>))
      <span class="var">byte</span> ) )
  (<span class="syntax">let</span> ((<span class="var">instruction</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
    (<span class="syntax">case</span> <span class="var">instruction</span>
      ...
      ((<span class="num">5</span>) (<span class="syntax">let</span> ((<span class="var">j</span> (<span class="func">fetch-byte</span>)))
             (<span class="func">list</span> '<span class="var">SHALLOW-ARGUMENT-REF</span> <span class="var">j</span>) ))
      ... ) ) )</pre>


<h2 id="compilation/sect:instructions"><span class="wrap"><span class="seq">7.4.</span><span class="title">Инструкции</span></span></h2>

<!--\indexR{инструкции!распределение арности}-->
<!--\indexR{арность}-->
<!--\indexR{байт-код!использование излишков}-->
<!--\indexR{специализация!машинных инструкций}-->
<p>Всего существует 256 возможных кодов инструкций, мы же используем только 34 из
них. Настало время задействовать эти резервы; вспомните, как мы предлагали
объединять инструкции, которые часто используются вместе. Кроме того очевиден
<span class="cite">[<a href="z1_bibliography.xhtml#cha80">Cha80</a>]</span> тот факт, что большинство функций имеет небольшое число аргументов.
Действительно, достаточно лишь посмотреть на функции, использованные в данной
книге. Их анализ показывает следующие результаты: лишь 16 функций имеют
переменную арность; распределение арности остальных 1988 приведено
в таблице <a href="#ch7-arity-probs">7.4</a>.</p>

<table id="ch7-arity-probs">
<thead>
<tr><td class="desc">арность</td>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
  <td>5</td><td>6</td><td>7</td><td>8</td></tr>
</thead>
<tbody>
<tr><td class="desc">доля, %</td>
  <td>35</td><td>30</td><td>18</td><td>9</td><td>4</td>
  <td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td class="desc">накопление, %</td>
  <td>35</td><td>66</td><td>84 </td><td>93</td><td>97</td>
  <td>99</td><td>99</td><td>99</td><td>100</td></tr>
</tbody>
</table>
<span class="caption">Таблица 7.4. Распределение функций по количеству аргументов.</span>

<p>Как видим, подавляющее большинство функций имеет не более четырёх аргументов.
При обобщении этих результатов следует учесть, что настолько большие числа для
нулевой арности получены в основном благодаря шестой главе. Итого, однозначно
имеет смысл оптимизировать вызовы функций, принимающих менее четырёх аргументов.
Этим мы и займёмся, используя избыточные коды инструкций для создания
специализированных вариантов.</p>


<h3 id="compilation/instructions/ssect:locals"><span class="wrap"><span class="seq">7.4.1.</span><span class="title">Локальные переменные</span></span></h3>

<!--\indexC{LAMBDA-PARAMETERS-LIMIT}-->
<!--\indexC{check-byte}-->
<!--\indexR{функции!максимальное количество аргументов}-->
<p>Пожалуй, давайте начнём с <code><span class="func">SHALLOW-ARGUMENT-REF</span></code>. Эта инструкция имеет один
операнд: <span class="math"><span class="ord var">j</span></span>, а её действие заключается в том, что регистр <code><span class="var">*val*</span></code> получает
значение <span class="math"><span class="ord var">j</span></span>-й локальной переменной текущей записи активации, хранящейся
в регистре <code><span class="var">*env*</span></code>. Здесь можно ввести специализации для случаев <span class="math"><span class="ord var">j</span><span class="rel">=</span><span class="ord num">0</span><span class="punct">,</span><span class="ord num">1</span><span class="punct">,</span><span class="ord num">2</span><span class="punct">,</span><span class="ord num">3</span></span>, сделав каждый из них отдельной инструкцией со своим кодом. Также для
простоты можно ввести ограничение<a class="footref" href="zz_footnotes.xhtml#foot7.2"><sup>2</sup></a> в 256 аргументов
функции — это позволит всегда кодировать индекс аргумента одним-единственным
байтом. Функция <code><span class="func">check-byte</span></code><a class="footref" href="zz_footnotes.xhtml#foot7.3"><sup>3</sup></a> убеждается в соблюдении этого
ограничения. Итак, вот определение <code><span class="func">SHALLOW-ARGUMENT-REF</span></code>. Эта инструкция
является генератором байт-кодов — она возвращает список<a class="footref" href="zz_footnotes.xhtml#foot7.4"><sup>4</sup></a> байтов,
соответствующих кодируемой инструкции. Этот список состоит из одного или двух
байтов, в зависимости от операнда.</p>

<!--\indexCS{SHALLOW-ARGUMENT-REF}{специализация}-->
<!--\indexC{check-byte}-->
<pre>(<span class="special">define</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="var">j</span>)
  (<span class="func">check-byte</span> <span class="var">j</span>)
  (<span class="syntax">case</span> <span class="var">j</span>
    ((<span class="num">0</span> <span class="num">1</span> <span class="num">2</span> <span class="num">3</span>) (<span class="func">list</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">j</span>)))
    (<span class="syntax">else</span>      (<span class="func">list</span> <span class="num">5</span> <span class="var">j</span>)) ) )

(<span class="special">define</span> (<span class="func">check-byte</span> <span class="var">j</span>)
  (<span class="syntax">unless</span> (<span class="func">&lt;=</span> <span class="num">0</span> <span class="var">j</span> <span class="num">255</span>)
    (<span class="func">static-wrong</span> <span class="string">"Cannot pack a number within a byte"</span> <span class="var">j</span>) ) )</pre>

<p>А вот определения собственно пяти<a class="footref" href="zz_footnotes.xhtml#foot7.5"><sup>5</sup></a> специализаций:</p>

<pre>(<span class="syntax">define-instruction</span> (<span class="func">SHALLOW-ARGUMENT-REF0</span>) <span class="num">1</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*env*</span> <span class="num">0</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">SHALLOW-ARGUMENT-REF1</span>) <span class="num">2</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*env*</span> <span class="num">1</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">SHALLOW-ARGUMENT-REF2</span>) <span class="num">3</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*env*</span> <span class="num">2</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">SHALLOW-ARGUMENT-REF3</span>) <span class="num">4</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*env*</span> <span class="num">3</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">SHALLOW-ARGUMENT-REF</span> <span class="var">j</span>) <span class="num">5</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*env*</span> <span class="var">j</span>)) )</pre>

<p><code><span class="func">SET-SHALLOW-ARGUMENT!</span></code> тоже работает с локальными переменными, так что
определяется аналогично. (Пропущенные здесь специализации легко определить
самостоятельно.)</p>

<!--\indexCS{SET-SHALLOW-ARGUMENT"!}{специализация}-->
<pre>(<span class="special">define</span> (<span class="func">SET-SHALLOW-ARGUMENT!</span> <span class="var">j</span>)
  (<span class="syntax">case</span> <span class="var">j</span>
    ((<span class="num">0</span> <span class="num">1</span> <span class="num">2</span> <span class="num">3</span>) (<span class="func">list</span> (<span class="func">+</span> <span class="num">21</span> <span class="var">j</span>)))
    (<span class="syntax">else</span>      (<span class="func">list</span> <span class="num">25</span> <span class="var">j</span>)) ) )

(<span class="syntax">define-instruction</span> (<span class="func">SET-SHALLOW-ARGUMENT!2</span>) <span class="num">23</span>
  (<span class="func">set-activation-frame-argument!</span> <span class="var">*env*</span> <span class="num">2</span> <span class="var">*val*</span>) )
(<span class="syntax">define-instruction</span> (<span class="func">SET-SHALLOW-ARGUMENT!</span> <span class="var">j</span>) <span class="num">25</span>
  (<span class="func">set-activation-frame-argument!</span> <span class="var">*env*</span> <span class="var">j</span> <span class="var">*val*</span>) )</pre>

<!--\indexCS{DEEP-ARGUMENT-REF}{специализация}-->
<!--\indexCS{SET-DEEP-ARGUMENT"!}{специализация}-->
<p>Что касается свободных переменных, то мы предполагаем<a class="footref" href="zz_footnotes.xhtml#foot7.6"><sup>6</sup></a>, что их индексы равновероятны, поэтому для них специализаций
не будет:</p>

<pre>(<span class="special">define</span> (<span class="func">DEEP-ARGUMENT-REF</span> <span class="var">i</span> <span class="var">j</span>) (<span class="func">list</span> <span class="num">6</span> <span class="var">i</span> <span class="var">j</span>))
(<span class="special">define</span> (<span class="func">SET-DEEP-ARGUMENT!</span> <span class="var">i</span> <span class="var">j</span>) (<span class="func">list</span> <span class="num">26</span> <span class="var">i</span> <span class="var">j</span>))

(<span class="syntax">define-instruction</span> (<span class="func">DEEP-ARGUMENT-REF</span> <span class="var">i</span> <span class="var">j</span>) <span class="num">6</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">deep-fetch</span> <span class="var">*env*</span> <span class="var">i</span> <span class="var">j</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">SET-DEEP-ARGUMENT!</span> <span class="var">i</span> <span class="var">j</span>) <span class="num">26</span>
  (<span class="func">deep-update!</span> <span class="var">*env*</span> <span class="var">i</span> <span class="var">j</span> <span class="var">*val*</span>) )</pre>


<h3 id="compilation/instructions/ssect:globals"><span class="wrap"><span class="seq">7.4.2.</span><span class="title">Глобальные переменные</span></span></h3>

<!--\indexR{глобальные переменные}-->
<!--\indexR{переменные!глобальные}-->
<!--\indexR{представление!глобальных переменных}-->
<!--\indexR{глобальное окружение!машинная реализация}-->
<!--\indexR{окружение!глобальное}-->
<p>Про распределение глобальных изменяемых переменных, определяемых пользователем,
виртуальная машина ничего знать не может в принципе, так что они тоже будут
кодироваться без специализаций. Для простоты предположим, что глобальных
переменных может быть не более 256, что позволит закодировать их адрес одним
байтом. Таким образом, имеем следующее:</p>

<!--\indexCS{GLOBAL-REF}{специализация}-->
<!--\indexCS{CHECKED-GLOBAL-REF}{специализация}-->
<!--\indexCS{SET-GLOBAL"!}{специализация}-->
<pre>(<span class="special">define</span> (<span class="func">GLOBAL-REF</span> <span class="var">i</span>) (<span class="func">list</span> <span class="num">7</span> <span class="var">i</span>))
(<span class="special">define</span> (<span class="func">CHECKED-GLOBAL-REF</span> <span class="var">i</span>) (<span class="func">list</span> <span class="num">8</span> <span class="var">i</span>))
(<span class="special">define</span> (<span class="func">SET-GLOBAL!</span> <span class="var">i</span>) (<span class="func">list</span> <span class="num">27</span> <span class="var">i</span>))

(<span class="syntax">define-instruction</span> (<span class="func">GLOBAL-REF</span> <span class="var">i</span>) <span class="num">7</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">global-fetch</span> <span class="var">i</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">CHECKED-GLOBAL-REF</span> <span class="var">i</span>) <span class="num">8</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">global-fetch</span> <span class="var">i</span>))
  (<span class="syntax">when</span> (<span class="func">eq?</span> <span class="var">*val*</span> <span class="var">undefined-value</span>)
    (<span class="func">signal-exception</span> <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Uninitialized global variable"</span> <span class="var">i</span>)) ) )

(<span class="syntax">define-instruction</span> (<span class="func">SET-GLOBAL!</span> <span class="var">i</span>) <span class="num">27</span>
  (<span class="func">global-update!</span> <span class="var">i</span> <span class="var">*val*</span>) )</pre>

<p>Случай предопределённых неизменяемых переменных более интересен, так как доступ
к наиболее часто используемым из них можно немного ускорить. В список таких
переменных включены <code><span class="var">t</span></code>, <code><span class="var">f</span></code>, <code><span class="var">nil</span></code>, <code><span class="func">cons</span></code>, <code><span class="func">car</span></code> и некоторые
другие.</p>

<!--\indexCS{PREDEFINED}{специализация}-->
<pre>(<span class="special">define</span> (<span class="func">PREDEFINED</span> <span class="var">i</span>)
  (<span class="func">check-byte</span> <span class="var">i</span>)
  (<span class="syntax">case</span> <span class="var">i</span>
    <span class="comment">;; <code><span class="num">0</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="hash">#t</span></code>, <code><span class="num">1</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="hash">#f</span></code>, <code><span class="num">2</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="hash">()</span></code>, <code><span class="num">3</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="func">cons</span></code>, <code><span class="num">4</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="func">car</span></code>,</span>
    <span class="comment">;; <code><span class="num">5</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="func">cdr</span></code>, <code><span class="num">6</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="func">pair?</span></code>, <code><span class="num">7</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="func">symbol?</span></code>, <code><span class="num">8</span></code><span class="math"><span class="ord"/><span class="rel">=</span><span class="ord"/></span><code><span class="func">eq?</span></code></span>
    ((<span class="func">0</span> <span class="num">1</span> <span class="num">2</span> <span class="num">3</span> <span class="num">4</span> <span class="num">5</span> <span class="num">6</span> <span class="num">7</span> <span class="num">8</span>) (<span class="func">list</span> (<span class="func">+</span> <span class="num">10</span> <span class="var">i</span>)))
    (<span class="syntax">else</span>                (<span class="func">list</span> <span class="num">19</span> <span class="var">i</span>)) ) )

(<span class="syntax">define-instruction</span> (<span class="func">PREDEFINED0</span>) <span class="num">10</span>    <span class="comment">; <code><span class="hash">#t</span></code></span>
  (<span class="special">set!</span> <span class="var">*val*</span> <span class="hash">#t</span>) )
(<span class="syntax">define-instruction</span> (<span class="func">PREDEFINED</span> <span class="var">i</span>) <span class="num">19</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">predefined-fetch</span> <span class="var">i</span>)) )</pre>

<!--\indexE{constants@\protect<code><span class="func">*constants*</span></code>}-->
<!--\indexR{регистры!constants@\protect<code><span class="func">*constants*</span></code>}-->
<!--\indexR{цитаты}-->
<p>Раз уж некоторые константы трактуются по-особому, то давайте так же поступим и
с цитатами. Предположим, в машине имеется регистр
<code><span class="var">*constants*</span></code>, содержащий
вектор всех используемых в программе цитат, тогда доступ к ним можно получить
с помощью функции <code><span class="func">quotation-fetch</span></code>:</p>

<!--\indexC{quotation-fetch}-->
<pre>(<span class="special">define</span> (<span class="func">quotation-fetch</span> <span class="var">i</span>)
  (<span class="func">vector-ref</span> <span class="var">*constants*</span> <span class="var">i</span>) )</pre>

<p>Комбинатор <code><span class="func">CONSTANT</span></code> собирает все цитаты в переменной <code><span class="var">*quotations*</span></code>
во время компиляции. Перед исполнением программы все используемые цитаты
загружаются в регистр <code><span class="var">*constants*</span></code>. Цитаты не равновероятны: некоторые из
них используются чаще других, поэтому им будут выданы собственные инструкции.
Часть из них по очевидным причинам совпадает с предопределёнными константами
вроде <code><span class="func">PREDEFINED0</span></code>. Наконец, мы предположим, что цитировать напрямую
в машинном коде можно только целые числа от 0 до 255, остальные будут на общих
правах размещаться в <code><span class="var">*constants*</span></code>.<a class="footref" href="zz_footnotes.xhtml#foot7.7"><sup>7</sup></a></p>

<!--\indexCS{CONSTANT}{специализация}-->
<!--\indexC{SHORT-NUMBER}-->
<!--\indexC{EXPLICIT-CONSTANT}-->
<pre>(<span class="special">define</span> (<span class="func">CONSTANT</span> <span class="var">value</span>)
  (<span class="syntax">cond</span> ((<span class="func">eq?</span> <span class="var">value</span> <span class="hash">#t</span>)    (<span class="func">list</span> <span class="num">10</span>))
        ((<span class="func">eq?</span> <span class="var">value</span> <span class="hash">#f</span>)    (<span class="func">list</span> <span class="num">11</span>))
        ((<span class="func">eq?</span> <span class="var">value</span> <span class="hash">'()</span>)   (<span class="func">list</span> <span class="num">12</span>))
        ((<span class="func">equal?</span> <span class="var">value</span> <span class="num">-1</span>) (<span class="func">list</span> <span class="num">80</span>))
        ((<span class="func">equal?</span> <span class="var">value</span> <span class="num">0</span>)  (<span class="func">list</span> <span class="num">81</span>))
        ((<span class="func">equal?</span> <span class="var">value</span> <span class="num">1</span>)  (<span class="func">list</span> <span class="num">82</span>))
        ((<span class="func">equal?</span> <span class="var">value</span> <span class="num">2</span>)  (<span class="func">list</span> <span class="num">83</span>))
        ((<span class="func">equal?</span> <span class="var">value</span> <span class="num">3</span>)  (<span class="func">list</span> <span class="num">84</span>))
        ((<span class="syntax">and</span> (<span class="func">integer?</span> <span class="var">value</span>)   <span class="comment">; непосредственное значение</span>
              (<span class="func">&lt;=</span> <span class="num">0</span> <span class="var">value</span> <span class="num">255</span>) )
         (<span class="func">list</span> <span class="num">79</span> <span class="var">value</span>) )
        (<span class="syntax">else</span> (<span class="func">EXPLICIT-CONSTANT</span> <span class="var">value</span>)) ) )

(<span class="special">define</span> (<span class="func">EXPLICIT-CONSTANT</span> <span class="var">value</span>)
  (<span class="special">set!</span> <span class="var">*quotations*</span> (<span class="func">append</span> <span class="var">*quotations*</span> (<span class="func">list</span> <span class="var">value</span>)))
  (<span class="func">list</span> <span class="num">9</span> (<span class="func">-</span> (<span class="func">length</span> <span class="var">*quotations*</span>) <span class="num">1</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">CONSTANT-1</span>) <span class="num">80</span>
  (<span class="special">set!</span> <span class="var">*val*</span> <span class="var">-1</span>) )
(<span class="syntax">define-instruction</span> (<span class="func">CONSTANT0</span>) <span class="num">81</span>
  (<span class="special">set!</span> <span class="var">*val*</span> <span class="num">0</span>) )
(<span class="syntax">define-instruction</span> (<span class="func">SHORT-NUMBER</span> <span class="var">value</span>) <span class="num">79</span>
  (<span class="special">set!</span> <span class="var">*val*</span> <span class="var">value</span>) )</pre>


<h3 id="compilation/instruction/ssect:jumps"><span class="wrap"><span class="seq">7.4.3.</span><span class="title">Переходы</span></span></h3>

<!--\indexR{переходы (jumps)!произвольная дальность}-->
<p>Если вы думаете, что расставленные то тут, то там ограничения чересчур суровы,
тогда этот раздел для вас. Очевидно, что не стоит ограничивать
<code><span class="func">GOTO</span></code> или
<code><span class="func">JUMP-FORWARD</span></code> прыжками максимум на 256 байтов вперёд<a class="footref" href="zz_footnotes.xhtml#foot7.8"><sup>8</sup></a>, так как код без проблем может превысить эти размеры. Поэтому мы
будем различать случаи, когда длина прыжка записывается одним или двумя байтами.
Введём две отдельные инструкции<a class="footref" href="zz_footnotes.xhtml#foot7.9"><sup>9</sup></a>: <code><span class="func">SHORT-GOTO</span></code> и <code><span class="func">LONG-GOTO</span></code>. Думаем, этого будет
достаточно на время; наш компилятор пока не метит в олимпийские чемпионы, чтобы
прыгать дальше 64 килобайт.</p>

<!--\indexCS{GOTO}{специализация}-->
<!--\indexCS{JUMP-FALSE}{специализация}-->
<pre>(<span class="special">define</span> (<span class="func">GOTO</span> <span class="var">offset</span>)
  (<span class="syntax">cond</span> ((<span class="func">&lt;</span> <span class="var">offset</span> <span class="num">256</span>) (<span class="func">list</span> <span class="num">30</span> <span class="var">offset</span>))
        ((<span class="func">&lt;</span> <span class="var">offset</span> <span class="num">65536</span>)
         (<span class="syntax">let</span> ((<span class="var">offset1</span> (<span class="func">modulo</span> <span class="var">offset</span> <span class="num">256</span>))
               (<span class="var">offset2</span> (<span class="func">quotient</span> <span class="var">offset</span> <span class="num">256</span>)) )
           (<span class="func">list</span> <span class="num">28</span> <span class="var">offset1</span> <span class="var">offset2</span>) ) )
        (<span class="syntax">else</span> (<span class="func">static-wrong</span> <span class="string">"Too far jump"</span> <span class="var">offset</span>)) ) )

(<span class="special">define</span> (<span class="func">JUMP-FALSE</span> <span class="var">offset</span>)
  (<span class="syntax">cond</span> ((<span class="func">&lt;</span> <span class="var">offset</span> <span class="num">256</span>) (<span class="func">list</span> <span class="num">31</span> <span class="var">offset</span>))
        ((<span class="func">&lt;</span> <span class="var">offset</span> <span class="num">65536</span>)
         (<span class="syntax">let</span> ((<span class="var">offset1</span> (<span class="func">modulo</span> <span class="var">offset</span> <span class="num">256</span>))
               (<span class="var">offset2</span> (<span class="func">quotient</span> <span class="var">offset</span> <span class="num">256</span>)) )
           (<span class="func">list</span> <span class="num">29</span> <span class="var">offset1</span> <span class="var">offset2</span>) ) )
        (<span class="syntax">else</span> (<span class="func">static-wrong</span> <span class="string">"Too far jump"</span> <span class="var">offset</span>)) ) )

(<span class="syntax">define-instruction</span> (<span class="func">SHORT-GOTO</span> <span class="var">offset</span>) <span class="num">30</span>
  (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">+</span> <span class="var">*pc*</span> <span class="var">offset</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">SHORT-JUMP-FALSE</span> <span class="var">offset</span>) <span class="num">31</span>
  (<span class="special">if</span> (<span class="func">not</span> <span class="var">*val*</span>) (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">+</span> <span class="var">*pc*</span> <span class="var">offset</span>))) )

(<span class="syntax">define-instruction</span> (<span class="func">LONG-GOTO</span> <span class="var">offset1</span> <span class="var">offset2</span>) <span class="num">28</span>
  (<span class="syntax">let</span> ((<span class="var">offset</span> (<span class="func">+</span> <span class="var">offset1</span> (<span class="func">*</span> <span class="num">256</span> <span class="var">offset2</span>))))
    (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">+</span> <span class="var">*pc*</span> <span class="var">offset</span>)) ) )</pre>


<h3 id="compilation/instruction/ssect:invocations"><span class="wrap"><span class="seq">7.4.4.</span><span class="title">Вызовы функций</span></span></h3>

<p>Для начала разберёмся с обычными вызовами, а потом перейдём ко встраиваемым.
Наблюдение о преимущественно небольшой арности используемых функций будет
полезным и здесь. Выделив ещё немного байт-кодов, мы можем специализировать
создание записей активаций для малого числа аргументов:</p>

<!--\indexCS{ALLOCATE-FRAME}{специализация}-->
<pre>(<span class="special">define</span> (<span class="func">ALLOCATE-FRAME</span> <span class="var">size</span>)
  (<span class="syntax">case</span> <span class="var">size</span>
    ((<span class="num">0</span> <span class="num">1</span> <span class="num">2</span> <span class="num">3</span> <span class="num">4</span>) (<span class="func">list</span> (<span class="func">+</span> <span class="num">50</span> <span class="var">size</span>)))
    (<span class="syntax">else</span>        (<span class="func">list</span> <span class="num">55</span> (<span class="func">+</span> <span class="var">size</span> <span class="num">1</span>))) ) )

(<span class="syntax">define-instruction</span> (<span class="func">ALLOCATE-FRAME1</span>) <span class="num">50</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">allocate-activation-frame</span> <span class="num">1</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">ALLOCATE-FRAME</span> <span class="var">size+1</span>) <span class="num">55</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">allocate-activation-frame</span> <span class="var">size+1</span>)) )</pre>

<p>Раскладывание значений аргументов по записям тоже можно улучшить для небольших
арностей:</p>

<!--\indexCS{POP-FRAME"!}{специализация}-->
<pre>(<span class="special">define</span> (<span class="func">POP-FRAME!</span> <span class="var">index</span>)
  (<span class="syntax">case</span> <span class="var">index</span>
    ((<span class="num">0</span> <span class="num">1</span> <span class="num">2</span> <span class="num">3</span>) (<span class="func">list</span> (<span class="func">+</span> <span class="num">60</span> <span class="var">index</span>)))
    (<span class="syntax">else</span>      (<span class="func">list</span> <span class="num">64</span> <span class="var">index</span>)) ) )

(<span class="syntax">define-instruction</span> (<span class="func">POP-FRAME!0</span>) <span class="num">60</span>
  (<span class="func">set-activation-frame-argument!</span> <span class="var">*val*</span> <span class="num">0</span> (<span class="func">stack-pop</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">POP-FRAME!</span> <span class="var">index</span>) <span class="num">64</span>
  (<span class="func">set-activation-frame-argument!</span> <span class="var">*val*</span> <span class="var">index</span> (<span class="func">stack-pop</span>)) )</pre>

<!--\indexR{функции!встраиваемые}-->
<!--\indexR{встраивание!функций}-->
<!--\indexR{встраивание!примитивов}-->
<!--\indexR{примитивы!встраивание}-->
<p>Встраиваемые вызовы встречаются очень часто, поэтому им стоит выдать личные
коды. Например, комбинатор <code><span class="func">INVOKE1</span></code> отвечает за унарные предопределённые
функции:</p>

<!--\indexE{INVOKE0@\protect<code><span class="func">INVOKE</span></code>\protect<i>n</i>!специализация}-->
<pre>(<span class="special">define</span> (<span class="func">INVOKE1</span> <span class="var">address</span>)
  (<span class="syntax">case</span> <span class="var">address</span>
    ((<span class="var">car</span>)     (<span class="func">list</span> <span class="num">90</span>))
    ((<span class="var">cdr</span>)     (<span class="func">list</span> <span class="num">91</span>))
    ((<span class="var">pair?</span>)   (<span class="func">list</span> <span class="num">92</span>))
    ((<span class="var">symbol?</span>) (<span class="func">list</span> <span class="num">93</span>))
    ((<span class="var">display</span>) (<span class="func">list</span> <span class="num">94</span>))
    (<span class="syntax">else</span>
     (<span class="func">static-wrong</span> <span class="string">"Cannot inline"</span> <span class="var">address</span>) ) ) )

(<span class="syntax">define-instruction</span> (<span class="func">CALL1-car</span>) <span class="num">90</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">car</span> <span class="var">*val*</span>)) )
(<span class="syntax">define-instruction</span> (<span class="func">CALL1-cdr</span>) <span class="num">91</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">cdr</span> <span class="var">*val*</span>)) )</pre>

<p>Естественно, аналогичные действия выполняются также для арностей 0, 2 и 3.
Функция <code><span class="func">display</span></code> сделана встраиваемой исключительно ради облегчения отладки.
Вообще ей там не место, учитывая её сложность и скорость работы. Лучше потратить
байт-коды на что-то более полезное, например: <code><span class="func">cadr</span></code>, <code><span class="func">cddr</span></code>, <code><span class="func">cdddr</span></code>
(в порядке убывания полезности).</p>

<p>Конечно, и сами проверки арности тоже можно специализировать для наиболее часто
встречающихся случаев:</p>

<!--\indexC{ARITY="?}-->
<pre>(<span class="special">define</span> (<span class="func">ARITY=?</span> <span class="var">arity+1</span>)
  (<span class="syntax">case</span> <span class="var">arity+1</span>
    ((<span class="num">1</span> <span class="num">2</span> <span class="num">3</span> <span class="num">4</span>) (<span class="func">list</span> (<span class="func">+</span> <span class="num">70</span> <span class="var">arity+1</span>)))
    (<span class="syntax">else</span>      (<span class="func">list</span> <span class="num">75</span> <span class="var">arity+1</span>)) ) )

(<span class="syntax">define-instruction</span> (<span class="func">ARITY=?2</span>) <span class="num">72</span>
  (<span class="syntax">unless</span> (<span class="func">=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="num">2</span>)
    (<span class="func">signal-exception</span>
     <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Incorrect arity for unary function"</span>) ) ) )

(<span class="syntax">define-instruction</span> (<span class="func">ARITY=?</span> <span class="var">arity+1</span>) <span class="num">75</span>
  (<span class="syntax">unless</span> (<span class="func">=</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>) <span class="var">arity+1</span>)
    (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span>) ) ) )</pre>

<p>Учитывая весьма небольшую долю функций с переменной арностью, для них особого
выигрыша подобные специализации не дадут.</p>


<!--\indexR{циклические структуры данных}-->
<p>Сейчас встраиваются лишь простые и быстрые функции. Если у нас останутся
свободные байты, то можно начать встраивать и функции посложнее, вроде <code><span class="func">memq</span></code>
или <code><span class="func">equal?</span></code>. Единственное возможное неудобство заключается в том, что вызов
<code><span class="func">memq</span></code> может никогда не завершиться (или же просто будет выполняться очень
долго), если просматриваемый ей список имеет циклы. MacScheme <span class="cite">[<a href="z1_bibliography.xhtml#85m85">85M85</a>]</span>,
к примеру, ограничивает для <code><span class="func">memq</span></code> максимальную просматриваемую длину списка несколькими
тысячами элементов.</p>

<h3 id="compilation/instruction/ssect:misc"><span class="wrap"><span class="seq">7.4.5.</span><span class="title">Прочее</span></span></h3>

<p>Ещё у нас остаются несколько простых инструкций, не имеющих операндов и
кодируемых одним-единственным байтом. Генераторы байт-кодов для них одинаковы,
так что хватит и одного примера:</p>

<pre>(<span class="special">define</span> (<span class="func">RESTORE-ENV</span>) (<span class="func">list</span> <span class="num">38</span>))</pre>

<p class="noindent">А вот и их определения:</p>

<!--\indexC{EXTEND-ENV}     -->
<!--\indexC{UNLINK-ENV}-->
<!--\indexC{PUSH-VALUE}     -->
<!--\indexC{POP-ARG1}-->
<!--\indexC{POP-ARG2}       -->
<!--\indexC{CREATE-CLOSURE}-->
<!--\indexC{RETURN}         -->
<!--\indexC{FUNCTION-GOTO}-->
<!--\indexC{FUNCTION-INVOKE}-->
<!--\indexC{POP-FUNCTION}-->
<!--\indexC{PRESERVE-ENV}   -->
<!--\indexC{RESTORE-ENV}-->
<pre>(<span class="syntax">define-instruction</span> (<span class="func">EXTEND-ENV</span>) <span class="num">32</span>
  (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">sr-extend*</span> <span class="var">*env*</span> <span class="var">*val*</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">UNLINK-ENV</span>) <span class="num">33</span>
  (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">activation-frame-next</span> <span class="var">*env*</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">PUSH-VALUE</span>) <span class="num">34</span>
  (<span class="func">stack-push</span> <span class="var">*val*</span>) )

(<span class="syntax">define-instruction</span> (<span class="func">POP-ARG1</span>) <span class="num">35</span>
  (<span class="special">set!</span> <span class="var">*arg1*</span> (<span class="func">stack-pop</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">POP-ARG2</span>) <span class="num">36</span>
  (<span class="special">set!</span> <span class="var">*arg2*</span> (<span class="func">stack-pop</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">CREATE-CLOSURE</span> <span class="var">offset</span>) <span class="num">40</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">make-closure</span> (<span class="func">+</span> <span class="var">*pc*</span> <span class="var">offset</span>) <span class="var">*env*</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">RETURN</span>) <span class="num">43</span>
  (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">FUNCTION-GOTO</span>) <span class="num">46</span>
  (<span class="func">invoke</span> <span class="var">*fun*</span> <span class="hash">#t</span>) )

(<span class="syntax">define-instruction</span> (<span class="func">FUNCTION-INVOKE</span>) <span class="num">45</span>
  (<span class="func">invoke</span> <span class="var">*fun*</span> <span class="hash">#f</span>) )

(<span class="syntax">define-instruction</span> (<span class="func">POP-FUNCTION</span>) <span class="num">39</span>
  (<span class="special">set!</span> <span class="var">*fun*</span> (<span class="func">stack-pop</span>)) )

(<span class="syntax">define-instruction</span> (<span class="func">PRESERVE-ENV</span>) <span class="num">37</span>
  (<span class="func">preserve-environment</span>) )

(<span class="syntax">define-instruction</span> (<span class="func">RESTORE-ENV</span>) <span class="num">38</span>
  (<span class="func">restore-environment</span>) )</pre>

<p>Сохранение и восстановление окружения реализуется следующей парой функций:</p>

<!--\indexC{preserve-environment}-->
<!--\indexC{restore-environment}-->
<pre>(<span class="special">define</span> (<span class="func">preserve-environment</span>)
  (<span class="func">stack-push</span> <span class="var">*env*</span>) )

(<span class="special">define</span> (<span class="func">restore-environment</span>)
  (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">stack-pop</span>)) )</pre>

<!--\indexR{вызов!хвостовой}-->
<!--\indexR{хвостовые вызовы}-->
<p>Возможны два способа вызова функций: <code><span class="func">FUNCTION-GOTO</span></code> для выполнения вызовов
из хвостовой позиции и <code><span class="func">FUNCTION-INVOKE</span></code> для всего остального. При вызове из
хвостовой позиции функция просто использует тот адрес возврата, который в момент
её вызова лежал на верхушке стека. При нормальном вызове поток исполнения
необходимо вернуть к инструкции, следующей за <code>(<span class="func">FUNCTION-INVOKE</span>)</code>, поэтому
она должна самостоятельно сохранить состояние счётчика команд в стеке. Хвостовой
вызов же по определению эквивалентен <code><span class="func">FUNCTION-INVOKE</span></code>, за которой сразу же
следует <code><span class="func">RETURN</span></code>, а так любая функция всегда завершается инструкцией
<code><span class="func">RETURN</span></code>, то достаточно просто оставить в стеке старый адрес возврата, чтобы
<code><span class="func">RETURN</span></code> вызываемой функции перешла куда следует — ведь вызывающей функции
всё равно ничего больше делать не надо. Именно так и поступает
<code><span class="func">FUNCTION-GOTO</span></code>. Обобщённая функция <code><span class="func">invoke</span></code> реализует оба варианта
поведения.</p>

<!--\indexC{invoke}-->
<!--\indexCS{invoke}{<code><span class="func">closure</span></code>}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">invoke</span> (<span class="var">f</span>) <span class="var">tail?</span>)
  (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Not a function"</span> <span class="var">f</span>)) )

(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">closure</span>) <span class="var">tail?</span>)
  (<span class="syntax">unless</span> <span class="var">tail?</span> (<span class="func">stack-push</span> <span class="var">*pc*</span>))
  (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">closure-closed-environment</span> <span class="var">f</span>))
  (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">closure-code</span> <span class="var">f</span>)) )</pre>

<p>Так как <code><span class="func">invoke</span></code> является обобщённой, это позволяет распространить её и на
другие объекты: например, на примитивы, представляемые замыканиями.</p>

<!--\indexCS{invoke}{<code><span class="func">primitive</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">primitive</span>) <span class="var">tail?</span>)
  (<span class="syntax">unless</span> <span class="var">tail?</span> (<span class="func">stack-push</span> <span class="var">*pc*</span>))
  ((<span class="func">primitive-address</span> <span class="var">f</span>)) )</pre>

<p>Естественно, значение <code><span class="var">tail?</span></code> надо учитывать при любом вызове функции. Для
примитивов тоже важно, прерываются ли данным вызовом вычисления или же наоборот,
сводятся к нему.</p>


<h2 id="compilation/instruction/ssect:starting"><span class="wrap"><span class="seq">7.5.</span><span class="title">Запускаем компилятор-интерпретатор</span></span></h2>

<!--\indexE{REPL}-->
<!--\indexR{интерактивная сессия (REPL)}-->
<!--\indexR{виртуальная машина!инициализация}-->
<p>Для реализации REPL (что мы делали во всех предыдущих главах) потребуется
слаженное взаимодействие компилятора и виртуальной машины. Функция
<code><span class="func">standalone-producer-c7</span></code> принимает программу и инициализирует компилятор.
Под инициализацией здесь понимается создание начального глобального окружения
и перечня используемых цитат. Результатом функции <code><span class="func">meaning</span></code> теперь является
список байтов, который укладывается в вектор между инструкциями <code><span class="func">FINISH</span></code>
в начале и <code><span class="func">RETURN</span></code> в конце. Начальным состоянием счётчика программ будет
единица — адрес первой инструкции после пролога. По известным причинам
<span class="see">[см. упр. <a href="ch06_fast_interpretation.xhtml#fast/ex:symbol-table">6.1</a>]</span>, с которыми мы столкнёмся позже, эта функция также
инициализирует поимённый список глобальных переменных и цитат. В конце концов
мы получаем замыкание, представляющее наши вычисления и ожидающее последний
важный параметр — необходимый размер стека.</p>

<!--\indexC{chapter7-interpreter}-->
<!--\indexC{make-code-segment}-->
<!--\indexC{code-prologue}-->
<!--\indexC{standalone-producer-c7}-->
<pre>(<span class="special">define</span> (<span class="func">chapter7-interpreter</span>)
  (<span class="special">define</span> (<span class="func">toplevel</span>)
    (<span class="func">display</span> ((<span class="func">standalone-producer-c7</span> (<span class="func">read</span>)) <span class="num">100</span>))
    (<span class="func">toplevel</span>) )
  (<span class="func">toplevel</span>) )

(<span class="special">define</span> (<span class="func">standalone-producer-c7</span> <span class="var">e</span>)
  (<span class="special">set!</span> <span class="var">g.current</span> (<span class="func">original.g.current</span>))
  (<span class="special">set!</span> <span class="var">*quotations*</span> <span class="hash">'()</span>)
  (<span class="syntax">let*</span> ((<span class="var">code</span> (<span class="func">make-code-segment</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r.init</span> <span class="hash">#t</span>)))
         (<span class="var">start-pc</span> (<span class="func">length</span> (<span class="func">code-prologue</span>)))
         (<span class="var">global-names</span> (<span class="func">map</span> <span class="var">car</span> (<span class="func">reverse</span> <span class="var">g.current</span>)))
         (<span class="var">constants</span> (<span class="func">apply</span> <span class="var">vector</span> <span class="var">*quotations*</span>)) )
    (<span class="special">lambda</span> (<span class="var">stack-size</span>)
      (<span class="func">run-machine</span> <span class="var">stack-size</span> <span class="var">start-pc</span> <span class="var">code</span>
                   <span class="var">constants</span> <span class="var">global-names</span> ) ) ) )

(<span class="special">define</span> (<span class="func">make-code-segment</span> <span class="var">m</span>)
  (<span class="func">apply</span> <span class="var">vector</span> (<span class="func">append</span> (<span class="func">code-prologue</span>) <span class="var">m</span> (<span class="func">RETURN</span>))) )

(<span class="special">define</span> (<span class="func">code-prologue</span>)
  (<span class="special">set!</span> <span class="var">finish-pc</span> <span class="num">0</span>)
  (<span class="func">FINISH</span>) )</pre>

<!--\indexR{виртуальная машина!остановка работы}-->
<p>Функция <code><span class="func">run-machine</span></code> инициализирует состояние виртуальной машины и запускает
её. Она должна создать вектор глобальных изменяемых переменных, запомнить их
имена, создать стек и инициализировать регистры. Вроде бы ничего
не забыли… стоп! а как нам остановить машину? Откомпилированная
программа представляется в виде огромной функции, которую виртуальная машина
вызывает из хвостовой позиции, то есть последней выполняемой инструкцией
программы будет <code><span class="func">RETURN</span></code>. Чтобы всё отработало как надо, в стеке должен
лежать адрес возврата для этой инструкции. Теперь понятно, зачем в самом начале
вектора кода располагается инструкция <code><span class="func">FINISH</span></code>? Сама она определяется так:</p>

<!--\indexC{FINISH}-->
<pre>(<span class="syntax">define-instruction</span> (<span class="func">FINISH</span>) <span class="num">20</span>
  (<span class="func">*exit*</span> <span class="var">*val*</span>) )</pre>

<p>Её задачей будет остановить виртуальную машину и передать наверх значение
регистра <code><span class="var">*val*</span></code> на момент завершения работы. Такого поведения мы добиваемся
с помощью ловкой активации продолжения функции <code><span class="func">run-machine</span></code>.</p>


<!--\indexC{run-machine}-->
<pre>(<span class="special">define</span> (<span class="func">run-machine</span> <span class="var">stack-size</span> <span class="var">pc</span> <span class="var">code</span> <span class="var">constants</span> <span class="var">global-names</span>)
  (<span class="special">set!</span> <span class="var">sg.current</span> (<span class="func">make-vector</span> (<span class="func">length</span> <span class="var">global-names</span>) <span class="var">undefined-value</span>))
  (<span class="special">set!</span> <span class="var">sg.current.names</span> <span class="var">global-names</span>)
  (<span class="special">set!</span> <span class="var">*constants*</span>   <span class="var">constants</span>)
  (<span class="special">set!</span> <span class="var">*code*</span>        <span class="var">code</span>)
  (<span class="special">set!</span> <span class="var">*env*</span>         <span class="var">sr.init</span>)
  (<span class="special">set!</span> <span class="var">*stack*</span>       (<span class="func">make-vector</span> <span class="var">stack-size</span>))
  (<span class="special">set!</span> <span class="var">*stack-index*</span> <span class="num">0</span>)
  (<span class="special">set!</span> <span class="var">*val*</span>         '<span class="var">anything</span>)
  (<span class="special">set!</span> <span class="var">*fun*</span>         '<span class="var">anything</span>)
  (<span class="special">set!</span> <span class="var">*arg1*</span>        '<span class="var">anything</span>)
  (<span class="special">set!</span> <span class="var">*arg2*</span>        '<span class="var">anything</span>)
  (<span class="func">stack-push</span> <span class="var">finish-pc</span>)         <span class="comment">; точка выхода из программы</span>
  (<span class="special">set!</span> <span class="var">*pc*</span>          <span class="var">pc</span>)
  (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">exit</span>)
             (<span class="special">set!</span> <span class="var">*exit*</span> <span class="var">exit</span>)
             (<span class="func">run</span>) )) )</pre>


<h3 id="compilation/instruction/ssect:catch-breath"><span class="wrap"><span class="seq">7.5.1.</span><span class="title">Передышка</span></span></h3>

<p>Напоследок, после тщательного рассмотрения инструкций нашей виртуальной машины,
давайте ещё раз взглянем на результат компиляции примера с факториалом, теперь
уже под новый диалект машинного языка. И оформленный, естественно, не в виде
байтов, а как читабельный дизассемблерный листинг. Прошу любить и жаловать:
таблица <a href="#ch7-disasm-2">7.5</a>.</p>

<table id="ch7-disasm-2" class="disasm">
<tbody>
<tr><td class="col1"><code>(<span class="func">CREATE-CLOSURE</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">CALL2-*</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHORT-GOTO</span> <span class="num">60</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">ARITY=?4</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">EXTEND-ENV</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF0</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FUNCTION</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">FUNCTION-GOTO</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CONSTANT0</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-ARG1</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CALL2-=</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME4</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHORT-JUMP-FALSE</span> <span class="num">10</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF2</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!1</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CONSTANT1</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FUNCTION</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">FUNCTION-GOTO</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">ALLOCATE-FRAME2</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-FRAME!0</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-FUNCTION</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">FUNCTION-GOTO</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHORT-GOTO</span> <span class="num">40</span>)</code></td>
    <td class="col2"><code>(<span class="func">EXTEND-ENV</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF1</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHALLOW-ARGUMENT-REF0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF0</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHORT-NUMBER</span> <span class="num">5</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CONSTANT1</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHALLOW-ARGUMENT-REF0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-ARG1</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CALL2--</span>)</code></td>
    <td class="col2"><code>(<span class="func">CREATE-CLOSURE</span> <span class="num">2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHORT-GOTO</span> <span class="num">4</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF1</span>)</code></td>
    <td class="col2"><code>(<span class="func">ARITY=?2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">EXTEND-ENV</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">CREATE-CLOSURE</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">SHALLOW-ARGUMENT-REF0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHORT-GOTO</span> <span class="num">19</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">ARITY=?2</span>)</code></td>
    <td class="col2"><code>(<span class="func">PUSH-VALUE</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">EXTEND-ENV</span>)</code></td>
    <td class="col2"><code>(<span class="func">ALLOCATE-FRAME4</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">DEEP-ARGUMENT-REF</span> <span class="num">1</span> <span class="num">2</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!2</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!1</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">DEEP-ARGUMENT-REF</span> <span class="num">1</span> <span class="num">0</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FRAME!0</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">PUSH-VALUE</span>)</code></td>
    <td class="col2"><code>(<span class="func">POP-FUNCTION</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">SHALLOW-ARGUMENT-REF0</span>)</code></td>
    <td class="col2"><code>(<span class="func">FUNCTION-GOTO</span>)</code></td></tr>
<tr><td class="col1"><code>(<span class="func">POP-ARG1</span>)</code></td>
    <td class="col2"><code>(<span class="func">RETURN</span>)</code></td></tr>
</tbody></table>
<span class="caption">Таблица 7.5. Откомпилированная программа.</span>

<h2 id="compilation/sect:continue"><span class="wrap"><span class="seq">7.6.</span><span class="title">Продолжения</span></span></h2>

<!--\indexCS{call/cc}{каноническая реализация}-->
<!--\indexR{полноценные объекты!продолжения}-->
<!--\indexR{продолжения (continuations)!как полноценные объекты}-->
<p>Мы уже знаем, что <code><span class="func">call/cc</span></code> — это магический оператор, реифицирующий
контекст исполнения программы, превращающий его в полноценный объект языка,
который можно сохранить в переменной, а потом восстановить обратно. Настало
время объяснить, как именно он работает. Предлагаемая реализация является
канонической. Более эффективные, но и более сложные варианты можно найти
в <span class="cite">[<a href="z1_bibliography.xhtml#cho88">CHO88</a>,
<a href="z1_bibliography.xhtml#hdb90">HDB90</a>,
<a href="z1_bibliography.xhtml#mb93">MB93</a>]</span>.</p>

<!--\indexR{программы!контекст исполнения}-->
<!--\indexR{стек!контекст исполнения}-->
<!--\indexR{контекст вычислений}-->
<!--\indexR{вычисления!контекст}-->
<p>Контекст исполнения программы — это стек и ничего, кроме стека.
Действительно, регистры <code><span class="var">*fun*</span></code>, <code><span class="var">*arg1*</span></code> и <code><span class="var">*arg2*</span></code> используются лишь для
хранения промежуточных результатов вычислений, их значения лишены смысла между
выражениями компилируемого языка. (Нельзя<a class="footref" href="zz_footnotes.xhtml#foot7.10"><sup>10</sup></a> вызвать <code><span class="func">call/cc</span></code> или
что-нибудь ещё во время процесса обработки вызова функции, когда эти регистры
используются.)</p>

<p>Регистр <code><span class="var">*val*</span></code> используется для передачи значений самим продолжениям, так
что тут нечего сохранять. Регистр <code><span class="var">*env*</span></code> тоже бессмысленно
запоминать, потому как <code><span class="func">call/cc</span></code> — это не встраиваемый примитив; если
окружение надо было сохранить, то это уже сделано в силу самого вызова
<em>функции</em> <code><span class="func">call/cc</span></code>. Таким образом, остаётся сохранить только стек.
Следующие функции помогут работать с ним:</p>

<!--\indexC{save-stack}-->
<!--\indexC{restore-stack}-->
<!--\indexC{vector-copy"!}-->
<pre>(<span class="special">define</span> (<span class="func">save-stack</span>)
  (<span class="syntax">let</span> ((<span class="var">copy</span> (<span class="func">make-vector</span> <span class="var">*stack-index*</span>)))
    (<span class="func">vector-copy!</span> <span class="var">*stack*</span> <span class="var">copy</span> <span class="num">0</span> <span class="var">*stack-index*</span>)
    <span class="var">copy</span> ) )

(<span class="special">define</span> (<span class="func">restore-stack</span> <span class="var">copy</span>)
  (<span class="special">set!</span> <span class="var">*stack-index*</span> (<span class="func">vector-length</span> <span class="var">copy</span>))
  (<span class="func">vector-copy!</span> <span class="var">copy</span> <span class="var">*stack*</span> <span class="num">0</span> <span class="var">*stack-index*</span>) )

(<span class="special">define</span> (<span class="func">vector-copy!</span> <span class="var">old</span> <span class="var">new</span> <span class="var">start</span> <span class="var">end</span>)
  (<span class="syntax">let</span> <span class="func">copy</span> ((<span class="var">i</span> <span class="var">start</span>))
    (<span class="syntax">when</span> (<span class="func">&lt;</span> <span class="var">i</span> <span class="var">end</span>)
          (<span class="func">vector-set!</span> <span class="var">new</span> <span class="var">i</span> (<span class="func">vector-ref</span> <span class="var">old</span> <span class="var">i</span>))
          (<span class="func">copy</span> (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>)) ) ) )</pre>

<p>Продолжения имеют личный класс значений и особый протокол вызова. При
активации продолжения следует восстановить стек, положить переданное значение
в регистр <code><span class="var">*val*</span></code>, а затем выполнить <code><span class="func">RETURN</span></code>, который перейдёт
к инструкции, следующей за вызовом <code><span class="func">call/cc</span></code>. Очевидно, для этого
<code><span class="func">call/cc</span></code> должна вызываться исключительно с помощью <code><span class="func">FUNCTION-INVOKE</span></code>, а
значит, следующей исполняемой инструкцией обязательно будет <code><span class="func">RESTORE-ENV</span></code>.
(Можете убедиться в этом, перечитав определение
<code><span class="func">REGULAR-CALL</span></code>.)
<span class="see">[см. раздел <a href="#compilation/bytes/customize/sssect:lin-invocation">7.1.3</a>]</span></p>

<!--\indexC{continuation}-->
<!--\indexCS{invoke}{<code><span class="func">continuation</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">continuation</span> <span class="class">Object</span>
  ( <span class="var">stack</span> ) )

(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">continuation</span>) <span class="var">tail?</span>)
  (<span class="special">if</span> (<span class="func">=</span> (<span class="func">+</span> <span class="num">1</span> <span class="num">1</span>) (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>))
      (<span class="special">begin</span>
        (<span class="func">restore-stack</span> (<span class="func">continuation-stack</span> <span class="var">f</span>))
        (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>))
        (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )
      (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">continuation</span>)) ) )</pre>

<!--\indexCS{call/cc}{огранизация стека}-->
<p>Для правильной работы продолжений <code><span class="func">call/cc</span></code> должна организовать стек таким
образом, чтобы после активации продолжения начал исполняться код, следующий за
самой <code><span class="func">call/cc</span></code>. То есть форма <code>(<span class="func">call/cc</span> <i>f</i>)</code> с точки зрения стека
должна быть идентична вызову функции <i>f</i> из хвостовой позиции (если забыть
про <code><span class="func">dynamic-wind</span></code>). Следующее определение добивается этого, выполняя
хвостовой вызов вручную. Функция <code><span class="func">call/cc</span></code> сама создаёт нужную запись
активации для своего аргумента-замыкания, сохраняет в ней продолжение, помещает
эту запись в обход стека сразу же в <code><span class="var">*val*</span></code> и вызывает <i>f</i> напрямую.</p>

<!--\indexC{call/cc}-->
<pre>(<span class="syntax">definitial</span> <span class="var">call/cc</span>
  (<span class="syntax">let*</span> ((<span class="var">arity</span> <span class="num">1</span>)
         (<span class="var">arity+1</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
    (<span class="func">make-primitive</span>
      (<span class="special">lambda</span> ()
        (<span class="special">if</span> (<span class="func">=</span> <span class="var">arity+1</span> (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>))
            (<span class="syntax">let</span> ((<span class="var">f</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>))
                  (<span class="var">frame</span> (<span class="func">allocate-activation-frame</span> (<span class="func">+</span> <span class="num">1</span> <span class="num">1</span>))) )
              (<span class="func">set-activation-frame-argument!</span>
               <span class="var">frame</span> <span class="num">0</span> (<span class="func">make-continuation</span> (<span class="func">save-stack</span>)) )
              (<span class="special">set!</span> <span class="var">*val*</span> <span class="var">frame</span>)
              (<span class="special">set!</span> <span class="var">*fun*</span> <span class="var">f</span>)       <span class="comment">; полезно для отладки</span>
              (<span class="func">invoke</span> <span class="var">f</span> <span class="hash">#t</span>) )
            (<span class="func">signal-exception</span> <span class="hash">#t</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span>
                                       '<span class="var">call/cc</span> )) ) ) ) ) )</pre>

<p>Итого, каноническая реализация <code><span class="func">call/cc</span></code> выполняет одно полное копирование
стека при своём вызове, а также по дополнительному копированию при каждой
активации сохранённых продолжений. Естественно, существуют стратегии поумнее,
но они более сложны для понимания и реализации. Основываются они на том, что
у захватываемых продолжений нередко <span class="cite">[<a href="z1_bibliography.xhtml#dan87">Dan87</a>]</span> имеются общие части, которые
бессмысленно дублировать, поэтому можно оптимизировать <code><span class="func">call/cc</span></code>, если
использовать более разумный способ представления продолжений, нежели полные
независимые снимки стека.</p>


<h2 id="compilation/sect:escapes"><span class="wrap"><span class="seq">7.7.</span><span class="title">Переходы</span></span></h2>

<!--\indexR{переходы (escapes)!реализация}-->
<!--\indexCS{bind-exit}{машинная реализация}-->
<p>Несмотря на то, что стоимость <code><span class="func">call/cc</span></code>
можно уменьшить, обычные переходы (escapes) всё ещё остаются гораздо более эффективными.
Мы упоминали об этом в третьей главе, так что сейчас было бы нечестным не показывать, как они
реализуются технически. Для иллюстрации была выбрана конструкция
<code><span class="special">bind-exit</span></code>.
<span class="see">[см. раздел <a href="ch03_escape_and_return.xhtml#escape/comparing/par:bind-exit">3.5</a>]</span>
Родом она из диалекта Dylan, её аналогами являются
<code><span class="special">let/cc</span></code> в <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span>,
<code><span class="special">block</span></code>/<code><span class="special">return-from</span></code>
в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>, <code><span class="special">escape</span></code>
в VLISP <span class="cite">[<a href="z1_bibliography.xhtml#cha80">Cha80</a>]</span>.</p>

<p>Наперекор традициям Scheme, она будет реализована в виде специальной формы, а
не функции. Во-первых, в данном случае легче реализовать именно специальную
форму, так как это избавит нас от излишней работы по соблюдению протокола вызова
функций; во-вторых, главной задачей этой главы является демонстрация внутреннего
строения компилятора, а не следование догмам. Если вас эти слова не убедили, то
вспомните, что подобную специальную форму можно выразить через аналогичную
функцию и наоборот, так что это лишь вопрос внешнего вида, а не сути.</p>

<p>Форма <code><span class="special">bind-exit</span></code> имеет следующий синтаксис:</p>

<pre>(<span class="special">bind-exit</span> (<i>переменная</i>) <i>формы</i>...)</pre>

<!--\indexC{call/ep}-->
<p><i>Переменная</i> связывается с продолжением формы <code><span class="special">bind-exit</span></code>, после чего
последовательно вычисляются <i>формы</i>. Захваченным продолжением можно
воспользоваться только во время этих вычислений. Если у нас есть <code><span class="special">bind-exit</span></code>,
то можно легко определить функцию <code><span class="func">call/ep</span></code> и наоборот:</p>

<pre>(<span class="special">define</span> (<span class="func">call/ep</span> <span class="var">f</span>)
  (<span class="special">bind-exit</span> (<span class="var">k</span>) (<span class="func">f</span> <span class="var">k</span>)) )

(<span class="special">bind-exit</span> (<i>k</i>) <i>тело</i>) <span class="math"><span class="rel">≡</span></span> (<span class="func">call/ep</span> (<span class="special">lambda</span> (<i>k</i>) <i>тело</i>))</pre>

<p>Переходы представляются объектами класса <code><span class="class">escape</span></code>. Его единственное поле
хранит высоту стека, какой она была на момент начала вычисления формы
<code><span class="special">bind-exit</span></code>.</p>

<!--\indexC{escape}-->
<pre>(<span class="syntax">define-class</span> <span class="class">escape</span> <span class="class">Object</span>
  ( <span class="var">stack-index</span> ) )</pre>

<p>Для определения специальной формы сперва необходимо добавить соответствующую
обработку в функцию <code><span class="func">meaning</span></code>, синтаксический анализатор компилируемых форм.
Её задачей является распознавание наших нововведений:</p>

<pre>... ((<span class="var">bind-exit</span>) (<span class="func">meaning-bind-exit</span> (<span class="func">caadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>)) ...</pre>

<p>Затем определяется способ предобработки данных форм:</p>

<!--\indexC{meaning-bind-exit}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-bind-exit</span> <span class="var">n</span> <span class="var">e+</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let*</span> ((<span class="var">r2</span> (<span class="func">r-extend*</span> <span class="var">r</span> (<span class="func">list</span> <span class="var">n</span>)))
         (<span class="var">m+</span> (<span class="func">meaning-sequence</span> <span class="var">e+</span> <span class="var">r2</span> <span class="hash">#t</span>)) )
    (<span class="func">ESCAPER</span> <span class="var">m+</span>) ) )</pre>

<p>Обработка заключается в объединении форм, составляющих тело <code><span class="special">bind-exit</span></code>,
в последовательность, которая вычисляется в лексическом окружении, расширенном
локальной переменной, вводимой формой <code><span class="special">bind-exit</span></code>. Генерацией байт-кода
будет заниматься функция <code><span class="func">ESCAPER</span></code>. Для её реализации нам потребуется пара
новых инструкций: <code><span class="func">PUSH-ESCAPER</span></code> и <code><span class="func">POP-ESCAPER</span></code>.</p>

<!--\indexC{ESCAPER}-->
<!--\indexC{PUSH-ESCAPER}-->
<!--\indexC{POP-ESCAPER}-->
<!--\indexC{escape-tag}-->
<pre>(<span class="special">define</span> (<span class="func">ESCAPER</span> <span class="var">m+</span>)
  (<span class="func">append</span> (<span class="func">PUSH-ESCAPER</span> (<span class="func">+</span> <span class="num">1</span> (<span class="func">length</span> <span class="var">m+</span>)))
          <span class="var">m+</span> (<span class="func">RETURN</span>) (<span class="func">POP-ESCAPER</span>)) )

(<span class="special">define</span> (<span class="func">POP-ESCAPER</span>) (<span class="func">list</span> <span class="num">250</span>))
(<span class="special">define</span> (<span class="func">PUSH-ESCAPER</span> <span class="var">offset</span>) (<span class="func">list</span> <span class="num">251</span> <span class="var">offset</span>))

(<span class="special">define</span> <span class="var">escape-tag</span> (<span class="func">list</span> '<span class="var">*ESCAPE*</span>))

(<span class="syntax">define-instruction</span> (<span class="func">POP-ESCAPER</span>) <span class="num">250</span>
  (<span class="syntax">let*</span> ((<span class="var">tag</span> (<span class="func">stack-pop</span>))
         (<span class="var">escape</span> (<span class="func">stack-pop</span>)) )
    (<span class="func">restore-environment</span>) ) )

(<span class="syntax">define-instruction</span> (<span class="func">PUSH-ESCAPER</span> <span class="var">offset</span>) <span class="num">251</span>
  (<span class="func">preserve-environment</span>)
  (<span class="syntax">let*</span> ((<span class="var">escape</span> (<span class="func">make-escape</span> (<span class="func">+</span> <span class="var">*stack-index*</span> <span class="num">3</span>)))
         (<span class="var">frame</span> (<span class="func">allocate-activation-frame</span> <span class="num">1</span>)) )
    (<span class="func">set-activation-frame-argument!</span> <span class="var">frame</span> <span class="num">0</span> <span class="var">escape</span>)
    (<span class="special">set!</span> <span class="var">*env*</span> (<span class="func">sr-extend*</span> <span class="var">*env*</span> <span class="var">frame</span>))
    (<span class="func">stack-push</span> <span class="var">escape</span>)
    (<span class="func">stack-push</span> <span class="var">escape-tag</span>)
    (<span class="func">stack-push</span> (<span class="func">+</span> <span class="var">*pc*</span> <span class="var">offset</span>)) ) )</pre>

<!--\indexR{переходы (escapes)!огранизация стека}-->
<!--\indexR{дескрипторы!переходов}-->
<!--\indexR{стековые фреймы!переходы}-->
<p>Иллюстрация принципа работы инструкции <code><span class="func">PUSH-ESCAPER</span></code>
приведена на рисунке <a href="#compilation/escapes/pic:push-escaper">7.4</a>.
Вот что она делает:</p>

<ol>
  <li>Сохраняет в стеке текущее окружение.</li>

  <li>Создаёт дескриптор перехода, указывающий на
    три ячейки выше текущего положения верхушки стека.</li>

  <li>Создаёт запись активации с единственным полем, в которое
    укладывает созданный ранее дескриптор, после чего расширяет
    текущее окружение полученной записью.</li>

  <li>Кладёт в стек дескриптор перехода, затем странную
    метку <code>(<span class="var">*ESCAPE*</span>)</code> и, наконец, адрес инструкции
    <code><span class="func">POP-ESCAPER</span></code>, соответствующей создаваемому
    переходу.</li>
</ol>

<div class="image" id="compilation/escapes/pic:push-escaper">
<img src="images/png09.png" alt="Состояние стека до и после инструкции PUSH-ESCAPER" style="width: 5.55in"/>
<span class="caption">Рис. 7.4. Состояние стека до и после инструкции <code><span class="func">PUSH-ESCAPER</span></code>.</span>
</div>

<!--\indexR{переходы (escapes)!допустимость}-->
<p>Процедура выполнения перехода несколько усложняется из-за того, что необходимо
проверять, можно ли его вообще выполнить. Переход допустим, если 1) он
выполняется вниз по стеку; 2) искомая ячейка стека действительно содержит
настоящий дескриптор перехода; 3) это именно тот дескриптор, который нам нужен.
Соблюдение всех этих условий обеспечивается предикатом <code><span class="func">escape-valid?</span></code>.</p>

<!--\indexCS{invoke}{<code><span class="func">escape</span></code>}-->
<!--\indexC{escape-valid"?}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">escape</span>) <span class="var">tail?</span>)
  (<span class="special">if</span> (<span class="func">=</span> (<span class="func">+</span> <span class="num">1</span> <span class="num">1</span>) (<span class="func">activation-frame-argument-length</span> <span class="var">*val*</span>))
      (<span class="special">if</span> (<span class="func">escape-valid?</span> <span class="var">f</span>)
          (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">*stack-index*</span> (<span class="func">escape-stack-index</span> <span class="var">f</span>))
                 (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">activation-frame-argument</span> <span class="var">*val*</span> <span class="num">0</span>))
                 (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>)) )
          (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Escape out of extent"</span> <span class="var">f</span>)) )
      (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Incorrect arity"</span> '<span class="var">escape</span>)) ) )

(<span class="special">define</span> (<span class="func">escape-valid?</span> <span class="var">f</span>)
  (<span class="syntax">let</span> ((<span class="var">index</span> (<span class="func">escape-stack-index</span> <span class="var">f</span>)))
    (<span class="syntax">and</span> (<span class="func">>=</span> <span class="var">*stack-index*</span> <span class="var">index</span>)
         (<span class="func">eq?</span> <span class="var">f</span> (<span class="func">vector-ref</span> <span class="var">*stack*</span> (<span class="func">-</span> <span class="var">index</span> <span class="num">3</span>)))
         (<span class="func">eq?</span> <span class="var">escape-tag</span> (<span class="func">vector-ref</span> <span class="var">*stack*</span> (<span class="func">-</span> <span class="var">index</span> <span class="num">2</span>))) ) ) )</pre>

<p>При выполнении перехода сначала проверяется арность соответствующей формы,
затем стек откатывается до состояния, которое он имел при входе в форму
<code><span class="special">bind-exit</span></code>, после этого аргумент перебрасывается в регистр <code><span class="var">*val*</span></code> и,
наконец, выполняется аналог <code><span class="func">RETURN</span></code> для выхода из тела формы <code><span class="special">bind-exit</span></code>.
Следующей исполняемой инструкцией будет <code><span class="func">POP-ESCAPER</span></code>, которая уберёт
со стека теперь уже ненужный дескриптор перехода и восстановит окружение.</p>

<p>На случай, если во время вычисления тела формы <code><span class="special">bind-exit</span></code> переход
инициирован не будет, в конце располагается настоящая инструкция <code><span class="func">RETURN</span></code>,
что в итоге приводит к такому же поведению и завершающему состоянию стека, как
если бы переход был выполнен.</p>

<!--\indexCS{bind-exit}{эффективность}-->
<p>Вход в форму <code><span class="special">bind-exit</span></code> вызывает создание двух объектов и занимает четыре
ячейки стека. Выполнение перехода стоит одной проверки на допустимость и
нескольких операций с регистрами. Дескрипторы переходов создаются и сохраняются
явно, так как переменные, создаваемые <code><span class="special">bind-exit</span></code>, могут быть захвачены
замыканиями, что даст им неограниченное время жизни (но не соответствующим
переходам). Если бы эти переменные гарантированно не захватывались, то можно
было бы ограничиться запоминанием высоты стека в каком-нибудь регистре.
Приведённая реализация, признаем, является довольно простой и прямолинейной,
поэтому, естественно, и менее эффективной по сравнению с результатами хорошей
компиляции. Однако, даже такая реализация оказывается значительно быстрее
канонического варианта <code><span class="func">call/cc</span></code>.</p>

<p>Специальная форма <code><span class="special">bind-exit</span></code> (вместе с динамическими переменными, которые
мы рассмотрим далее) облегчает написание аналогов <code><span class="special">catch</span></code>/<code><span class="special">throw</span></code>.
<span class="see">[см. раздел <a href="ch03_escape_and_return.xhtml#escape/forms/ssect:dynamic">3.1.3</a>]</span>
Также напомним, что если в языке
реализована форма <code><span class="special">unwind-protect</span></code>, то <code><span class="special">bind-exit</span></code> уже не обязательно
гарантирует сверхбыстрые переходы, так как во время их выполнения необходимо
выполнять и установленные <code><span class="special">unwind-protect</span></code> формы-уборщики. Это значит, что
нам придётся полностью просматривать часть стека, которую текущая реализация
просто игнорирует.</p>


<h2 id="compilation/sect:dynamic"><span class="wrap"><span class="seq">7.8.</span><span class="title">Динамические переменные</span></span></h2>

<!--\indexR{дальнее (deep) связывание}-->
<!--\indexR{связывание!дальнее (deep)}-->
<!--\indexR{динамические переменные}-->
<!--\indexR{переменные!динамические}-->
<p>Мы уже не раз упоминали значимость идеи динамических переменных для языков
программирования. Проще всего они реализуются с помощью дальнего связывания. Как
и ранее, <span class="see">[см. раздел <a href="ch05_denotational_semantics.xhtml#denotational/dynamic/par:two-forms">5.6</a>]</span>, мы введём две специальные
формы для создания и использования подобных переменных. Вот их синтаксис:</p>

<!--\indexC{dynamic}-->
<!--\indexC{dynamic-let}-->
<pre>(<span class="special">dynamic-let</span> (<i>переменная</i> <i>значение</i>) <i>тело</i>...)
(<span class="special">dynamic</span> <i>переменная</i>)</pre>

<p>Форма <code><span class="special">dynamic-let</span></code> связывает <i>переменную</i> со <i>значением</i> на время
вычисления <i>тела</i>. Текущее значение динамической переменной можно получить
с помощью формы <code><span class="special">dynamic</span></code>. Естественно, если переменная не была ранее связана
с каким-либо значением, то возникает ошибка.</p>

<p>Итак, добавляем две новые формы в синтаксический анализатор <code><span class="func">meaning</span></code>:</p>

<pre>...
((<span class="var">dynamic</span>)     (<span class="func">meaning-dynamic-reference</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>))
((<span class="var">dynamic-let</span>) (<span class="func">meaning-dynamic-let</span> (<span class="func">car</span> (<span class="func">cadr</span> <span class="var">e</span>))
                                    (<span class="func">cadr</span> (<span class="func">cadr</span> <span class="var">e</span>))
                                    (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span> ))
...</pre>

<p>Реализуем их обработку:</p>

<!--\indexC{meaning-dynamic-let}-->
<!--\indexC{meaning-dynamic-reference}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-dynamic-let</span> <span class="var">n</span> <span class="var">e</span> <span class="var">e+</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">index</span> (<span class="func">get-dynamic-variable-index</span> <span class="var">n</span>))
        (<span class="var">m</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r</span> <span class="hash">#f</span>))
        (<span class="var">m+</span> (<span class="func">meaning-sequence</span> <span class="var">e+</span> <span class="var">r</span> <span class="hash">#f</span>)) )
    (<span class="func">append</span> <span class="var">m</span> (<span class="func">DYNAMIC-PUSH</span> <span class="var">index</span>) <span class="var">m+</span> (<span class="func">DYNAMIC-POP</span>)) ) )

(<span class="special">define</span> (<span class="func">meaning-dynamic-reference</span> <span class="var">n</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">index</span> (<span class="func">get-dynamic-variable-index</span> <span class="var">n</span>)))
    (<span class="func">DYNAMIC-REF</span> <span class="var">index</span>) ) )</pre>

<p>В результате получаем три новых генератора:</p>

<!--\indexC{DYNAMIC-PUSH}-->
<!--\indexC{DYNAMIC-POP}-->
<!--\indexC{DYNAMIC-REF}-->
<pre>(<span class="special">define</span> (<span class="func">DYNAMIC-PUSH</span> <span class="var">index</span>) (<span class="func">list</span> <span class="num">242</span> <span class="var">index</span>))
(<span class="special">define</span> (<span class="func">DYNAMIC-POP</span>)        (<span class="func">list</span> <span class="num">241</span>))
(<span class="special">define</span> (<span class="func">DYNAMIC-REF</span> <span class="var">index</span>)  (<span class="func">list</span> <span class="num">240</span> <span class="var">index</span>))</pre>

<p>Эти генераторы соответствуют трём новым инструкциям виртуальной машины:</p>

<pre>(<span class="syntax">define-instruction</span> (<span class="func">DYNAMIC-PUSH</span> <span class="var">index</span>) <span class="num">242</span>
  (<span class="func">push-dynamic-binding</span> <span class="var">index</span> <span class="var">*val*</span>) )

(<span class="syntax">define-instruction</span> (<span class="func">DYNAMIC-POP</span>) <span class="num">241</span>
  (<span class="func">pop-dynamic-binding</span>) )

(<span class="syntax">define-instruction</span> (<span class="func">DYNAMIC-REF</span> <span class="var">index</span>) <span class="num">240</span>
  (<span class="special">set!</span> <span class="var">*val*</span> (<span class="func">find-dynamic-value</span> <span class="var">index</span>)) )</pre>

<!--\indexR{принцип нулевых издержек}-->
<!--\indexR{регистры!dynenv@\protect<code><span class="func">*dynenv*</span></code>}-->
<!--\indexE{dynenv@\protect<code><span class="func">*dynenv*</span></code>}-->
<p>Итак, как же нам представить окружение динамических переменных? Первая же идея,
которая приходит в голову, — это ввести новый регистр, скажем, <code><span class="var">*dynenv*</span></code>,
хранящий ассоциативный список имён и значений динамических переменных. Вернее,
цепочку <em class="term">фреймов</em>, подобную стеку записей активаций. К сожалению, в таком
случае этот регистр будет являться частью состояния машины, за сохранение/восстановление которого отвечают инструкции <code><span class="func">PRESERVE-ENV</span></code>
и <code><span class="func">RESTORE-ENV</span></code>. Так как эти инструкции встречаются повсеместно, то введение
<code><span class="var">*dynenv*</span></code> скажется на производительности даже тех частей программы, где
динамические переменные вовсе не используются. Очень важным является принцип, по
которому за услуги платит только тот, кто их заказывает; следовательно, если
какие-либо возможности языка не используются, то они не должны вызывать
накладных расходов. С этой точки зрения введение дополнительного регистра
является плохой идеей.</p>

<div class="image" id="compilation/dynamic/pic:subj">
<img src="images/png10.png" alt="Состояние стека до и после инструкции DYNAMIC-PUSH" style="width: 4.49in"/>
<span class="caption">Рис. 7.5. Состояние стека до и после инструкции <code><span class="func">DYNAMIC-PUSH</span></code>.</span>
</div>

<!--\indexR{динамические переменные!организация стека}-->
<!--\indexR{стековые фреймы!динамические переменные}-->
<p>Поэтому вместо добавления общего для всех регистра мы реализуем иной подход,
позволяющий сохранять необходимую информацию только тем, кто нуждается в ней и
действительно будет пользоваться динамическими переменными. Конечно, расходы при
этом будут немного выше, но они никогда не падут на непричастных. Динамические
переменные будут храниться в особым образом сформированных фреймах стека,
подобно переходам (см. рисунок <a href="#compilation/dynamic/pic:subj">7.5</a>). Функция
<code><span class="func">search-dynenv-index</span></code> ищет в стеке самый верхний фрейм, содержащий
динамическую переменную, — именно эту информацию должен был хранить регистр
<code><span class="var">*dynenv*</span></code>.</p>

<!--\indexC{dynenv-tag}-->
<!--\indexC{search-dynenv-index}-->
<!--\indexC{pop-dynamic-binding}-->
<!--\indexC{push-dynamic-binding}-->
<pre>(<span class="special">define</span> <span class="var">dynenv-tag</span> (<span class="func">list</span> '<span class="var">*dynenv*</span>))

(<span class="special">define</span> (<span class="func">search-dynenv-index</span>)
  (<span class="syntax">let</span> <span class="func">search</span> ((<span class="var">i</span> (<span class="func">-</span> <span class="var">*stack-index*</span> <span class="num">1</span>)))
    (<span class="special">if</span> (<span class="func">&lt;</span> <span class="var">i</span> <span class="num">0</span>) <span class="var">i</span>
        (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">vector-ref</span> <span class="var">*stack*</span> <span class="var">i</span>) <span class="var">dynenv-tag</span>)
            (<span class="func">-</span> <span class="var">i</span> <span class="num">1</span>)
            (<span class="func">search</span> (<span class="func">-</span> <span class="var">i</span> <span class="num">1</span>)) ) ) ) )

(<span class="special">define</span> (<span class="func">pop-dynamic-binding</span>)
  (<span class="func">stack-pop</span>)
  (<span class="func">stack-pop</span>)
  (<span class="func">stack-pop</span>)
  (<span class="func">stack-pop</span>) )

(<span class="special">define</span> (<span class="func">push-dynamic-binding</span> <span class="var">index</span> <span class="var">value</span>)
  (<span class="func">stack-push</span> (<span class="func">search-dynenv-index</span>))
  (<span class="func">stack-push</span> <span class="var">value</span>)
  (<span class="func">stack-push</span> <span class="var">index</span>)
  (<span class="func">stack-push</span> <span class="var">dynenv-tag</span>) )</pre>

<!--\indexR{символы!адреса при компиляции}-->
<p>Единственная не совсем очевидная деталь — это как именно компилировать
обращения к динамическим переменным. Очевидно, что просто так у нас не получится
скомпилировать выражение <code>(<span class="special">dynamic</span> <span class="var">foo</span>)</code> в байты, потому что символ <code><span class="var">foo</span></code>
— это не число. Та же проблема у нас была с глобальными переменными, тогда мы
стали их нумеровать по мере появления. Почему бы не поступить аналогично
и сейчас? Этим будет заниматься функция <code><span class="func">get-dynamic-variable-index</span></code>:</p>

<!--\indexC*{dynamic-variables}{*dynamic-variables*}-->
<!--\indexC{get-dynamic-variable-index}-->
<pre>(<span class="special">define</span> <span class="var">*dynamic-variables*</span> '())

(<span class="special">define</span> (<span class="func">get-dynamic-variable-index</span> <span class="var">n</span>)
  (<span class="syntax">let</span> ((<span class="var">where</span> (<span class="func">memq</span> <span class="var">n</span> <span class="var">*dynamic-variables*</span>)))
    (<span class="special">if</span> <span class="var">where</span> (<span class="func">length</span> <span class="var">where</span>)
        (<span class="special">begin</span>
          (<span class="special">set!</span> <span class="var">*dynamic-variables*</span> (<span class="func">cons</span> <span class="var">n</span> <span class="var">*dynamic-variables*</span>))
          (<span class="func">length</span> <span class="var">*dynamic-variables*</span>) ) ) ) )</pre>

<p>Каждой динамической переменной ставится в соответствие индекс, по которому её
можно отыскать в окружении динамических переменных, располагаемом в стеке.
Переменная <code><span class="var">*dynamic-variables*</span></code> в принципе нужна только для компиляции, но
возможность вывести имя переменной в случае ошибки — тоже вещь хорошая.
Определение функции <code><span class="func">find-dynamic-value</span></code> оставляется вам в качестве
упражнения.</p>

<p>В этом разделе приведена реализация динамических переменных с помощью пары
специальных форм. Функциональная реализация лучше соотносится с духом Scheme,
но она не полностью эквивалентна текущей. Аргументы функций могут быть как
непосредственными значениями, так и выражениями, тогда как специальным формам
позволяется вводить особые требования к синтаксису. Очевидно, что мы не сможем
заранее пронумеровать динамические переменные, если их поддержка реализуется
с помощью функций, так как это даёт возможность вычислять символы во время
исполнения программы.
<span class="see">[см. раздел <a href="ch02_lisp_1_2_omega.xhtml#lisp1-2-omega/namespaces/ssect:dyn-vars-no-special">2.5.3</a>]</span> В этом случае уже
придётся, по-видимому, как-то использовать сами символы напрямую, но поддержка
модулей, пространств имён и различные оптимизации могут повлиять на семантику
сравнения символов, что в свою очередь скажется на динамических переменных.</p>


<h2 id="compilation/sect:exception"><span class="wrap"><span class="seq">7.9.</span><span class="title">Исключения</span></span></h2>

<p>В любом сколь-нибудь развитом языке программирования обязательно присутствует
система обработки ошибок. Возможность обработки ошибок — это ключ к написанию
устойчивых, надёжных приложений. К сожалению, в стандарте R<sup>5</sup>RS подобная
система не описана, поэтому давайте создадим её самостоятельно; просто чтобы
показать, насколько она может быть полезной и удобной.</p>

<!--\indexR{ошибки!и исключения}-->
<!--\indexR{обработка ошибок}-->
<p>Понятие ошибки имеет несколько значений. Во-первых, это предотвратимые, но
почему-то не предусмотренные ситуации. Например, ошибки типизации:
<code>(<span class="func">car</span> <span class="num">33</span>)</code>, недопустимые значения аргументов: <code>(<span class="func">quotient</span> <span class="num">111</span> <span class="num">0</span>)</code>, или
их неправильное количество: <code>(<span class="func">cons</span>)</code>. Подобных логических ошибок можно
избежать, вовремя выполняя соответствующие проверки. Другой класс ошибок
составляют непредотвратимые, исключительные ситуации, например, ошибка открытия
файла. Для их обработки необходимы следующие механизмы:</p>

<ol>
  <li>Способ создания объекта, описывающего ошибку и поддающегося
    программной обработке.</li>

  <li>Возможность передать этот объект определённой функции,
    которую пользователь назначил обработчиком ошибок.</li>
</ol>

<!--\indexR{исключения}-->
<p>Если в языке присутствуют эти механизмы, то пользователи языка закономерно
захотят их применять. Так ошибки становятся <em class="term">исключениями</em>, и появляется
возможность описывать логику программ с их помощью: реализовывать только
корректное, нормальное поведение, а всевозможные аномальные прерывания
вычислений оставлять на откуп обработчику исключительных ситуаций.</p>

<!--\indexR{динамическое связывание!и исключения}-->
<!--\indexR{обработка ошибок!динамические переменные}-->
<!--\indexR{дескрипторы!исключений}-->
<p>Существует несколько моделей обработки исключений. В основном они базируются на
идее динамического времени жизни. Если мы хотим обрабатывать ошибки, возникающие
во время определённых вычислений, то очевидно, что на время проведения этих
вычислений с ними связывается определённая функция-обработчик. Если вычисления
выполнились без проблем, то обработчик становится ненужным и автоматически
утилизируется. В противном случае создаётся объект, описывающий произошедшую
ошибку, и к нему применяется обработчик. Если ошибку первым заметил
пользовательский код, то он же её и описывает. Если же ошибка была обнаружена
системой, то возникает системное исключение.</p>

<!--\indexC{cerror}-->
<!--\indexR{исключения!возобновление}-->
<!--\indexR{возобновляемые исключения}-->
<!--\indexR{обработка ошибок!с возобновлением}-->
<!--\indexR{исключения!модели обработки}-->
<!--\indexR{модель обработки исключений}-->
<p>Некоторые модели обработки поддерживают возможность возобновления прерванных
вычислений. В случае возникновения некоторых ошибок (в частности,
предусмотренных заранее программистом, вроде вызываемых формой <code><span class="func">cerror</span></code>
в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>) можно попытаться повторить вычисления ещё раз, начиная с того
места, где они были прерваны. Во многих других случаях, к сожалению,
единственным возможным и наиболее адекватным поведением будет переход
куда-нибудь в безопасное место, дабы не усугублять и так непростую ситуацию.</p>

<!--\indexR{раскрутка стека (unwinding)}-->
<p>Модель исключений <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> более чем полна, но её масштабность не особо
сочетается с данной книгой, чьей задачей является рассмотрение сути вещей.
Модель ML не поддерживает возобновление после ошибок; если где-то возникает
исключение, то это вызывает необратимую раскрутку стека до ближайшего
обработчика. Возможно только перебросить исключение дальше, раскручивая стек до
следующего обработчика. В нашем случае подобная модель не подходит, так как при
возникновении ошибки теряется динамическое окружение переменных, а ведь проблема
могла быть именно в нём. Поэтому мы пойдём другим путём. (На его выбор сильное
влияние оказал <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span>.) Сначала мы неформально опишем идею,
а затем плавно перейдём к её реализации.</p>

<!--\indexC{monitor}-->
<!--\indexR{специальные формы!monitor@\protect<code><span class="func">monitor</span></code>}-->
<p id="compilation/exception/par:monitor">Специальная форма
<code><span class="special">monitor</span></code> устанавливает функцию-обработчик исключений на
время вычислений, представляемых её телом. Таким образом, она имеет следующий
синтаксис:</p>

<pre>(<span class="special">monitor</span> <i>обработчик</i> <i>формы</i>...)</pre>

<p>Соответственно, в синтаксическом анализаторе <code><span class="func">meaning</span></code> появляется новое
правило:</p>

<pre>... ((<span class="var">monitor</span>) (<span class="func">meaning-monitor</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">tail?</span>)) ...</pre>

<p><i>Обработчик</i> вычисляется и становится текущим обработчиком исключений.
<i>Формы</i>, составляющие тело <code><span class="func">meaning</span></code>, последовательно вычисляются
внутри неявной формы <code><span class="special">begin</span></code>. Если во время вычислений ничего плохого
не произошло, то <code><span class="special">monitor</span></code> возвращает значение последней вычисленной формы и
устанавливает обратно предыдущий обработчик.</p>

<!--\indexR{исключения!цепочка обработчиков}-->
<!--\indexR{исключения!терминальный обработчик}-->
<!--\indexR{терминальный обработчик исключений}-->
<p>Если же возникает исключительная ситуация, то сначала отыскивается текущий
обработчик, то есть обработчик, ассоциированный с динамически ближайшей формой
<code><span class="special">monitor</span></code>. (На машинном языке это читается как «ближайший к верхушке
стека».) Найденная функция вызывается с двумя аргументами: логическим
значением, показывающим, может ли она возобновить вычисления после завершения
обработки, и объектом, описывающим проблему. Вызов осуществляется специальным
образом, оставляя стек неизменным. Естественно, в самом обработчике также
могут возникнуть ошибки — за них отвечает предыдущий обработчик. Вычисления,
выполняемые при обработке, могут или нормально вернуть значение, или же
прерваться переходом. Если исключение является возобновляемым, то возвращённое
значение становится значением формы, вызвавшей исключение. Если возобновление
запрещено, а значение всё равно возвращается, то возникает новое
(невозобновляемое) исключение, сигнализирующее об этой проблеме. Если же
обработка заканчивается переходом, то наблюдение за ошибками автоматически
передаётся обработчику, ближайшему к новой текущей верхушке стека. В самом низу
стека находится терминальный обработчик исключений. Если по каким-либо причинам
исключение доходит до него, то он останавливает вирутальную машину и возвращает
управление операционной системе.</p>

<div class="image" id="compilation/exception/pic:subj">
<img src="images/png11.png" alt="Конфигурация стека до и после начала обработки исключения" style="width: 4.65in"/>
<span class="caption">Рис. 7.6. Процесс обработки исключения.</span>
</div>

<p>Предобработка превращает форму <code><span class="special">monitor</span></code> в комбинацию двух новых инструкций,
отвечающих за работу со стеком обработчиков исключений:</p>

<!--\indexC{meaning-monitor}-->
<pre>(<span class="special">define</span> (<span class="func">meaning-monitor</span> <span class="var">e</span> <span class="var">e+</span> <span class="var">r</span> <span class="var">tail?</span>)
  (<span class="syntax">let</span> ((<span class="var">m</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r</span> <span class="hash">#f</span>))
        (<span class="var">m+</span> (<span class="func">meaning-sequence</span> <span class="var">e+</span> <span class="var">r</span> <span class="hash">#f</span>)) )
    (<span class="func">append</span> <span class="var">m</span> (<span class="func">PUSH-HANDLER</span>) <span class="var">m+</span> (<span class="func">POP-HANDLER</span>)) ) )

(<span class="special">define</span> (<span class="func">PUSH-HANDLER</span>) (<span class="func">list</span> <span class="num">246</span>))
(<span class="special">define</span> (<span class="func">POP-HANDLER</span>)  (<span class="func">list</span> <span class="num">247</span>))</pre>

<p>Для обработки случаев возобновления невозобновляемого вводится дополнительная
инструкция:</p>

<pre>(<span class="special">define</span> (<span class="func">NON-CONT-ERR</span>) (<span class="func">list</span> <span class="num">245</span>))</pre>

<p>Инструкции <code><span class="func">PUSH-HANDLER</span></code> и <code><span class="func">POP-HANDLER</span></code> можно реализовать по-разному,
так что сразу выделим их в отдельные функции:</p>

<!--\indexC{PUSH-HANDLER}-->
<!--\indexC{POP-HANDLER}-->
<pre>(<span class="syntax">define-instruction</span> (<span class="func">PUSH-HANDLER</span>) <span class="num">246</span>
  (<span class="func">push-exception-handler</span>) )

(<span class="syntax">define-instruction</span> (<span class="func">POP-HANDLER</span>) <span class="num">247</span>
  (<span class="func">pop-exception-handler</span>) )</pre>

<p>Вот теперь примемся за работу. Определить, какой из обработчиков ближе всех
к верхушке стека, не составляет проблем: это типичная задача, решаемая с помощью
динамических переменных. Заодно мы получаем приятный подарок: под стек
обработчиков не потребуется специальный регистр. Вместо этого обработчики можно
расположить в динамической переменной с индексом <code><span class="num">0</span></code>, так как функция
<code><span class="func">get-dynamic-variable-index</span></code> не может выдать этот индекс обычным динамическим
переменным. Хитрость здесь лишь в том, как сделать так, чтобы при выполнении
текущего обработчика возникающие в нём ошибки перенаправлялись предыдущему. Эта
проблема решается связыванием в список значений динамических переменных,
хранимых по индексу <code><span class="num">0</span></code>, что даёт возможность получить доступ к предыдущему
обработчику, не снимая со стека текущий.</p>

<!--\indexC{search-exception-handlers}-->
<!--\indexC{push-exception-handler}-->
<!--\indexC{pop-exception-handler}-->
<pre>(<span class="special">define</span> (<span class="func">search-exception-handlers</span>)
  (<span class="func">find-dynamic-value</span> <span class="num">0</span>) )

(<span class="special">define</span> (<span class="func">push-exception-handler</span>)
  (<span class="syntax">let</span> ((<span class="var">handlers</span> (<span class="func">search-exception-handlers</span>)))
    (<span class="func">push-dynamic-binding</span> <span class="num">0</span> (<span class="func">cons</span> <span class="var">*val*</span> <span class="var">handlers</span>)) ) )

(<span class="special">define</span> (<span class="func">pop-exception-handler</span>)
  (<span class="func">pop-dynamic-binding</span>) )</pre>

<p>Если вычисления проходят гладко, то находящиеся в стеке обработчики
не вмешиваются в работу программы. Но при возникновении исключительной
ситуации вызывается функция <code><span class="func">signal-exception</span></code>, которая является заменой
старой доброй <code><span class="func">wrong</span></code>.</p>

<!--\indexC{signal-exception}-->
<pre>(<span class="special">define</span> (<span class="func">signal-exception</span> <span class="var">continuable?</span> <span class="var">exception</span>)
  (<span class="syntax">let</span> ((<span class="var">handlers</span> (<span class="func">search-exception-handlers</span>))
        (<span class="var">v*</span> (<span class="func">allocate-activation-frame</span> (<span class="func">+</span> <span class="num">2</span> <span class="num">1</span>))) )
    (<span class="func">set-activation-frame-argument!</span> <span class="var">v*</span> <span class="num">0</span> <span class="var">continuable?</span>)
    (<span class="func">set-activation-frame-argument!</span> <span class="var">v*</span> <span class="num">1</span> <span class="var">exception</span>)
    (<span class="special">set!</span> <span class="var">*val*</span> <span class="var">v*</span>)
    (<span class="func">stack-push</span> <span class="var">*pc*</span>) (<span class="func">preserve-environment</span>)
    (<span class="func">push-dynamic-binding</span> <span class="num">0</span> (<span class="special">if</span> (<span class="func">null?</span> (<span class="func">cdr</span> <span class="var">handlers</span>)) <span class="var">handlers</span>
                                (<span class="func">cdr</span> <span class="var">handlers</span>) ))
    (<span class="special">if</span> <span class="var">continuable?</span>
      (<span class="func">stack-push</span> <span class="num">2</span>)   <span class="comment">; выполнится <code>(<span class="func">POP-HANDLER</span>) (<span class="func">RESTORE-ENV</span>) (<span class="func">RETURN</span>)</code></span>
      (<span class="func">stack-push</span> <span class="num">0</span>) ) <span class="comment">; выполнится <code>(<span class="func">NON-CONT-ERR</span>)</code></span>
    (<span class="func">invoke</span> (<span class="func">car</span> <span class="var">handlers</span>) <span class="hash">#t</span>) ) )</pre>

<!--\indexR{исключения!дескрипторы}-->
<p>Функция <code><span class="func">signal-exception</span></code> принимает два аргумента: флаг, указывающий,
допускается ли возобновление выполнения после успешного завершения обработчика,
и значение, описывающее исключение. Это значение может быть абсолютно любым:
например, предопределённые исключения представляются списками из
человекочитаемой строки и дополнительных данных. <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> и <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span>
допускают передачу только объектов специальных классов.</p>

<p>Обработка исключения происходит так. Сначала из динамического окружения
достаётся список активных обработчиков, затем вручную формируется запись
активации, которая будет передана первому из них. После этого специальным
образом подготавливается стек, так как обработчику для правильной работы
необходимо передать некоторую информацию, которой не место в записи активации.
А именно, в стек заталкиваются текущее состояние счётчика команд и окружение (на
случай, если придётся возвращаться). Далее, текущий обработчик исключений хитрым
образом заменяется предыдущим: в динамической переменной сохраняется урезанный
список активных обработчиков, что позволяет элегантно организовать передачу
обязанностей предыдущего обработчика следующему. Так как в этом списке всегда
должен оставаться как минимум один обработчик, то последний из них никогда
не отбрасывается. Естественно, этот терминальный обработчик сам не должен
вызывать исключений; и это действительно так, потому что он лишь сообщает
об ошибке и завершает исполнение программы — тут нечему ломаться.</p>

<!--\indexR{исключения!возобновление!реализация}-->
<p>Итак, как же реализуется возможность возобновления управления после завершения
обработки? Существует простое решение, но оно требует наличия в памяти
определённых инструкций, расположенных по строго определённым абсолютным
адресам. Мы уже расположили <code><span class="func">FINISH</span></code> именно таким образом в прологе,
почему бы не добавить туда ещё немного кода?</p>

<!--\indexC{code-prologue}-->
<pre>(<span class="special">define</span> (<span class="func">code-prologue</span>)
  (<span class="special">set!</span> <span class="var">finish-pc</span> <span class="num">1</span>)
  (<span class="func">append</span> (<span class="func">NON-CONT-ERR</span>) (<span class="func">FINISH</span>) (<span class="func">POP-HANDLER</span>) (<span class="func">RESTORE-ENV</span>) (<span class="func">RETURN</span>)) )</pre>

<p>Теперь проблема возврата решается просто: перед вызовом обработчика достаточно
положить в стек необходимый адрес возврата. Таким образом, <code><span class="func">RETURN</span></code>,
выполненная функцией-обработчиком, перейдёт в ту или иную ветку. Адрес <code><span class="num">0</span></code>
приводит к исполнению инструкции <code><span class="func">NON-CONT-ERR</span></code>, вызывающей новое исключение;
адрес <code><span class="num">2</span></code> приводит к очистке стека от информации об исключении, которую
<code><span class="func">signal-exception</span></code> туда положила, восстановлению сохранённого ранее окружения
и возврату управления назад в то место, где произошла ошибка.</p>


<!--\indexC{NON-CONT-ERR}-->
<pre>(<span class="syntax">define-instruction</span> (<span class="func">NON-CONT-ERR</span>) <span class="num">245</span>
  (<span class="func">signal-exception</span> <span class="hash">#f</span> (<span class="func">list</span> <span class="string">"Non continuable exception continued"</span>)) )</pre>

<p>Вот и всё, осталось только показать, как запускать виртуальную машину с учётом
данных нововведений. Функция <code><span class="func">run-machine</span></code> теперь должна корректным образом
устанавливать терминальный обработчик исключений. Его можно реализовать,
например, так, чтобы он выводил состояние машины и останавливал её. Без
лишних слов:</p>

<!--\indexC{run-machine}-->
<!--\indexC{base-error-handler}-->
<pre>(<span class="special">define</span> (<span class="func">run-machine</span> <span class="var">stack-size</span> <span class="var">pc</span> <span class="var">code</span> <span class="var">constants</span> <span class="var">global-names</span> <span class="var">dynamics</span>)
  (<span class="special">define</span> <span class="var">base-error-handler-primitive</span>
    (<span class="func">make-primitive</span> <span class="var">base-error-handler</span>) )
  (<span class="special">set!</span> <span class="var">sg.current</span> (<span class="func">make-vector</span> (<span class="func">length</span> <span class="var">global-names</span>) <span class="var">undefined-value</span>))
  (<span class="special">set!</span> <span class="var">sg.current.names</span> <span class="var">global-names</span>)
  (<span class="special">set!</span> <span class="var">*constants*</span>         <span class="var">constants</span>)
  (<span class="special">set!</span> <span class="var">*dynamic-variables*</span> <span class="var">dynamics</span>)
  (<span class="special">set!</span> <span class="var">*code*</span>              <span class="var">code</span>)
  (<span class="special">set!</span> <span class="var">*env*</span>               <span class="var">sr.init</span>)
  (<span class="special">set!</span> <span class="var">*stack*</span>             (<span class="func">make-vector</span> <span class="var">stack-size</span>))
  (<span class="special">set!</span> <span class="var">*stack-index*</span>       <span class="num">0</span>)
  (<span class="special">set!</span> <span class="var">*val*</span>               '<span class="var">anything</span>)
  (<span class="special">set!</span> <span class="var">*fun*</span>               '<span class="var">anything</span>)
  (<span class="special">set!</span> <span class="var">*arg1*</span>              '<span class="var">anything</span>)
  (<span class="special">set!</span> <span class="var">*arg2*</span>              '<span class="var">anything</span>)
  (<span class="func">push-dynamic-binding</span> <span class="num">0</span> (<span class="func">list</span> <span class="var">base-error-handler-primitive</span>))
  (<span class="func">stack-push</span> <span class="var">finish-pc</span>)
  (<span class="special">set!</span> <span class="var">*pc*</span> <span class="var">pc</span>)
  (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">exit</span>)
             (<span class="special">set!</span> <span class="var">*exit*</span> <span class="var">exit</span>)
             (<span class="func">run</span>) )) )

(<span class="special">define</span> (<span class="func">base-error-handler</span>)
  (<span class="func">show-registers</span> <span class="string">"Panic error! Contents of registers:"</span>)
  (<span class="func">wrong</span> <span class="string">"Abort"</span>) )</pre>

<p>Функция <code><span class="func">signal-exception</span></code> легко превращается в доступный пользователям языка
примитив, что позволяет использовать её (вместе с <code><span class="special">monitor</span></code>) подобно
<code><span class="func">cerror</span></code>/<code><span class="func">error</span></code> в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> и <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span> для обработки
пользовательских исключений. Однако, ввиду относительно высокой стоимости
вызова, стоит ограничить применения данного механизма действительно
<em>исключительными</em> ситуациями.</p>

<div class="bigskip"/>

<p>В этом разделе была определена система обработки исключений. Рассмотренная
модель позволяет вернуться из обработчика обратно и попробовать выполнить
вычисления ещё раз. Также обработчик вызывается в том же динамическом окружении,
где произошло исключение, что даёт больше возможностей для определения причин
возникшей аномалии. Например, с помощью данной системы мы можем написать
следующую весьма нестандартную версию факториала:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">monitor</span> (<span class="special">lambda</span> (<span class="var">c</span> <span class="var">e</span>) ((<span class="special">dynamic</span> <span class="var">foo</span>) <span class="num">1</span>))
  (<span class="syntax">let</span> <span class="func">fact</span> ((<span class="var">n</span> <span class="num">5</span>))
    (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">/</span> <span class="num">11</span> <span class="num">0</span>)
        (<span class="func">*</span> <span class="var">n</span> (<span class="special">bind-exit</span> (<span class="var">k</span>)
               (<span class="special">dynamic-let</span> (<span class="var">foo</span> <span class="var">k</span>)
                 (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)) ) )) ) ) )</pre>

<p>Не следует вызывать переходы из ошибочного контекста в попытке быстро исправить
ситуацию. Лучше сообщить об ошибке с помощью исключения и иметь в результате
больше доступной информации о проблеме.</p>

<!--\indexR{инструкции!и исключения}-->
<!--\indexR{исключения!и атомарность инструкций}-->
<p>В силу того, что наша виртуальная машина — это лишь интерпретатор байт-кодов,
система обработки исключений получилась относительно простой. Дело в том, что
у нас ошибки могут возникнуть только в процессе исполнения какой-либо
инструкции, а сами инструкции являются независимыми друг от друга. По крайней
мере, состояние машины чётко определено в промежутках времени между исполнением
инструкций. Для реальной машины это отнюдь не так и существует множество
возможностей оставить её в неопределённом состоянии, например, какое-нибудь
неожиданно полученное асинхронное прерывание.</p>

<!--\indexR{исключения!возобновление!и системные ошибки}-->
<p>У вас может возникнуть вопрос, почему некоторые предопределённые исключения
являются возобновляемыми, а другие нет. Как уже было сказано, виртуальная машина
работает с завидной аккуратностью, так что возобновить исполнение программы
принципиально возможно после любого исключения, так как у нас всегда будет на
руках точное значение счётчика команд. И снова, всё гораздо усложняется
в реальности, где процессоры могут переупорядочивать исполняемые инструкции, а
какое-нибудь деление на ноль, например, может быть обработано только постфактум.
Безопаснее всего предполагать, что только для пользовательских исключений можно
обеспечить переносимую и корректную логику работы после возобновления исполнения
прерванного кода. Маловероятно, что программа сможет исправить ошибку, возникшую
в самой системе.</p>

<p>Кстати, с этим связан ещё один интересный момент. Вспомните, что все ошибки
предобработки теперь вызывают <code><span class="func">signal-exception</span></code>, иногда даже допуская
возобновление. И в этом действительно есть определённый смысл: компилятор,
используя специальный обработчик исключений, получает возможность самостоятельно
исправлять некоторые недосмотры предобработки на лету.</p>


<h2 id="compilation/sect:separate"><span class="wrap"><span class="seq">7.10.</span><span class="title">Раздельная компиляция</span></span></h2>

<!--\indexR{компиляция!раздельная}-->
<p>Программы на языках вроде Си и Паскаля обычно компилируются и сохраняются
в файлах. Лисп ничем не хуже, так что в этом разделе мы создадим подобный
компилятор, а также компоновщик, собирающий отдельные кусочки кода воедино,
и загрузчик, запускающий полученные программы.</p>


<h3 id="compilation/separate/ssect:files"><span class="wrap"><span class="seq">7.10.1.</span><span class="title">Компилируем файлы</span></span></h3>

<p>Откомпилировать программу, хранящуюся в файле, проще простого. Этим занимается
функция <code><span class="func">compile-file</span></code>, показанная ниже. Сначала она инициализирует списки
глобальных переменных <code><span class="var">g.current</span></code> и цитат <code><span class="var">*quotations*</span></code>, а также список
<code><span class="var">*dynamic-variables*</span></code>. Затем выражения, считанные из файла, компилируются
так, как будто бы все они находятся в огромной форме <code><span class="special">begin</span></code>, а
результат компиляции записывается в другой файл вместе со значениями трёх
вышеупомянутых переменных.</p>

<!--\indexC{read-file}-->
<!--\indexC{compile-file}-->
<!--\indexC{write-result-file}-->
<pre>(<span class="special">define</span> (<span class="func">read-file</span> <span class="var">filename</span>)
  (<span class="func">call-with-input-file</span> <span class="var">filename</span>
    (<span class="special">lambda</span> (<span class="var">in</span>)
      (<span class="syntax">let</span> <span class="func">gather</span> ((<span class="var">e</span> (<span class="func">read</span> <span class="var">in</span>)) (<span class="var">content</span> <span class="hash">'()</span>))
        (<span class="special">if</span> (<span class="func">eof-object?</span> <span class="var">e</span>)
            (<span class="func">reverse</span> <span class="var">content</span>)
            (<span class="func">gather</span> (<span class="func">read</span> <span class="var">in</span>) (<span class="func">cons</span> <span class="var">e</span> <span class="var">content</span>)) ) ) ) ) )

(<span class="special">define</span> (<span class="func">compile-file</span> <span class="var">filename</span>)
  (<span class="special">set!</span> <span class="var">g.current</span> '())
  (<span class="special">set!</span> <span class="var">*quotations*</span> '())
  (<span class="special">set!</span> <span class="var">*dynamic-variables*</span> '())
  (<span class="syntax">let*</span> ((<span class="var">complete-filename</span> (<span class="func">string-append</span> <span class="var">filename</span> <span class="string">".scm"</span>))
         (<span class="var">e</span>                 `(<span class="special">begin</span> . ,(<span class="func">read-file</span> <span class="var">complete-filename</span>)))
         (<span class="var">code</span>              (<span class="func">make-code-segment</span> (<span class="func">meaning</span> <span class="var">e</span> <span class="var">r.init</span> <span class="hash">#t</span>)))
         (<span class="var">global-names</span>      (<span class="func">map</span> <span class="var">car</span> (<span class="func">reverse</span> <span class="var">g.current</span>)))
         (<span class="var">constants</span>         (<span class="func">apply</span> <span class="var">vector</span> <span class="var">*quotations*</span>))
         (<span class="var">dynamics</span>          <span class="var">*dynamic-variables*</span>)
         (<span class="var">ofilename</span>         (<span class="func">string-append</span> <span class="var">filename</span> <span class="string">".so"</span>)) )
    (<span class="func">write-result-file</span> <span class="var">ofilename</span>
                       (<span class="func">list</span> <span class="string">";;; Bytecode object file for "</span>
                             <span class="var">complete-filename</span> )
                       <span class="var">dynamics</span> <span class="var">global-names</span> <span class="var">constants</span> <span class="var">code</span>
                       (<span class="func">length</span> (<span class="func">code-prologue</span>)) ) ) )

(<span class="special">define</span> (<span class="func">write-result-file</span> <span class="var">ofilename</span> <span class="var">comments</span> <span class="var">dynamics</span>
                           <span class="var">global-names</span> <span class="var">constants</span> <span class="var">code</span> <span class="var">entry</span> )
  (<span class="func">call-with-output-file</span> <span class="var">ofilename</span>
    (<span class="special">lambda</span> (<span class="var">out</span>)
      (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">comment</span>) (<span class="func">display</span> <span class="var">comment</span> <span class="var">out</span>))
                <span class="var">comments</span> ) (<span class="func">newline</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)

      (<span class="func">display</span> <span class="string">";;; Dynamic variables"</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)
      (<span class="func">write</span> <span class="var">dynamics</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)

      (<span class="func">display</span> <span class="string">";;; Global modifiable variables"</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)
      (<span class="func">write</span> <span class="var">global-names</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)

      (<span class="func">display</span> <span class="string">";;; Quotations"</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)
      (<span class="func">write</span> <span class="var">constants</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)

      (<span class="func">display</span> <span class="string">";;; Bytecode"</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)
      (<span class="func">write</span> <span class="var">code</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)

      (<span class="func">display</span> <span class="string">";;; Entry point"</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>)
      (<span class="func">write</span> <span class="var">entry</span> <span class="var">out</span>) (<span class="func">newline</span> <span class="var">out</span>) ) ) )</pre>

<!--\indexC{*.scm}-->
<!--\indexC{*.so}-->
<!--\indexR{объектные файлы}-->
<p>Дабы не завязнуть в трясине различий файловых систем и способов записи путей,
предполагается, что имена файлов записываются простыми строками. Компилятор
понимает переданную ему строку как полное название файла. (Под названием
подразумевается часть имени без обычного расширения <code>.scm</code>.) Программа
читается из <code>*.scm</code>-файла, а результат компиляции сохраняется
в <code>*.so</code>-файл. Этот результат состоит из байт-кода, списка глобальных
изменяемых переменных, списка динамических переменных, вектора цитат и точки
входа — начального значения счётчика команд. Всё это записывается в файл без
особых изысков с помощью стандартной функции <code><span class="func">write</span></code>. Также там оставляется
немного комментариев, чтобы облегчить чтение результата человеком.</p>

<p>Итого, компиляция такого исходного файла:</p>

<!--\indexC{fact}-->
<div class="snippet"><span class="title">si/example.scm</span>
<pre>(<span class="special">set!</span> <span class="var">fact</span>
      ((<span class="special">lambda</span> (<span class="var">fact</span>) (<span class="special">lambda</span> (<span class="var">n</span>)
                        (<span class="special">if</span> (<span class="func">&lt;</span> <span class="var">n</span> <span class="num">0</span>)
                            <span class="string">"Toctoc la tete!"</span>
                            (<span class="func">fact</span> <span class="var">n</span> <span class="var">fact</span> (<span class="special">lambda</span> (<span class="var">x</span>) <span class="var">x</span>)) ) ))
       (<span class="special">lambda</span> (<span class="var">n</span> <span class="var">f</span> <span class="var">k</span>)
         (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>)
             (<span class="func">k</span> <span class="num">1</span>)
             (<span class="func">f</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">f</span> (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>)))) ) ) ) )</pre></div>

<p class="noindent">создаёт следующий объектный файл:</p>

<div class="snippet"><span class="title">si/example.so</span>
<pre><span class="comment">;;; Bytecode object file for si/example.scm</span>

<span class="comment">;;; Dynamic variables</span>
()

<span class="comment">;;; Global modifiable variables</span>
(<span class="var">FACT</span>)

<span class="comment">;;; Quotations</span>
#(<span class="string">"Toctoc la tete!"</span>)

<span class="comment">;;; Bytecode</span>
#(<span class="num">245</span> <span class="num">20</span> <span class="num">247</span> <span class="num">38</span> <span class="num">43</span> <span class="num">40</span> <span class="num">30</span> <span class="num">59</span> <span class="num">74</span> <span class="num">32</span> <span class="num">1</span> <span class="num">34</span> <span class="num">81</span> <span class="num">35</span> <span class="num">106</span> <span class="num">31</span> <span class="num">10</span> <span class="num">3</span> <span class="num">34</span> <span class="num">82</span> <span class="num">34</span> <span class="num">51</span>
  <span class="num">60</span> <span class="num">39</span> <span class="num">46</span> <span class="num">30</span> <span class="num">39</span> <span class="num">2</span> <span class="num">34</span> <span class="num">1</span> <span class="num">34</span> <span class="num">82</span> <span class="num">35</span> <span class="num">105</span> <span class="num">34</span> <span class="num">2</span> <span class="num">34</span> <span class="num">40</span> <span class="num">30</span> <span class="num">19</span> <span class="num">72</span> <span class="num">32</span> <span class="num">6</span> <span class="num">1</span> <span class="num">2</span> <span class="num">34</span>
  <span class="num">6</span> <span class="num">1</span> <span class="num">0</span> <span class="num">34</span> <span class="num">1</span> <span class="num">35</span> <span class="num">109</span> <span class="num">34</span> <span class="num">51</span> <span class="num">60</span> <span class="num">39</span> <span class="num">46</span> <span class="num">43</span> <span class="num">34</span> <span class="num">53</span> <span class="num">62</span> <span class="num">61</span> <span class="num">60</span> <span class="num">39</span> <span class="num">46</span> <span class="num">43</span> <span class="num">34</span> <span class="num">51</span>
  <span class="num">60</span> <span class="num">32</span> <span class="num">40</span> <span class="num">30</span> <span class="num">38</span> <span class="num">72</span> <span class="num">32</span> <span class="num">1</span> <span class="num">34</span> <span class="num">81</span> <span class="num">35</span> <span class="num">107</span> <span class="num">31</span> <span class="num">4</span> <span class="num">9</span> <span class="num">0</span> <span class="num">30</span> <span class="num">24</span> <span class="num">6</span> <span class="num">1</span> <span class="num">0</span> <span class="num">34</span> <span class="num">1</span> <span class="num">34</span> <span class="num">6</span>
  <span class="num">1</span> <span class="num">0</span> <span class="num">34</span> <span class="num">40</span> <span class="num">30</span> <span class="num">4</span> <span class="num">72</span> <span class="num">32</span> <span class="num">1</span> <span class="num">43</span> <span class="num">34</span> <span class="num">53</span> <span class="num">62</span> <span class="num">61</span> <span class="num">60</span> <span class="num">39</span> <span class="num">46</span> <span class="num">43</span> <span class="num">33</span> <span class="num">27</span> <span class="num">0</span> <span class="num">43</span>)

<span class="comment">;;; Entry point</span>
<span class="num">5</span></pre></div>


<h3 id="compilation/separate/ssect:build"><span class="wrap"><span class="seq">7.10.2.</span><span class="title">Собираем приложение</span></span></h3>

<!--\indexC{ld}-->
<!--\indexR{компоновка}-->
<!--\indexR{линкер}-->
<!--\indexR{линкер|see{компоновка}}-->
<p>Возможность компилировать отдельные файлы — это, конечно, здорово, но неплохо
было бы запускать всё приложение целиком! Вторая утилита, которую мы создадим,
соответствует тому, что называется <em class="term">компоновщиком</em> (линкером,
<code>ld</code> в UNIX). Её задачей является связывание нескольких отдельных объектных файлов
в единый исполнимый файл. Функция <code><span class="func">build-application</span></code> принимает имя
результирующего исполнимого файла, а затем имена компонуемых объектных файлов.</p>


<!--\indexC{build-application}-->
<pre>(<span class="special">define</span> (<span class="func">build-application</span> <span class="var">application-name</span> <span class="var">ofilename</span> . <span class="var">ofilenames</span>)
  (<span class="special">set!</span> <span class="var">sg.current.names</span>    <span class="hash">'()</span>)
  (<span class="special">set!</span> <span class="var">*dynamic-variables*</span> <span class="hash">'()</span>)
  (<span class="special">set!</span> <span class="var">sg.current</span>          (<span class="func">vector</span>))
  (<span class="special">set!</span> <span class="var">*constants*</span>         (<span class="func">vector</span>))
  (<span class="special">set!</span> <span class="var">*code*</span>              (<span class="func">vector</span>))
  (<span class="syntax">let</span> <span class="func">install</span> ((<span class="var">filenames</span> (<span class="func">cons</span> <span class="var">ofilename</span> <span class="var">ofilenames</span>))
                (<span class="var">entry-points</span> <span class="hash">'()</span>) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">filenames</span>)
        (<span class="syntax">let</span> ((<span class="var">ep</span> (<span class="func">install-object-file!</span> (<span class="func">car</span> <span class="var">filenames</span>))))
          (<span class="func">install</span> (<span class="func">cdr</span> <span class="var">filenames</span>) (<span class="func">cons</span> <span class="var">ep</span> <span class="var">entry-points</span>)) )
        (<span class="func">write-result-file</span> <span class="var">application-name</span>
                           (<span class="func">cons</span> <span class="string">";;; Bytecode application containing "</span>
                                 (<span class="func">cons</span> <span class="var">ofilename</span> <span class="var">ofilenames</span>) )
                           <span class="var">*dynamic-variables*</span>
                           <span class="var">sg.current.names</span>
                           <span class="var">*constants*</span>
                           <span class="var">*code*</span>
                           <span class="var">entry-points</span> ) ) ) )</pre>

<!--\indexR{исполнимый файл}-->
<p>Большая часть работы поручается функции
<code><span class="func">install-object-file!</span></code>, которая
формирует пять переменных, необходимых для обеспечения корректной работы машины:</p>

<ul>
  <li><code><span class="var">sg.current.names</span></code> —
    имена изменяемых глобальных переменных;</li>

  <li><code><span class="var">*dynamic-variables*</span></code> —
    имена динамических переменных;</li>

  <li><code><span class="var">sg.current</span></code> —
    значения изменяемых глобальных переменных;</li>

  <li><code><span class="var">*constants*</span></code> —
    значения цитат;</li>

  <li><code><span class="var">*code*</span></code> —
    вектор байт-кодов.</li>
</ul>

<p class="noindent">После сборки всех объектных файлов остаётся только создать записать результат
в исполнимый файл. Его формат совпадает с форматом объектных файлов во всём,
кроме точки входа: теперь это будет список точек входа.</p>

<p>Функция <code><span class="func">install-object-file!</span></code> добавляет один скомпилированный файл
в приложение и возвращает адрес его первой инструкции в едином векторе
байт-кодов. Дописать немного кода в вектор <code><span class="var">*code*</span></code> просто. Гораздо сложнее
защитить то, что является личной собственностью отдельных файлов, и разделить
между всеми файлами то, что должно быть общим. В следующем коде эту нелёгкую
работу выполняют функции, начинающиеся на <code><span class="func">relocate</span></code>.</p>

<!--\indexC{install-object-file"!}-->
<!--\indexC{install-code"!}-->
<pre>(<span class="special">define</span> (<span class="func">install-object-file!</span> <span class="var">filename</span>)
  (<span class="syntax">let</span> ((<span class="var">ofilename</span> (<span class="func">string-append</span> <span class="var">filename</span> <span class="string">".so"</span>)))
    (<span class="special">if</span> (<span class="func">probe-file</span> <span class="var">ofilename</span>)
        (<span class="func">call-with-input-file</span> <span class="var">ofilename</span>
          (<span class="special">lambda</span> (<span class="var">in</span>)
            (<span class="syntax">let*</span> ((<span class="var">dynamics</span>     (<span class="func">read</span> <span class="var">in</span>))
                   (<span class="var">global-names</span> (<span class="func">read</span> <span class="var">in</span>))
                   (<span class="var">constants</span>    (<span class="func">read</span> <span class="var">in</span>))
                   (<span class="var">code</span>         (<span class="func">read</span> <span class="var">in</span>))
                   (<span class="var">entry</span>        (<span class="func">read</span> <span class="var">in</span>)) )
              (<span class="func">close-input-port</span> <span class="var">in</span>)
              (<span class="func">relocate-globals!</span> <span class="var">code</span> <span class="var">global-names</span>)
              (<span class="func">relocate-constants!</span> <span class="var">code</span> <span class="var">constants</span>)
              (<span class="func">relocate-dynamics!</span> <span class="var">code</span> <span class="var">dynamics</span>)
              (<span class="func">+</span> <span class="var">entry</span> (<span class="func">install-code!</span> <span class="var">code</span>)) ) ) )
        (<span class="func">signal-exception</span> <span class="hash">#f</span>
          (<span class="func">list</span> <span class="string">"No such file"</span> <span class="var">ofilename</span>) ) ) ) )

(<span class="special">define</span> (<span class="func">install-code!</span> <span class="var">code</span>)
  (<span class="syntax">let</span> ((<span class="var">start</span> (<span class="func">vector-length</span> <span class="var">*code*</span>)))
    (<span class="special">set!</span> <span class="var">*code*</span> (<span class="func">vector-append</span> <span class="var">*code*</span> <span class="var">code</span>))
    <span class="var">start</span> ) )</pre>

<!--\indexR{компоновка!цитат}-->
<p>Цитаты, например, у каждого файла свои собственные, они не должны совпадать даже
физически. Но в каждом файле они заново нумеруются с нуля, что обязательно
приведёт к коллизиям, если ничего не предпринять. Общий учёт используемых цитат
ведётся в переменной <code><span class="var">*constants*</span></code>, но новые цитаты добавляются туда
не сразу, а после аккуратного обновления их номеров, являющихся адресами
соответствующих значений в общем векторе. Номер цитаты, как вы помните,
располагается сразу же за кодом инструкции <code><span class="func">CONSTANT</span></code>. Следующая функция
пробегает по всему вектору байт-кодов, отыскивает все нужные инструкции и
заменяет старые адреса новыми:</p>

<!--\indexC{relocate-constants"!}-->
<pre>(<span class="special">define</span> <span class="var">CONSTANT-code</span> <span class="num">9</span>)

(<span class="special">define</span> (<span class="func">relocate-constants!</span> <span class="var">code</span> <span class="var">constants</span>)
  (<span class="special">define</span> <span class="var">n</span> (<span class="func">vector-length</span> <span class="var">*constants*</span>))
  (<span class="syntax">let</span> ((<span class="var">code-size</span> (<span class="func">vector-length</span> <span class="var">code</span>)))
    (<span class="syntax">let</span> <span class="func">scan</span> ((<span class="var">pc</span> <span class="num">0</span>))
      (<span class="syntax">when</span> (<span class="func">&lt;</span> <span class="var">pc</span> <span class="var">code-size</span>)
        (<span class="syntax">let</span> ((<span class="var">instr</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
          (<span class="syntax">when</span> (<span class="func">=</span> <span class="var">instr</span> <span class="var">CONSTANT-code</span>)
            (<span class="syntax">let*</span> ((<span class="var">i</span> (<span class="func">vector-ref</span> <span class="var">code</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>)))
                   (<span class="var">quotation</span> (<span class="func">vector-ref</span> <span class="var">constants</span> <span class="var">i</span>)) )
              (<span class="func">vector-set!</span> <span class="var">code</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>) (<span class="func">+</span> <span class="var">n</span> <span class="var">i</span>)) ) )
          (<span class="func">scan</span> (<span class="func">+</span> <span class="var">pc</span> (<span class="func">instruction-size</span> <span class="var">code</span> <span class="var">pc</span>))) ) ) ) )
  (<span class="special">set!</span> <span class="var">*constants*</span> (<span class="func">vector-append</span> <span class="var">*constants*</span> <span class="var">constants</span>)) )</pre>

<!--\indexR{компоновка!глобальных переменных}-->
<p>Глобальные переменные, напротив, должны разделяться. Два файла, использующих
<code><span class="var">foo</span></code>, должны обращаться к одной и той же переменной <code><span class="var">foo</span></code>. Эти переменные
нумеруются в каждом файле независимо, поэтому при компоновке необходимо
согласовать их адреса. Эти адреса представляются числами, следующими за
инструкциями <code><span class="func">GLOBAL-REF</span></code>, <code><span class="func">CHECKED-GLOBAL-REF</span></code> и <code><span class="func">SET-GLOBAL!</span></code>. Каждое
найденное число соответствует имени переменной; этому же имени соответствует
другое число — адрес переменной в собираемой программе. Остаётся только
заменить везде первое вторым.</p>

<!--\indexC{relocate-globals"!}-->
<pre>(<span class="special">define</span> <span class="var">GLOBAL-REF-code</span>         <span class="num">7</span>)
(<span class="special">define</span> <span class="var">CHECKED-GLOBAL-REF-code</span> <span class="num">8</span>)
(<span class="special">define</span> <span class="var">SET-GLOBAL!-code</span>       <span class="num">27</span>)

(<span class="special">define</span> (<span class="func">relocate-globals!</span> <span class="var">code</span> <span class="var">global-names</span>)
  (<span class="special">define</span> (<span class="func">get-index</span> <span class="var">name</span>)
    (<span class="syntax">let</span> ((<span class="var">where</span> (<span class="func">memq</span> <span class="var">name</span> <span class="var">sg.current.names</span>)))
      (<span class="special">if</span> <span class="var">where</span> (<span class="func">-</span> (<span class="func">length</span> <span class="var">where</span>) <span class="num">1</span>)
          (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">sg.current.names</span> (<span class="func">cons</span> <span class="var">name</span> <span class="var">sg.current.names</span>))
                 (<span class="func">get-index</span> <span class="var">name</span>) ) ) ) )
  (<span class="syntax">let</span> ((<span class="var">code-size</span> (<span class="func">vector-length</span> <span class="var">code</span>)))
    (<span class="syntax">let</span> <span class="func">scan</span> ((<span class="var">pc</span> <span class="num">0</span>))
      (<span class="syntax">when</span> (<span class="func">&lt;</span> <span class="var">pc</span> <span class="var">code-size</span>)
        (<span class="syntax">let</span> ((<span class="var">instr</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
          (<span class="syntax">when</span> (<span class="syntax">or</span> (<span class="func">=</span> <span class="var">instr</span> <span class="var">GLOBAL-REF-code</span>)
                    (<span class="func">=</span> <span class="var">instr</span> <span class="var">CHECKED-GLOBAL-REF-code</span>)
                    (<span class="func">=</span> <span class="var">instr</span> <span class="var">SET-GLOBAL!-code</span>) )
            (<span class="syntax">let*</span> ((<span class="var">i</span> (<span class="func">vector-ref</span> <span class="var">code</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>)))
                   (<span class="var">name</span> (<span class="func">list-ref</span> <span class="var">global-names</span> <span class="var">i</span>)) )
              (<span class="func">vector-set!</span> <span class="var">code</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>) (<span class="func">get-index</span> <span class="var">name</span>)) ) )
          (<span class="func">scan</span> (<span class="func">+</span> <span class="var">pc</span> (<span class="func">instruction-size</span> <span class="var">code</span> <span class="var">pc</span>))) ) ) ) )
  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">make-vector</span> (<span class="func">length</span> <span class="var">sg.current.names</span>) <span class="var">undefined-value</span>)))
    (<span class="func">vector-copy!</span> <span class="var">sg.current</span> <span class="var">v</span> <span class="num">0</span> (<span class="func">vector-length</span> <span class="var">sg.current</span>))
    (<span class="special">set!</span> <span class="var">sg.current</span> <span class="var">v</span>) ) )</pre>

<!--\indexR{компоновка!динамических переменных}-->
<p>Аналогично поступаем с динамическими переменными:</p>

<!--\indexC{relocate-dynamics"!}-->
<pre>(<span class="special">define</span> <span class="var">DYNAMIC-REF-code</span> <span class="num">240</span>)
(<span class="special">define</span> <span class="var">DYNAMIC-PUSH-code</span> <span class="num">242</span>)

(<span class="special">define</span> (<span class="func">relocate-dynamics!</span> <span class="var">code</span> <span class="var">dynamics</span>)
  (<span class="func">for-each</span> <span class="var">get-dynamic-variable-index</span> <span class="var">dynamics</span>)
  (<span class="syntax">let</span> ((<span class="var">dynamics</span> (<span class="func">reverse</span> <span class="var">dynamics</span>))
        (<span class="var">code</span> <span class="var">size</span> (<span class="func">vector-length</span> <span class="var">code</span>)) )
    (<span class="syntax">let</span> <span class="func">scan</span> ((<span class="var">pc</span> <span class="num">0</span>))
      (<span class="syntax">when</span> (<span class="func">&lt;</span> <span class="var">pc</span> <span class="var">code-size</span>)
        (<span class="syntax">let</span> ((<span class="var">instr</span> (<span class="func">vector-ref</span> <span class="var">code</span> <span class="var">pc</span>)))
          (<span class="syntax">when</span> (<span class="syntax">or</span> (<span class="func">=</span> <span class="var">instr</span> <span class="var">DYNAMIC-REF-code</span>)
                    (<span class="func">=</span> <span class="var">instr</span> <span class="var">DYNAMIC-PUSH-code</span>) )
            (<span class="syntax">let*</span> ((<span class="var">i</span> (<span class="func">vector-ref</span> <span class="var">code</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>)))
                   (<span class="var">name</span> (<span class="func">list-ref</span> <span class="var">dynamics</span> (<span class="func">-</span> <span class="var">i</span> <span class="num">1</span>))) )
              (<span class="func">vector-set!</span> <span class="var">code</span> (<span class="func">+</span> <span class="var">pc</span> <span class="num">1</span>)
                           (<span class="func">get-dynamic-variable-index</span> <span class="var">name</span>) ) ) )
          (<span class="func">scan</span> (<span class="func">+</span> <span class="var">pc</span> (<span class="func">instruction-size</span> <span class="var">code</span> <span class="var">pc</span>))) ) ) ) ) )</pre>

<p>Обратите внимание на то, как и почему здесь используется
<code><span class="func">instruction-size</span></code>. Также стоит отметить, что глупо просматривать вектор
кода три раза подряд, вполне можно выполнить всю работу и за один проход.</p>

<!--\indexR{компиляция!модулей}-->
<!--\indexR{язык!описания модулей}-->
<!--\indexR{модули}-->
<p id="compilation/separate/build/par:linker-dsl">Выбранный формат представления
скомпилированных программ позволяет множество вариаций. Например, можно понимать
список глобальных изменяемых переменных как интерфейс к модулю, которым является файл.
Такой модуль экспортирует все свои глобальные переменные для внешнего использования
под теми именами, которые они
имеют внутри данного модуля. Однако, нехорошо выставлять напоказ всё подряд,
так что вдобавок к этому можно, например, разрешить экспортировать не все
переменные или же дать возможность переименовывать их при экспорте. Можно даже
представить себе специализированный язык для описания способов сборки модулей,
управления именованием переменных и т. д. Поясним эту идею на примере языка,
предлагаемого в <span class="cite">[<a href="z1_bibliography.xhtml#qp91a">QP91a</a>]</span> для <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span>. Следующая директива описывает
экспортируемые переменные модуля <code><span class="var">mod</span></code>:</p>

<pre>(<span class="syntax">ordered-union</span>
  (<span class="syntax">only</span> (<span class="var">fact</span>) (<span class="syntax">expose</span> <span class="string">"fact"</span>))
  (<span class="syntax">union</span> (<span class="syntax">except-pattern</span> (<span class="string">"fib*"</span>) (<span class="syntax">expose</span> <span class="string">"fib"</span>))
         (<span class="syntax">rename</span> ((<span class="var">call/cc</span> <span class="var">call-with-current-continuation</span>))
           (<span class="syntax">expose</span> <span class="string">"scheme"</span>) )
         (<span class="syntax">expose</span> <span class="string">"numeric"</span>) ) )</pre>

<p>Предположим, запись <code><span class="var">foo@mod</span></code> означает переменную с именем <code><span class="var">foo</span></code> в модуле
<code><span class="var">mod</span></code>. Также допустим, что модуль <code><span class="var">fact</span></code> определяет переменные <code><span class="var">fact</span></code> и
<code><span class="var">fact100</span></code> (последняя содержит значение <code>(<span class="func">fact</span> <span class="num">100</span>)</code>, которое очень часто
бывает необходимым); модуль <code><span class="var">fib</span></code> определяет переменные <code><span class="var">fib</span></code>, <code><span class="var">fib20</span></code>
и <code><span class="var">Fibonacci</span></code>. Модуль <code><span class="var">numeric</span></code> среди множества определяемых им функций
содержит также <code><span class="var">fact</span></code> и <code><span class="var">fib</span></code>, а модуль <code><span class="var">scheme</span></code> определяет все
стандартные функции R<sup>5</sup>RS. Тогда создаваемый данной директивой модуль состоит из
следующих частей: переменной <code><span class="var">fact@fact</span></code> (а переменная <code><span class="var">fact100@fact</span></code>,
экспортируемая директивой <code>(<span class="syntax">expose</span> <span class="string">"fact"</span>)</code>, отбрасывается директивой
<code><span class="syntax">only</span></code>); переменной <code><span class="var">Fibonacci@fib</span></code> (все остальные фильтруются по шаблону
с помощью <code><span class="syntax">except-pattern</span></code>). Экспортируемая переменная
<code><span class="var">call-with-current-continuation@scheme</span></code> становится просто
<code><span class="var">call/cc@scheme</span></code>. Так как объединение, определяющее <code><span class="var">mod</span></code>, объявлено
как упорядоченное (ordered union), то модуль <code><span class="var">fact</span></code> загружается
перед остальными (<code><span class="var">fib</span></code>, <code><span class="var">numeric</span></code> и <code><span class="var">scheme</span></code>), порядок обработки
которых не указывается, но должен соответствовать их определениям. Например,
модуль <code><span class="var">numeric</span></code> наверняка использует возможности <code><span class="var">scheme</span></code>, поэтому его
следует обрабатывать одним из последних.</p>


<h3 id="compilation/separate/ssect:execute"><span class="wrap"><span class="seq">7.10.3.</span><span class="title">Запускаем приложение</span></span></h3>

<!--\indexR{загрузчик}-->
<p>Исполнимый файл создаётся, конечно же, для того, чтобы его исполняли. Благо,
все сложности уже позади и написать загрузчик не составляет труда. Нужна только
внимательность, чтобы не забыть проинициализировать какой-нибудь регистр.</p>


<!--\indexC{run-application}-->
<pre>(<span class="special">define</span> (<span class="func">run-application</span> <span class="var">stack-size</span> <span class="var">filename</span>)
  (<span class="special">if</span> (<span class="func">probe-file</span> <span class="var">filename</span>)
      (<span class="func">call-with-input-file</span> <span class="var">filename</span>
        (<span class="special">lambda</span> (<span class="var">in</span>)
          (<span class="syntax">let*</span> ((<span class="var">dynamics</span>     (<span class="func">read</span> <span class="var">in</span>))
                 (<span class="var">global-names</span> (<span class="func">read</span> <span class="var">in</span>))
                 (<span class="var">constants</span>    (<span class="func">read</span> <span class="var">in</span>))
                 (<span class="var">code</span>         (<span class="func">read</span> <span class="var">in</span>))
                 (<span class="var">entry-points</span> (<span class="func">read</span> <span class="var">in</span>)) )
            (<span class="func">close-input-port</span> <span class="var">in</span>)
            (<span class="special">set!</span> <span class="var">sg.current.names</span>    <span class="var">global-names</span>)
            (<span class="special">set!</span> <span class="var">*dynamic-variables*</span> <span class="var">dynamics</span>)
            (<span class="special">set!</span> <span class="var">sg.current</span> (<span class="func">make-vector</span> (<span class="func">length</span> <span class="var">sg.current.names</span>)
                                          <span class="var">undefined-value</span> ))
            (<span class="special">set!</span> <span class="var">*constants*</span>         <span class="var">constants</span>)
            (<span class="special">set!</span> <span class="var">*code*</span>              (<span class="func">vector</span>))
            (<span class="func">install-code!</span> <span class="var">code</span>)
            (<span class="special">set!</span> <span class="var">*env*</span>               <span class="var">sr.init</span>)
            (<span class="special">set!</span> <span class="var">*stack*</span>             (<span class="func">make-vector</span> <span class="var">stack-size</span>))
            (<span class="special">set!</span> <span class="var">*stack-index*</span>       <span class="num">0</span>)
            (<span class="special">set!</span> <span class="var">*val*</span>               '<span class="var">anything</span>)
            (<span class="special">set!</span> <span class="var">*fun*</span>               '<span class="var">anything</span>)
            (<span class="special">set!</span> <span class="var">*arg1*</span>              '<span class="var">anything</span>)
            (<span class="special">set!</span> <span class="var">*arg2*</span>              '<span class="var">anything</span>)
            (<span class="func">push-dynamic-binding</span>
             <span class="num">0</span> (<span class="func">list</span> (<span class="func">make-primitive</span> (<span class="special">lambda</span> ()
                                       (<span class="func">show-exception</span>)
                                       (<span class="func">*exit*</span> '<span class="var">aborted</span>) ))) )
            (<span class="func">stack-push</span> <span class="num">1</span>)
            (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">entry-points</span>)
                (<span class="func">for-each</span> <span class="var">stack-push</span> <span class="var">entry-points</span>)
                (<span class="func">stack-push</span> <span class="var">entry-points</span>) ) )
          (<span class="special">set!</span> <span class="var">*pc*</span> (<span class="func">stack-pop</span>))
          (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">exit</span>)
                     (<span class="special">set!</span> <span class="var">*exit*</span> <span class="var">exit</span>)
                     (<span class="func">run</span>) )) ) )
      (<span class="func">static-wrong</span> <span class="string">"No such file"</span> <span class="var">filename</span>) ) )</pre>

<!--\indexC{show-exception}-->
<!--\indexR{дескрипторы!исключений}-->
<p>Прежде всего, конечно же, необходимо прочитать файл с загружаемой программой.
Входной порт закрывается сразу же, как становится ненужным. Далее, подобно
<code><span class="func">run-machine</span></code>, инициализируются переменные состояния машины. После
установки терминального обработчика исключений в стек заталкиваются точки входа
всех объектных файлов, составляющих приложение. Такой подход позволяет запускать
единичный объектный файл аналогично цельному приложению. Стандартный обработчик
исключений останавливает исполнение программы при возникновении исключительной
ситуации; для этого захватывается продолжение функции <code><span class="func">run-application</span></code> и
сохраняется в переменной <code><span class="var">*exit*</span></code>. Функция <code><span class="func">show-exception</span></code> отвечает за
вывод понятных и выразительных<a class="footref" href="zz_footnotes#foot7.11"><sup>11</sup></a> сообщений об ошибках на основе дескриптора исключения, находящегося
в тот момент в регистре <code><span class="var">*val*</span></code>. Остаётся только не забыть об инструкции
<code><span class="func">RETURN</span></code> в конце каждого объектного файла, которая обеспечивает передачу
управления следующему файлу в цепочке.</p>

<!--\indexR{стек!обработка переполнения}-->
<p>Функция <code><span class="func">run-application</span></code> принимает максимальный размер стека как аргумент.
Это отдельная и весьма важная проблема реализации: не допустить переполнения
стека. Было бы слишком дорого выполнять проверку границ при каждом вызове
<code><span class="func">stack-push</span></code>. Иногда возможно использовать механизм страничной виртуальной
памяти, предоставляемый операционной системой, чтобы избавиться от проверок и
увеличивать размер стека при необходимости на лету. Наша эмуляция памяти
вряд ли является эффективной, так как о стоимости выражения
<code>(<span class="func">vector-ref</span> <i>v</i> <i>i</i>)</code>
нельзя сказать ничего определённого; здесь наверняка каждый раз
будет выполняться проверка, что <i>v</i> это действительно вектор, а
<i>i</i> является неотрицательным целым числом, меньшим, чем длина вектора <i>v</i>.</p>

<p>Функция <code><span class="func">run-application</span></code> требует весьма немного приспособлений для
исполнения скомпилированных приложений. Ей нужен всего лишь интерпретатор
байт-кодов (<code><span class="func">run</span></code>), а также функции для работы с векторами, списками и
другими классами вроде <code><span class="class">primitive</span></code> и <code><span class="class">continuation</span></code>. Ещё потребуется
функция <code><span class="func">read</span></code> для чтения файлов. Всё это слабо зависит от конкретного
компилятора, создающего объектные файлы (что, правда, не особо помогает при
отладке), а ведь именно подобное отделение языка от исполнимых программ и есть
целью компиляции!</p>


<h2 id="compilation/sect:conclusions"><span class="wrap"><span class="seq">7.11.</span><span class="title">Заключение</span></span></h2>

<p>До полной реализации Scheme нашему компилятору не хватает множества функций
стандартной библиотеки, а также поддержки оставшихся типов данных. С этим
не должно возникнуть каких-либо принципиальных проблем, кроме разве что
сложностей с реализацией проверки типов и допустимости значений.</p>

<!--\indexR{интерпретация!связь с компиляцией}-->
<!--\indexR{компиляция!связь с интерпретацией}-->
<p>Описанная реализация является довольно простой, но достигается эта простота
игнорированием огромного числа всевозможных оптимизаций. Однако, основной упор
в ней делается на том, чтобы использовать предыдущие наработки —
оптимизированный интерпретатор, уже частично превращённый в компилятор.
Действительно, существует глубокая связь между интерпретацией и компиляцией
(рассмотренная подробнее в <span class="cite">[<a href="z1_bibliography.xhtml#nei84">Nei84</a>]</span>). Интерпретатор непосредственно
исполняет программу, тогда как компилятор превращает программу в нечто, что
будет исполнено потом. Следовательно, они отличаются лишь способом трактовки
инструкций языка: исполнять ли соответствующие действия или генерировать
соответствующий код. Мы воспользовались данной связью, чтобы легко превратить
имеющийся интерпретатор в компилятор.</p>

<!--\indexR{промежуточное представление!недостатки}-->
<!--\indexR{записи активации}-->
<!--\indexR{стек}-->
<p>Основной недостаток такого подхода в том, что здесь используется лишь
информация, сохранённая в промежуточном языке, а её явно недостаточно для
качественной компиляции. Мы ничего не знаем, к примеру, об используемых
локальных переменных; несомненно, это один из главных источников информации,
необходимой для проведения различных оптимизаций. Мы не знаем, изменяются ли
значения переменных, захватываются ли они замыканиями, захватываются ли
несколькими или только одним, изменяются ли захваченные копии и т. д. Во многих
случаях подобные статические сведения о переменных позволяют избавиться от
записей активаций и пользоваться одним только стеком — а это, очевидно,
положительно сказывается на скорости работы. Записи активаций действительно
полезны лишь для сохранения значений переменных, захваченных замыканиями;
комбинаторы вполне могут обойтись и без них. Так как значения передаваемых
аргументов уже находятся в стеке, то их можно там и оставить, не создавая при
этом объектов-посредников и экономя таким образом значительное количество
времени.</p>


<h2 id="compilation/sect:exercises"><span class="wrap"><span class="seq">7.12.</span><span class="title">Упражнения</span></span></h2>

<h5 class="exercise" id="compilation/ex:dynamic">Упражнение <span class="seq">7.1</span></h5>
<p>Реализуйте поддержку динамических переменных с помощью регистра
<code><span class="var">*dynenv*</span></code>
для компилятора и виртуальной машины из этой главы.
<span class="see">[см. раздел <a href="#compilation/sect:dynamic">7.8</a>]</span></p>


<h5 class="exercise" id="compilation/ex:load">Упражнение <span class="seq">7.2</span></h5>
<!--\indexC{load}-->
<p>Определите функцию <code><span class="func">load</span></code>, которая загружает
и исполняет скомпилированные программы. Например, если у нас есть файл <code>fact.so</code>,
полученный из файла <code>fact.scm</code>, то следующая программа должна успешно
компилироваться и выдавать ожидаемое число 120:</p>

<pre>(<span class="special">begin</span> (<span class="func">load</span> <span class="string">"fact"</span>)
       (<span class="func">fact</span> <span class="num">5</span>) )</pre>


<h5 class="exercise" id="compilation/ex:global-value">Упражнение <span class="seq">7.3</span></h5>
<p>Реализуйте функцию <code><span class="func">global-value</span></code>, принимающую имя глобальной переменной
и возвращающую её текущее значение.</p>


<h5 class="exercise" id="compilation/ex:shallow-dynamic">Упражнение <span class="seq">7.4</span></h5>
<!--\indexR{ближнее (shallow) связывание}-->
<!--\indexR{связывание!ближнее (shallow)}-->
<p>Переопределите инструкции, отвечающие за работу с динамическими переменными,
реализовав их с помощью ближнего связывания.
<span class="see">[см. раздел <a href="ch01_basics.xhtml#basics/representing-functions/ssect:deep-or-shallow">1.6.2</a>]</span></p>


<h5 class="exercise" id="compilation/ex:export-rename">Упражнение <span class="seq">7.5</span></h5>
<p><span class="see">[см. раздел <a href="#compilation/separate/build/par:linker-dsl">7.10.2</a>]</span>
Напишите функцию, переименовывающую экспортируемые глобальные переменные. Если
<code>fact.so</code> это объектный файл, то следующая программа должна создать новый
модуль <code>nfact.so</code>, где переменная <code><span class="var">fact</span></code>
имеет имя <code><span class="var">factorial</span></code>:</p>

<pre>(<span class="func">build-application-with-renaming-variables</span>
 <span class="string">"fact.so"</span> <span class="string">"nfact.so"</span> '((<span class="var">fact</span> <span class="var">factorial</span>)) )</pre>


<h5 class="exercise" id="compilation/ex:unchecked-ref">Упражнение <span class="seq">7.6</span></h5>
<!--\indexR{мемоизация}-->
<p><span class="see">[см. раздел <a href="ch06_fast_interpretation.xhtml#fast/fast/classify/static-err/par:self-modify">6.1.4</a>]</span>
Измените инструкцию <code><span class="func">CHECKED-GLOBAL-REF</span></code> так, чтобы после определения
соответствующей переменной она автоматически изменялась на <code><span class="func">GLOBAL-REF</span></code>.</p>

<h5 class="exercise" id="compilation/ex:unchecked-ref">Проект <span class="seq">7.7</span></h5>
<p>Многие реализации Лиспа и Scheme имеют компиляторы в байт-код. Возьмём,
например, GNU Emacs Lisp <span class="cite">[<a href="z1_bibliography.xhtml#llst93">LLSt93</a>]</span> и xscheme <span class="cite">[<a href="z1_bibliography.xhtml#bet91">Bet91</a>]</span>. Реализуйте
соответствующие виртуальные машины для них.</p>


<h2><span class="wrap"><span class="title">Рекомендуемая литература</span></span></h2>

<p>Литературы на тему основ компиляции весьма немного. Собственно, это одна из
причин появления данной книги. Как бы то ни было, вам стоит взглянуть на
<span class="cite">[<a href="z1_bibliography.xhtml#all78">All78</a>]</span> и <span class="cite">[<a href="z1_bibliography.xhtml#hen80">Hen80</a>]</span>. Об общих принципах компиляции функциональных языков
неплохо написано в <span class="cite">[<a href="z1_bibliography.xhtml#dil88">Dil88</a>]</span>. В следующих книгах тоже есть несколько
интересных компиляторов с комментариями:
<span class="cite">[<a href="z1_bibliography.xhtml#ste78">Ste78</a>,
<a href="z1_bibliography.xhtml#as85">AS85</a>,
<a href="z1_bibliography.xhtml#fwh92">FWH92</a>]</span>.</p>

</body>
</html>
