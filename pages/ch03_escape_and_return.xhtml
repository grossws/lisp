<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru">

<head>
    <title>3 – Переходы и возвраты: продолжения</title>
    <link rel="stylesheet" type="text/css" href="zz_lisp.css"/>
    <link rel="stylesheet" type="text/css" href="zz_fontsize.css"/>
</head>

<body>

<h1 id="chapter:escape"><span class="wrap"><span class="seq">Глава 3.</span><span class="title">Переходы и возвраты: продолжения</span></span></h1>

<p class="noindent"><span class="initial">К</span><span class="sc"><span class="c">аждое вычисление</span></span> в конечном счёте
приводит к возврату результата сущности, которая называется <em class="term">продолжением</em>.
В данной главе разбирается эта идея и её исторические предпосылки. Мы также
создадим ещё один интерпретатор, призванный явно оперировать продолжениями.
В процессе разработки будут рассмотрены различные варианты реализации
продолжений в Лиспе и Scheme, а также своеобразный «стиль передачи
продолжений». Одним из отличий Лиспа от других языков является большое
количество механизмов управления ходом вычислений. Это в некотором смысле
превращает данную главу в каталог <span class="cite">[<a href="z1_bibliography.xhtml#moz87">Moz87</a>]</span>, где представлена тысяча и одна
управляющая конструкция. С другой стороны, мы не будем вдаваться в подробности
о продолжениях; по крайней мере, о том, как физически реализуется их захват и
сохранение. Наш интерпретатор будет использовать объекты для представления
продолжений в виде <em class="term">стека вызовов</em>.</p>

<div class="bigskip"/>

<!--\indexR{переходы (escapes)}-->
<p>Интерпретаторам, построенным нами ранее, было необходимо только окружение, чтобы
вычислить значение переданного выражения. К сожалению, они не в состоянии
проводить вычисления, в которых есть <em class="term">переходы</em> (escapes): полезная
управляющая конструкция, позволяющая покинуть текущий контекст исполнения, чтобы
перейти в другой, более подходящий. Обычно они используются для обработки
исключительных ситуаций, когда мы указываем, куда нам следует перейти для
обработки события или ошибки, прервавшей нормальный ход вычислений.</p>

<!--\indexC{prog}-->
<!--\indexC{goto}-->
<p>История переходов в Лиспе восходит ко временам <span class="sc">L<span class="c">isp</span> 1.5</span> и формы <code><span class="special">prog</span></code>.
Сейчас эта форма считается устаревшей, но раньше на неё возлагались большие
надежды по переманиванию программистов на Алголе в ряды лисперов, так как
считалось, что для них было более привычным использование <code>goto</code>. Вместо
этого оказалось, что данная форма больше влияет на самих лисперов, сталкивая их
с праведного пути хвостовой рекурсии.<a class="footref" href="zz_footnotes.xhtml#foot3.1"><sup>1</sup></a> Тем не менее, форма <code><span class="special">prog</span></code>
достойна рассмотрения, потому как обладает несколькими интересными свойствами.
Например, вот так с её помощью записывается факториал:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">defun</span> <span class="func">fact</span> (<span class="var">n</span>)     <span class="dialect"><span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span></span>
  (<span class="special">prog</span> (<span class="var">r</span>)
            (<span class="special">setq</span> <span class="var">r</span> <span class="num">1</span>)
       <span class="syntax">loop</span> (<span class="syntax">cond</span> ((<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) (<span class="special">return</span> <span class="var">r</span>)))
            (<span class="special">setq</span> <span class="var">r</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>))
            (<span class="special">setq</span> <span class="var">n</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))
            (<span class="special">go</span> <span class="syntax">loop</span>) ) )</pre>

<p>Специальная форма <code><span class="special">prog</span></code> сначала объявляет все используемые локальные
переменные (в данном случае это <code><span class="var">r</span></code>). Далее следуют инструкции
(представляемые списками) и метки (представляемые символами). Инструкции
последовательно вычисляются, как в <code><span class="special">progn</span></code>. Результатом вычисления формы
<code><span class="special">prog</span></code> по умолчанию является <code><span class="var">nil</span></code>. Но внутри <code><span class="special">prog</span></code> можно использовать
специальные инструкции. Безусловные переходы выполняются с помощью <code><span class="special">go</span></code>
(которая принимает символ — имя метки), а вернуть определённое значение из
<code><span class="special">prog</span></code> можно с помощью <code><span class="special">return</span></code>. В <span class="sc">L<span class="c">isp</span> 1.5</span> было лишь одно ограничение:
формы <code><span class="special">go</span></code> и <code><span class="special">return</span></code> могли появляться только на первом уровне вложенности
или внутри <code><span class="syntax">cond</span></code> на том же первом уровне.</p>

<p>Форма <code><span class="special">return</span></code> позволяла выйти из <code><span class="special">prog</span></code>, забрав с собой результат
вычислений. Ограничение <span class="sc">L<span class="c">isp</span> 1.5</span> допускало лишь простые переходы, в более
поздних версиях оно было снято, что позволило реализовать более изощрённые
варианты поведения. Переходы стали обычным способом обработки ошибок. Если
происходила ошибка, то выполнение переходило из ошибочного контекста исполнения
в безопасный для обработки возникшей ситуации. Теперь можно переписать факториал
следующим образом, поместив <code><span class="special">return</span></code> глубже:</p>

<pre>(<span class="special">defun</span> <span class="func">fact2</span> (<span class="var">n</span>)     <span class="dialect"><span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span></span>
  (<span class="special">prog</span> (<span class="var">r</span>)
            (<span class="special">setq</span> <span class="var">r</span> <span class="num">1</span>)
       <span class="syntax">loop</span> (<span class="special">setq</span> <span class="var">r</span> (<span class="func">*</span> (<span class="syntax">cond</span> ((<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) (<span class="special">return</span> <span class="var">r</span>))
                             ('<span class="var">else</span> <span class="var">n</span>) )
                       <span class="var">r</span> ))
            (<span class="special">setq</span> <span class="var">n</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))
            (<span class="special">go</span> <span class="syntax">loop</span>) ) )</pre>

<!--\indexR{управляющие конструкции}-->
<p>Если рассматривать формы <code><span class="special">prog</span></code> и <code><span class="special">return</span></code> только как управляющие
конструкции, то становится ясно, что они влияют на последовательность вычислений
подобно функциям: выполнение функции начинается переходом в её тело и
заканчивается возвратом результата в то место, откуда функция была вызвана.
Только в нашем случае внутри формы <code><span class="special">prog</span></code> известно, куда требуется вернуть
значение, — она сама связывает <code><span class="special">return</span></code> с этим местом. Для перехода
не требуется знать, откуда мы уходим, но необходимо знать, куда мы хотим
попасть.</p>

<p>Если такой <em class="term">прыжок</em> будет эффективно реализован, то это порождает
жизнеспособную парадигму программирования. Например, пусть стоит задача
проверить вхождение элемента в двоичное дерево. В лоб эта задача решается
примерно таким способом:</p>

<!--\indexCS{find-symbol}{обычная}-->
<pre>(<span class="special">define</span> (<span class="func">find-symbol</span> <span class="var">id</span> <span class="var">tree</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">tree</span>)
      (<span class="syntax">or</span> (<span class="func">find-symbol</span> <span class="var">id</span> (<span class="func">car</span> <span class="var">tree</span>))
          (<span class="func">find-symbol</span> <span class="var">id</span> (<span class="func">cdr</span> <span class="var">tree</span>)) )
      (<span class="func">eq?</span> <span class="var">tree</span> <span class="var">id</span>) ) )</pre>

<p>Допустим, мы ищем <code><span class="var">foo</span></code> в следующем дереве:
<code>(((<span class="var">a</span> . <span class="var">b</span>) . (<span class="var">foo</span> . <span class="var">c</span>)) . (<span class="var">d</span> . <span class="var">e</span>))</code>.
Так как поиск идёт слева направо и в глубину, то после того, как
нужный символ будет найден, нам ещё предстоит подниматься обратно по
вложенным <code><span class="syntax">or</span></code>, неся с собой вожделенную
<code><span class="hash">#t</span></code>, которая в конце концов
станет результатом вычислений. Вот так это происходит:</p>

<pre>(<span class="func">find-symbol</span> '<span class="var">foo</span> '(((<span class="var">a</span> . <span class="var">b</span>) . (<span class="var">foo</span> . <span class="var">c</span>)) . (<span class="var">d</span> . <span class="var">e</span>)))
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> (<span class="func">find-symbol</span> '<span class="var">foo</span> '((<span class="var">a</span> . <span class="var">b</span>) . (<span class="var">foo</span> . <span class="var">c</span>)))
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> (<span class="syntax">or</span> (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">a</span> . <span class="var">b</span>))
           (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">foo</span> . <span class="var">c</span>)) )
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> (<span class="syntax">or</span> (<span class="syntax">or</span> (<span class="func">find-symbol</span> '<span class="var">foo</span> '<span class="var">a</span>)
               (<span class="func">find-symbol</span> '<span class="var">foo</span> '<span class="var">b</span>) )
           (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">foo</span> . <span class="var">c</span>)) )
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> (<span class="syntax">or</span> (<span class="func">find-symbol</span> '<span class="var">foo</span> '<span class="var">b</span>)
           (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">foo</span> . <span class="var">c</span>)) )
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">foo</span> . <span class="var">c</span>))
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> (<span class="syntax">or</span> (<span class="func">find-symbol</span> '<span class="var">foo</span> '<span class="var">foo</span>)
           (<span class="func">find-symbol</span> '<span class="var">foo</span> '<span class="var">c</span>) )
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> (<span class="syntax">or</span> <span class="hash">#t</span>
           (<span class="func">find-symbol</span> '<span class="var">foo</span> '<span class="var">c</span>) )
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">≡</span></span>  (<span class="syntax">or</span> <span class="hash">#t</span>
       (<span class="func">find-symbol</span> '<span class="var">foo</span> '(<span class="var">d</span> . <span class="var">e</span>)) )
<span class="math"><span class="rel">→</span></span> <span class="hash">#t</span></pre>

<p>Как раз здесь бы не помешал эффективно реализованный переход к последней строке.
Как только мы находим нужный символ, то не продираемся через <code><span class="syntax">or</span></code> и уж тем
более не смотрим в другие ветки, а сразу же возвращаем результат.</p>

<!--\indexR{исключения}-->
<p>Другим примером может быть так называемое программирование исключениями. Суть
подхода: пусть в цикле выполняются какие-то действия. Данный цикл продолжает
выполняться до тех пор, пока не возникает исключительная ситуация и
не происходит выход из цикла, который иначе бы продолжался вечно.
Нечто подобное реализует функция <code><span class="func">better-map</span></code>, рассматриваемая позже.
<span class="see">[см. раздел <a href="#escape/forms/catch-vs-block/p:better-map">3.1.4</a>]</span></p>

<!--\indexR{продолжения (continuations)}-->
<p>Размышляя дальше над природой сущности, представляющей точку входа в функцию,
можно прийти к выводу, что понятие вычислений подразумевает не только выражение,
которое необходимо вычислить, и окружение, в котором будут проходить вычисления,
но и нечто, куда необходимо вернуть полученный результат. Это нечто и называется
<em class="term">продолжением</em> (continuation). Это всё, что ещё осталось вычислить.</p>

<p>У любого вычисления есть продолжение. Например, в выражении <code>(<span class="func">+</span> 3 (<span class="func">*</span> <span class="num">2</span> <span class="num">4</span>))</code>
продолжением подвыражения <code>(<span class="func">*</span> <span class="num">2</span> <span class="num">4</span>)</code> будет сложение, где первый аргумент
это <code><span class="num">3</span></code>, а второй ожидается в результате вычислений. Здесь можно заметить
параллели и представить продолжения в более привычной форме — как функции.
Ведь продолжения тоже представляют некоторые вычисления и, как и функции, тоже
требуют, чтобы сначала были вычислены все необходимые параметры. Для предыдущего
примера продолжением <code>(<span class="func">*</span> <span class="num">2</span> <span class="num">4</span>)</code> будет функция
<code>(<span class="special">lambda</span> (<i>x</i>) (<span class="func">+</span> <span class="num">3</span> <i>x</i>))</code>, подчёркивающая тот факт, что вычисление ожидает второй аргумент для
сложения.</p>

<p>Продолжения можно записывать и проще, в духе <span class="math"><span class="ord var">λ</span></span>-исчисления. Мы будем
записывать предыдущее продолжение как <code>(<span class="func">+</span> <span class="num">3</span> <span class="hash">[]</span>)</code>, где <code><span class="hash">[]</span></code> означает место,
куда необходимо подставить результат вычислений.</p>

<p>Действительно, у всего есть продолжение. Вычисление условного выражения в формах
ветвления проводится для продолжения, которое ожидает это значение, чтобы
выбрать ту или иную ветку условной формы. В выражении <code>(<span class="special">if</span> (<span class="func">foo</span>) <span class="num">1</span> <span class="num">2</span>)</code>
продолжением вызова <code>(<span class="func">foo</span>)</code> является
<code>(<span class="special">lambda</span> (<i>x</i>) (<span class="special">if</span> <i>x</i> <span class="num">1</span> <span class="num">2</span>))</code>
или <code>(<span class="special">if</span> <span class="hash">[]</span> <span class="num">1</span> <span class="num">2</span>)</code>.</p>

<p>Переходы, исключения и тому подобные механизмы — это лишь частные случаи
манипуляции продолжениями. Имея это в виду, давайте рассмотрим в деталях
различные варианты использования продолжений, которые были придуманы за
последние тридцать с лишним лет.</p>


<h2 id="escape/sect:handling"><span class="wrap"><span class="seq">3.1.</span><span class="title">Формы, манипулирующие продолжениями</span></span></h2>

<p>Явное использование продолжений даёт нам возможность управлять ходом исполнения
программы. Форма <code><span class="special">prog</span></code> имеет схожие возможности, но при этом обладает
излишним функционалом <code><span class="syntax">let</span></code>. Оставив только функционал управления потоком
исполнения, мы получим то, для чего (в первую очередь) были придуманы формы
<code><span class="special">catch</span></code> и <code><span class="special">throw</span></code>.</p>


<h3 id="escape/handling/ssect:catch-throw"><span class="wrap"><span class="seq">3.1.1.</span><span class="title">Пара <code><span class="special">catch</span></code>/<code><span class="special">throw</span></code></span></span></h3>

<!--\indexC{catch}-->
<!--\indexE{catch@\protect<code><span class="func">catch</span></code>|seealso{\protect<code><span class="func">throw</span></code>}}-->
<!--\indexR{специальные формы!catch@\protect<code><span class="func">catch</span></code>}-->
<!--\indexR{переходы (escapes)!динамические}-->
<p>Специальная форма <code><span class="func">catch</span></code> имеет следующий синтаксис:</p>

<pre>(<span class="special">catch</span> <i>метка</i> <i>формы</i>...)</pre>

<p><i>Метка</i> вычисляется и с ней связывается продолжение формы <code><span class="special">catch</span></code>. Раз
связывается, то это значит, что нам необходимо новое пространство имён —
<em>динамическое окружение меток</em>, — в котором и будут храниться эти связи.
Это не совсем пространство <em>имён</em>, так как метки не обязательно являются
идентификаторами, но вполне на него похоже по смыслу. Правда, произвольность
значений меток может вызвать проблемы с определением их равенства и,
следовательно, с поиском в этом окружении, так как не все значения можно легко
и однозначно сравнивать. К этому вопросу мы ещё вернёмся.</p>

<p>Оставшиеся <i>формы</i> являются телом <code><span class="special">catch</span></code> и вычисляются последовательно,
как в <code><span class="special">progn</span></code> или <code><span class="special">begin</span></code>. Если ничего не произошло, то значением
<code><span class="special">catch</span></code> является значение последней вычисленной формы. Но мы можем вмешаться
в это поведение с помощью <code><span class="special">throw</span></code>.</p>

<!--\indexC{throw}-->
<!--\indexE{throw@\protect<code><span class="func">throw</span></code>|seealso{\protect<code><span class="func">catch</span></code>}}-->
<p>Форма <code><span class="special">throw</span></code> имеет следующий синтаксис:</p>

<pre>(<span class="special">throw</span> <i>метка</i> <i>форма</i>)</pre>

<p class="noindent">Первый аргумент должен вычисляться в значение, с которым <code><span class="special">catch</span></code> динамически
связала продолжение. Если это так, то исполнение переходит в соответствующее
продолжение, а вместо значения <code><span class="special">catch</span></code> подставляется значение <i>формы</i>
из <code><span class="special">throw</span></code>.</p>

<p>Вернёмся к примеру с поиском в двоичном дереве и перепишем его с использованием
<code><span class="special">catch</span></code> и <code><span class="special">throw</span></code>. Мы не будем здесь бессмысленно передавать по
рекурсивным вызовам значение <code><span class="var">id</span></code>, так как оно лексически видимо отовсюду;
такое поведение реализовано с помощью вспомогательной функции.</p>

<!--\indexCS{find-symbol}{с переходами}-->
<pre>(<span class="special">define</span> (<span class="func">find-symbol</span> <span class="var">id</span> <span class="var">tree</span>)
  (<span class="special">define</span> (<span class="func">find</span> <span class="var">tree</span>)
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">tree</span>)
        (<span class="syntax">or</span> (<span class="func">find</span> (<span class="func">car</span> <span class="var">tree</span>))
            (<span class="func">find</span> (<span class="func">cdr</span> <span class="var">tree</span>)) )
        (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">tree</span> <span class="var">id</span>)
            (<span class="special">throw</span> '<span class="var">find</span> <span class="hash">#t</span>)
            <span class="hash">#f</span> ) ) )
  (<span class="special">catch</span> '<span class="var">find</span>
    (<span class="func">find</span> <span class="var">tree</span>) ) )</pre>

<p>Форма <code><span class="special">catch</span></code>, оправдывая своё название, ловит значение, которое бросает ей
<code><span class="special">throw</span></code>. Переход в данном случае обеспечивается явным указанием значения,
связанного с сохранённым продолжением. То есть <code><span class="special">catch</span></code> — это связывающая
форма, которая ассоциирует метку с текущим продолжением. Тогда форма <code><span class="special">throw</span></code>
фактически ссылается на это продолжение, используя его для управления потоком
вычислений. Сама по себе она не возвращает значения, <code><span class="special">throw</span></code> лишь заставляет
<code><span class="special">catch</span></code> вернуть указанное значение. Здесь <code><span class="special">catch</span></code> захватывает продолжение
вызова <code><span class="func">find-symbol</span></code>, а <code><span class="special">throw</span></code> выполняет прямой переход к дальнейшим
вычислениям, которые должны выполняться после вызова <code><span class="func">find-symbol</span></code>.</p>

<!--\indexR{динамическое окружение!окружение меток}-->
<p>Динамическое окружение меток описывается следующей таблицей свойств:</p>

<table class="envtable">
<tr><td>Ссылка</td>      <td><code>(<span class="special">throw</span> <i>метка</i> ...)</code></td></tr>
<tr><td>Значение</td>    <td>отсутствует, это объекты второго класса</td></tr>
<tr><td>Изменение</td>   <td>запрещено</td></tr>
<tr><td>Расширение</td>  <td><code>(<span class="special">catch</span> <i>метка</i> ...)</code></td></tr>
<tr><td>Определение</td> <td>запрещено</td></tr>
</table>

<p>Как мы уже говорили, <code><span class="special">catch</span></code> это не функция, а специальная форма, вычисляющая
свой первый аргумент (метку), затем связывающая с ней в динамическом окружении
своё продолжение, после чего вычисляющая оставшиеся формы подобно <code><span class="special">begin</span></code>.
Не обязательно все они будут вычислены. Когда <code><span class="special">catch</span></code> возвращает значение или
мы выходим из неё с помощью <code><span class="special">throw</span></code>, связь между меткой и продолжением
автоматически удаляется.</p>

<!--\indexCS{throw}{варианты реализации}-->
<p>Форму <code><span class="special">throw</span></code> же можно реализовать и как функцию, и как специальную форму.
Если это специальная форма, как в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>, то она вычисляет метку, затем
ищет соответствующее продолжение <code><span class="special">catch</span></code>, и, если находит, то вычисляет
значение для передачи и выполняет переход. Если же <code><span class="func">throw</span></code> реализована как
функция, то всё происходит немного в другом порядке: сначала вычисляются оба
аргумента, затем ищется <code><span class="special">catch</span></code>, после чего выполняется переход.</p>

<p>Эти семантические различия хорошо показывают неточность описания поведения этих
форм естественным языком. И на этом они не заканчиваются, можно придумать ещё
множество вопросов, на которые будет сложно дать однозначный ответ. Например,
что делать, если соответствующей <code><span class="special">catch</span></code>-формы нет? Как именно всё же сравнивать метки?
Что будет, если написать <code>(<span class="special">throw</span> <span class="math"><span class="ord var">α</span></span> (<span class="special">throw</span> <span class="math"><span class="ord var">β</span></span> <span class="math"><span class="ord var">π</span></span>))</code>?
Мы попытаемся ответить на эти вопросы немного позже.</p>


<h3 id="escape/forms/ssect:block-return"><span class="wrap"><span class="seq">3.1.2.</span><span class="title">Пара <code><span class="special">block</span></code>/<code><span class="special">return-from</span></code></span></span></h3>

<!--\indexR{переходы (escapes)!лексические}-->
<!--\indexR{специальные формы!block@\protect<code><span class="func">block</span></code>}-->
<p>Переходы, которые реализуют <code><span class="special">catch</span></code> и <code><span class="special">throw</span></code>, выполняются динамически.
Когда <code><span class="special">throw</span></code> запрашивает переход, она должна во время исполнения программы
отыскать соответствующую <code><span class="special">catch</span></code>-форму и её продолжение. Естественно, это
требует времени, которое можно попытаться сократить, использовав
<em>лексические</em> метки, как их называют в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>. Специальные формы
<code><span class="special">block</span></code> и <code><span class="special">return-from</span></code> слегка напоминают <code><span class="special">catch</span></code> и <code><span class="special">throw</span></code>.</p>

<!--\indexC{block}-->
<!--\indexE{block@\protect<code><span class="func">block</span></code>|seealso{\protect<code><span class="func">return-from</span></code>}}-->
<p>Форма <code><span class="special">block</span></code> имеет следующий синтаксис:</p>

<pre>(<span class="special">block</span> <i>метка</i> <i>формы</i>...)</pre>

<!--\indexR{лексическое окружение!окружение меток}-->
<p class="noindent">Первый аргумент не вычисляется и должен быть идентификатором. Форма <code><span class="special">block</span></code>
связывает текущее продолжение с <i>меткой</i> в <em>лексическом окружении
меток</em>. Далее вычисляется тело <code><span class="special">block</span></code> как в <code><span class="special">progn</span></code> и последнее
полученное значение становится значением всей формы
<code><span class="special">block</span></code>.
Последовательность можно прервать с помощью <code><span class="special">return-from</span></code>.</p>

<!--\indexC{return-from}-->
<!--\indexE{return-from@\protect<code><span class="func">return-from</span></code>|seealso{\protect<code><span class="func">block</span></code>}}-->
<p>Форма <code><span class="special">return-from</span></code> имеет следующий синтаксис:</p>

<pre>(<span class="special">return-from</span> <i>метка</i> <i>форма</i>)</pre>

<p class="noindent">Первый аргумент не вычисляется и должен быть именем лексически видимой метки;
читай: <code><span class="special">return-from</span></code> может находиться только внутри <code><span class="special">block</span></code>
с одноимённой меткой, как переменная может использоваться только внутри
соответствующей <code><span class="special">lambda</span></code>-формы. При вычислении <code><span class="special">return-from</span></code>
соответствующий <code><span class="special">block</span></code> прерывается и возвращает значение <i>формы</i>.</p>

<p>Лексические метки образуют новое пространство имён, чьи свойства описываются
следующей таблицей:</p>

<table class="envtable">
<tr><td>Ссылка</td>      <td><code>(<span class="special">return-from</span> <i>метка</i> ...)</code></td></tr>
<tr><td>Значение</td>    <td>отсутствует, это объекты второго класса</td></tr>
<tr><td>Изменение</td>   <td>запрещено</td></tr>
<tr><td>Расширение</td>  <td><code>(<span class="special">block</span> <i>метка</i> ...)</code></td></tr>
<tr><td>Определение</td> <td>запрещено</td></tr>
</table>

<p>Перепишем<a class="footref" href="zz_footnotes.xhtml#foot3.2"><sup>2</sup></a> наш пример с деревом на новый лад:</p>

<!--\indexCS{find-symbol}{с переходами}-->
<pre>(<span class="special">define</span> (<span class="func">find-symbol</span> <span class="var">id</span> <span class="var">tree</span>)
  (<span class="special">block</span> <span class="var">find</span>
    (<span class="syntax">letrec</span> ((<span class="var">find</span> (<span class="special">lambda</span> (<span class="var">tree</span>)
                     (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">tree</span>)
                         (<span class="syntax">or</span> (<span class="func">find</span> (<span class="func">car</span> <span class="var">tree</span>))
                             (<span class="func">find</span> (<span class="func">cdr</span> <span class="var">tree</span>)) )
                         (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">id</span> <span class="var">tree</span>)
                             (<span class="special">return-from</span> <span class="var">find</span> <span class="hash">#t</span>)
                             <span class="hash">#f</span> ) ) )))
      (<span class="func">find</span> <span class="var">tree</span>) ) ) )</pre>

<p>Заметьте, мы не просто поменяли все „<code><span class="special">catch</span> '<span class="var">find</span></code>“ на „<code><span class="special">block</span> <span class="var">find</span></code>“;
нам потребовалось переместить тело функции внутрь <code><span class="special">block</span></code>, иначе
<code><span class="special">return-from</span></code> не находилась бы в лексической области видимости
метки <code><span class="var">find</span></code>.</p>

<!--\indexCS{block}{эффективность}-->
<p>Компилятор может генерировать для <code><span class="special">block</span></code> очень эффективный код. Грубо
говоря, всё, что надо сделать <code><span class="special">block</span></code>, — это сохранить высоту стека
вызовов в соответствующей метке. А <code><span class="special">return-from</span></code> надо лишь положить
возвращаемое значение <code><span class="hash">#t</span></code> туда, где его ждут (в регистр, например), после
чего вернуть указатель верхушки стека в положение, сохранённое в метке
<code><span class="var">find</span></code>. Это всего лишь пара-тройка инструкций, а не поиск среди всех
доступных меток, который устраивает <code><span class="special">catch</span></code>. Отличие станет более заметным,
когда мы попробуем реализовать <code><span class="special">catch</span></code><a class="footref" href="zz_footnotes.xhtml#foot3.3"><sup>3</sup></a> с помощью <code><span class="special">block</span></code>:</p>

<!--\indexC*{active-catchers}{*active-catchers*}-->
<!--\indexCS{catch}{с лексическими метками}-->
<!--\indexCS{throw}{c лексическими метками}-->
<pre>(<span class="special">define</span> <span class="var">*active-catchers*</span> <span class="hash">'()</span>)

(<span class="special">define-syntax</span> <span class="var">throw</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">throw</span> <span class="var">tag</span> <span class="var">value</span>)
     (<span class="syntax">let*</span> ((<span class="var">label</span> <span class="var">tag</span>)   <span class="comment">; вычисляется единожды</span>
            (<span class="var">escape</span> (<span class="func">assv</span> <span class="var">label</span> <span class="var">*active-catchers*</span>)) ) <span class="comment">; узкое место</span>
       (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">escape</span>)
           ((<span class="func">cdr</span> <span class="var">escape</span>) <span class="var">value</span>)
           (<span class="func">wrong</span> <span class="string">"No associated catch to"</span> <span class="var">label</span>) ) ) ) ) )

(<span class="special">define-syntax</span> <span class="var">catch</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">catch</span> <span class="var">tag</span> . <span class="var">body</span>)
     (<span class="syntax">let*</span> ((<span class="var">saved-catchers</span> <span class="var">*active-catchers*</span>)
            (<span class="var">result</span> (<span class="special">block</span> <span class="var">label</span>
                      (<span class="special">set!</span> <span class="var">*active-catchers*</span>
                            (<span class="func">cons</span> (<span class="func">cons</span> <span class="var">tag</span>
                                        (<span class="special">lambda</span> (<span class="var">x</span>)
                                          (<span class="special">return-from</span> <span class="var">label</span> <span class="var">x</span>) ) )
                                  <span class="var">*active-catchers*</span> ) )
                      . <span class="var">body</span> )) )
      (<span class="special">set!</span> <span class="var">*active-catchers*</span> <span class="var">saved-catchers</span>)
      <span class="var">result</span> ) ) ) )</pre>

<p>Здесь практически вся стоимость использования <code><span class="syntax">catch</span></code>/<code><span class="syntax">throw</span></code>
сосредоточена в вызове <code><span class="func">assv</span></code><a class="footref" href="zz_footnotes.xhtml#foot3.4"><sup>4</sup></a> при раскрытии макроса <code><span class="syntax">throw</span></code>.
Рассмотрим, как работает эта реализация. Глобальная переменная (тут она названа
<code><span class="var">*active-catchers*</span></code>) хранит все активные <code><span class="special">catch</span></code>-формы (выполнение которых
ещё не завершилось). Переменная обновляется при выходе из <code><span class="syntax">catch</span></code> (как
нормальном, так и при помощи <code><span class="syntax">throw</span></code>). Значением <code><span class="var">*active-catchers*</span></code>
является А-список пар «метка — продолжение». Этот список фактически
соответствует динамическому окружению, которым пользовались исходные <code><span class="special">catch</span></code>
и <code><span class="special">throw</span></code> для обмена информацией о метках.</p>


<h3 id="escape/forms/ssect:dynamic"><span class="wrap"><span class="seq">3.1.3.</span><span class="title">Метки с динамическим временем жизни</span></span></h3>

<p>Однако, эта эмуляция не совсем хороша, так как если <code><span class="syntax">catch</span></code> окажется внутри
<code><span class="special">block</span></code>, то значение переменной <code><span class="var">*active-catchers*</span></code> может быть искажено.
Эмулировать неестественный для языка синтаксис непросто <span class="cite">[<a href="z1_bibliography.xhtml#fel90">Fel90</a>,
<a href="z1_bibliography.xhtml#bak92c">Bak92c</a>]</span>, так
как это часто требует сложных архитектурных решений, которым необходимы ресурсы
в единоличное пользование (вроде <code><span class="var">*active-catchers*</span></code>). Позже мы покажем, как
подружить <code><span class="syntax">catch</span></code> и <code><span class="special">block</span></code>, но уже с помощью специального приспособления:
<code><span class="special">unwind-protect</span></code>.<a class="footref"
href="zz_footnotes.xhtml#foot3.5"><sup>5</sup></a></p>

<!--\indexR{динамическое связывание}-->
<!--\indexR{продолжения (continuations)!время жизни!динамическое}-->
<p>Как и все объекты Лиспа, продолжения тоже имеют своё время жизни. В эмуляции
<code><span class="syntax">catch</span></code> с помощью <code><span class="special">block</span></code> видно, что продолжение, захватываемое
<code><span class="syntax">catch</span></code>, живёт только во время вычислений внутри тела <code><span class="syntax">catch</span></code>. Это
называется <em class="term">динамическим</em> временем жизни. Такое поведение напоминает
динамические переменные, которые тоже существуют только во время вычислений
внутри связывающей формы, что их создала. Поэтому давайте сделаем список
<code><span class="var">*active-catchers*</span></code> динамической переменной, что позволит использовать
<code><span class="syntax">catch</span></code> и <code><span class="special">block</span></code> одновременно, так как задача поддержания целостности
списка будет передана механизму динамических переменных.</p>

<!--\indexCS{catch}{с динамическими метками}-->
<!--\indexCS{throw}{с динамическими метками}-->
<pre>(<span class="special">define-syntax</span> <span class="var">throw</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">throw</span> <span class="var">tag</span> <span class="var">value</span>)
     (<span class="syntax">let*</span> ((<span class="var">label</span> <span class="var">tag</span>)
            (<span class="var">escape</span> (<span class="func">assv</span> <span class="var">label</span> (<span class="special">dynamic</span> <span class="var">*active-catchers*</span>))) )
       (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">escape</span>)
           ((<span class="func">cdr</span> <span class="var">escape</span>) <span class="var">value</span>)
           (<span class="func">wrong</span> <span class="string">"No associated catch to"</span> <span class="var">label</span>) ) ) ) ) )

(<span class="special">define-syntax</span> <span class="var">catch</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">catch</span> <span class="var">tag</span> . <span class="var">body</span>)
     (<span class="special">block</span> <span class="var">label</span>
       (<span class="special">dynamic-let</span> ((<span class="var">*active-catchers*</span>
                      (<span class="func">cons</span> (<span class="func">cons</span> <span class="var">tag</span> (<span class="special">lambda</span> (<span class="var">x</span>)
                                        (<span class="special">return-from</span> <span class="var">label</span> <span class="var">x</span>) ))
                            (<span class="special">dynamic</span> <span class="var">*active-catchers*</span>) ) ))
        . <span class="var">body</span> ) ) ) ) )</pre>

<!--\indexR{переходы (escapes)!допустимость}-->
<p>Время жизни метки, создаваемой <code><span class="special">block</span></code> в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>, динамическое, так что
на метку можно перейти только внутри тела <code><span class="special">block</span></code>. Точно такая же ситуация
и с <code><span class="syntax">catch</span></code>. Однако, лексический характер привязки, создаваемой <code><span class="special">block</span></code>,
является источником проблемы, которая не возникает с <code><span class="syntax">catch</span></code>: если <code><span class="syntax">throw</span></code>
и <code><span class="special">return-from</span></code> позволяют отбросить оставшиеся вычисления, то эти вычисления
должны существовать в момент совершения перехода. Рассмотрим следующую
программу:</p>

<pre>((<span class="special">block</span> <span class="var">foo</span>
   (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">return-from</span> <span class="var">foo</span> <span class="var">x</span>)) )
 <span class="num">33</span> )</pre>

<!--\indexR{замыкания (closures)!и переходы}-->
<p>Здесь функция-переход на <code><span class="var">foo</span></code> применяется к числу 33, но ведь в момент
применения этой функции уже нет никакой метки <code><span class="var">foo</span></code>, так что мы получаем
ошибку. При создании замыкания оно честно захватило своё окружение, в частности,
метку <code><span class="var">foo</span></code>. Потом это замыкание возвращается как значение <code><span class="special">block</span></code> и мы
выходим из этой формы. Нельзя выйти оттуда ещё раз, перейдя на <code><span class="var">foo</span></code>, так как
вычисления уже завершены. Поэтому во время вызова подобных функций необходимо
проверять, не стало ли сохранённое продолжение уже неактуальным, и выполнять
переход только при соблюдении этого условия. Кроме того, не стоит забывать и
о другом аспекте лексических меток, создаваемых <code><span class="special">block</span></code>. Например:</p>

<pre>(<span class="special">block</span> <span class="var">foo</span>
  (<span class="syntax">let</span> ((<span class="var">f1</span> (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">return-from</span> <span class="var">foo</span> <span class="var">x</span>))))
    (<span class="func">*</span> <span class="num">2</span> (<span class="special">block</span> <span class="var">foo</span>
           (<span class="func">f1</span> <span class="num">1</span>) )) ) ) <span class="math"><span class="rel">→</span></span> <span class="num">1</span></pre>

<p>Сравните это с результатом, который мы получим, сменив „<code><span class="special">block</span> <span class="var">foo</span></code>“ на
„<code><span class="special">catch</span> '<span class="var">foo</span></code>“:</p>

<pre>(<span class="special">catch</span> '<span class="var">foo</span>
  (<span class="syntax">let</span> ((<span class="var">f1</span> (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">throw</span> '<span class="var">foo</span> <span class="var">x</span>))))
    (<span class="func">*</span> <span class="num">2</span> (<span class="special">catch</span> '<span class="var">foo</span>
           (<span class="func">f1</span> <span class="num">1</span>) )) ) ) <span class="math"><span class="rel">→</span></span> <span class="num">2</span></pre>

<p>Функция <code><span class="func">f1</span></code> в данном случае вызовет выход из ближайшей формы <code><span class="special">catch</span></code>,
ожидающей <code><span class="var">foo</span></code>, а не той, которая была видна ей при определении;
соответственно, умножение будет выполнено и верхняя форма <code><span class="special">catch</span></code> получит
значение <code><span class="num">2</span></code>.</p>


<h3 id="escape/forms/ssect:catch-vs-block"><span class="wrap"><span class="seq">3.1.4.</span><span class="title">Сравнение <code><span class="special">catch</span></code> и <code><span class="special">block</span></code></span></span></h3>

<!--\indexCS{catch}{в сравнении с <code><span class="func">block</span></code>}-->
<!--\indexCS{block}{в сравнении с <code><span class="func">catch</span></code>}-->
<p>С одной стороны, <code><span class="special">catch</span></code> и <code><span class="special">block</span></code> похожи: захватываемые ими продолжения
имеют динамическое время жизни — ими можно пользоваться только внутри
соответствующих блоков. С другой стороны, <code><span class="special">return-from</span></code> всегда обращается
к нужному продолжению, тогда как <code><span class="special">throw</span></code> может их перепутать. Форма
<code><span class="special">block</span></code> более эффективна, так как <code><span class="special">return-from</span></code> не требуется проверять,
действительно ли существует парный ему <code><span class="special">block</span></code>, — это гарантируется
синтаксисом. Тем не менее, ей приходится проверять, можно ли воспользоваться
сохранённым продолжением, хотя чаще всего это тоже можно гарантировать по
исходному коду. Видна явная параллель между динамическими и лексическими метками
с одной стороны и динамическими и лексическими переменными с другой: возникающие
проблемы схожи в обоих случаях.</p>

<!--\indexR{конфликт имён}-->
<!--\indexR{область видимости!конфликт имён}-->
<p>Динамические метки могут конфликтовать между собой — лексические же
в принципе не могут мешать друг другу. Взять хотя бы возможность использовать
динамические метки где угодно: одна функция может случайно перехватить то, что
предназначалось другой. Например:</p>

<pre>(<span class="special">define</span> (<span class="func">foo</span>)
  (<span class="special">catch</span> '<span class="var">foo</span> (<span class="func">*</span> <span class="num">2</span> (<span class="func">bar</span>))) )

(<span class="special">define</span> (<span class="func">bar</span>)
  (<span class="func">+</span> <span class="num">1</span> (<span class="special">throw</span> '<span class="var">foo</span> <span class="num">5</span>)) )

(<span class="func">foo</span>) <span class="math"><span class="rel">→</span></span> <span class="num">5</span></pre>

<p><code><span class="special">block</span></code> ограничивает область видимости метки лишь своим телом, тогда как
<code><span class="special">catch</span></code> отзывается на подходящий <code><span class="special">throw</span></code> из любого уголка программы.
Поэтому можно будет сделать <code>(<span class="special">throw</span> '<span class="var">foo</span> ...)</code> где угодно в процессе
вычисления <code>(<span class="func">*</span> <span class="num">2</span> (<span class="func">bar</span>))</code> и это сработает. Использование
„<code><span class="special">catch</span> '<span class="var">foo</span></code>“
вместо „<code><span class="special">block</span> <span class="var">foo</span></code>“
естественно приведёт к ошибке, так как
<code><span class="special">return-from</span></code> понятия не имеет о
<code>(<span class="special">block</span> <span class="var">foo</span> ...)</code> в функциях, которые
вызывают <code><span class="func">bar</span></code>. Но это ещё безобидный пример. Рассмотрим следующую ситуацию.</p>

<pre id="escape/forms/catch-vs-block/p:better-map">(<span class="special">catch</span> '<span class="var">not-a-pair</span>
  (<span class="func">better-map</span> (<span class="special">lambda</span> (<span class="var">x</span>)
                (<span class="syntax">or</span> (<span class="func">pair?</span> <span class="var">x</span>)
                    (<span class="special">throw</span> '<span class="var">not-a-pair</span> <span class="var">x</span>) ) )
              (<span class="func">hack-and-return-list</span>) ) )</pre>

<p>Предположим, мы услышали от бабушек на лавочке, что <code><span class="func">better-map</span></code> гораздо
лучше <code><span class="func">map</span></code>; далее допустим, что мы рискнём использовать именно её, чтобы
быстро проверить, действительно ли <code>(<span class="func">hack-and-return-list</span>)</code>
возвращает список, состоящий из пар; наконец предположим, что мы не знаем, как реализована
<code><span class="func">better-map</span></code>, хотя на самом деле она выглядит вот так:</p>

<!--\indexC{better-map}-->
<pre>(<span class="special">define</span> (<span class="func">better-map</span> <span class="var">f</span> <span class="var">L</span>)
  (<span class="special">define</span> (<span class="func">loop</span> <span class="var">L1</span> <span class="var">L2</span> <span class="var">flag</span>)
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">L1</span>)
        (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">L1</span> <span class="var">L2</span>)
            (<span class="special">throw</span> '<span class="var">not-a-pair</span> <span class="var">L</span>)
            (<span class="func">cons</span> (<span class="func">F</span> (<span class="func">car</span> <span class="var">L1</span>))
                  (<span class="func">loop</span> (<span class="func">cdr</span> <span class="var">L1</span>)
                        (<span class="special">if</span> <span class="var">flag</span> (<span class="func">cdr</span> <span class="var">L2</span>) <span class="var">L2</span>)
                        (<span class="func">not</span> <span class="var">flag</span>) ) ) ) ) )
  (<span class="func">loop</span> <span class="var">L</span> (<span class="func">cons</span> '<span class="var">ignore</span> <span class="var">L</span>) <span class="hash">#t</span>) )</pre>

<p>Функция <code><span class="func">better-map</span></code> интересна тем, что в отличие от <code><span class="func">map</span></code> она не зависает
намертво на замкнутых списках (при правильном использовании). Если
<code>(<span class="func">hack-and-return-list</span>)</code> возвращает следующий список:
<code><span class="hash">#1=</span>((<span class="var">foo</span> . <span class="var">hack</span>) . <span class="hash">#1#</span>)</code><a class="footref" href="zz_footnotes.xhtml#foot3.6"><sup>6</sup></a>, то <code><span class="func">better-map</span></code> прыгнет на
ближайшую метку <code><span class="var">not-a-pair</span></code> и таким образом избежит бесконечного цикла. Но
вот незадача: замыканию, переданному в <code><span class="func">better-map</span></code>, эта метка тоже нужна.
Конечно, если в документации к <code><span class="func">better-map</span></code> будет написано, что она
использует такую метку, то конфликт имён можно устранить, использовав
какое-нибудь другое имя для своих целей. Благо, в случае <code><span class="special">catch</span></code> можно
использовать что угодно в качестве метки, в частности, список, собранный
специально для этого случая:</p>

<pre>(<span class="syntax">let</span> ((<span class="var">tag</span> (<span class="func">list</span> '<span class="var">not-a-pair</span>)))
  (<span class="special">catch</span> <span class="var">tag</span>
    (<span class="func">better-map</span> (<span class="special">lambda</span> (<span class="var">x</span>)
                  (<span class="syntax">or</span> (<span class="func">pair?</span> <span class="var">x</span>)
                      (<span class="special">throw</span> <span class="var">tag</span> <span class="var">x</span>) ) )
                (<span class="func">hack-and-return-list</span>) ) ) )</pre>

<div class="bigskip"/>

<p>Наконец, рассмотрим, как можно проэмулировать <code><span class="special">block</span></code> с помощью <code><span class="special">catch</span></code>
(естественно, выигрыша в производительности мы не получим). Для этого достаточно
обеспечить лексичность используемых меток.</p>

<!--\indexCS{block}{определение через <code><span class="func">catch</span></code>}-->
<!--\indexCS{return-from}{определение через <code><span class="func">throw</span></code>}-->
<pre>(<span class="special">define-syntax</span> <span class="var">block</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">block</span> <span class="var">label</span> . <span class="var">body</span>)
     (<span class="syntax">let</span> ((<span class="var">label</span> (<span class="func">list</span> '<span class="var">label</span>)))
       (<span class="special">catch</span> <span class="var">label</span> . <span class="var">body</span>) ) ) ) )

(<span class="special">define-syntax</span> <span class="var">return-from</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">return-from</span> <span class="var">label</span> <span class="var">value</span>)
     (<span class="special">throw</span> <span class="var">label</span> <span class="var">value</span>) ) ) )</pre>

<p>Макрос <code><span class="syntax">block</span></code> создаёт уникальную метку и лексически связывает её
с одноимённой переменной. Этим мы гарантируем, что нужную метку будут видеть
только те <code><span class="syntax">return-from</span></code>, которые лексически находятся внутри формы
<code><span class="syntax">block</span></code>. Правда, для этого используется имя <code><span class="var">label</span></code>, что опять может
вызвать конфликты. Конечно, можно воспользоваться чем-то вроде <code><span class="func">gensym</span></code>,
достаточно лишь удостовериться, что <code><span class="special">catch</span></code> и <code><span class="special">throw</span></code> используют
одинаковые метки.</p>

<h3 id="escape/forms/ssect:immortal"><span class="wrap"><span class="seq">3.1.5.</span><span class="title">Метки с неограниченным временем жизни</span></span></h3>

<!--\indexR{переходы (escapes)!неограниченные}-->
<!--\indexR{оператор $J$}-->
<!--\indexE{J, оператор@$J$, оператор}-->
<p>Диалект Scheme, появившийся около 1975 года, предложил дать продолжениям,
захватываемым <code><span class="special">catch</span></code> и <code><span class="special">block</span></code>, неограниченное время жизни. Это свойство
открыло поразительные возможности их использования. Позже, в соответствии
с догматом о минимальном количестве специальных форм, были предприняты попытки
выразить захват продолжений и сами продолжения как функции. В <span class="cite">[<a href="z1_bibliography.xhtml#lan65">Lan65</a>]</span>
Питер Лэндин предложил оператор <span class="math"><span class="ord var">J</span></span>, прямым
потомком которого является функция <code><span class="func">call/cc</span></code> в Scheme.</p>


<!--\indexCS{call/cc}{определение}-->
<!--\indexR{продолжения (continuations)!захват}-->
<p>Мы попробуем объяснить её синтаксис настолько просто, насколько это возможно.
Во-первых, она захватывает продолжения, так что это должна быть форма, где
доступно продолжение её вызова:</p>

<pre><sub><i>k</i></sub>(...)</pre>

<p>Далее, это должна быть функция. Назовём её <code><span class="func">call/cc</span></code>:</p>

<pre><sub><i>k</i></sub>(<span class="func">call/cc</span> ...)</pre>

<p>Теперь, когда мы захватили <i>k</i>, его нужно как-то передать пользователю.
Но как? Очевидно, нельзя вернуть <i>k</i> как значение <code><span class="func">call/cc</span></code>, потому что
это бессмысленно. Оно ожидается внутри какого-то вычисления, так что можно это
вычисление обернуть в унарную функцию<a class="footref" href="zz_footnotes.xhtml#foot3.7"><sup>7</sup></a>, принимающую <i>k</i>, которую и передать внутрь
<code><span class="func">call/cc</span></code>:</p>

<pre><sub><i>k</i></sub>(<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) ...))</pre>

<!--\indexR{полноценные объекты!продолжения}-->
<!--\indexR{продолжения (continuations)!как полноценные объекты}-->
<!--\indexR{продолжения (continuations)!как замыкания}-->
<!--\indexR{реификация}-->
<p>Продолжение <i>k</i> становится объектом первого класса, к которому применяется
функция-аргумент <code><span class="func">call/cc</span></code>. Аналогично, само продолжение <i>k</i> тоже является
унарной функцией, которая неотличима от замыканий, создаваемых <code><span class="special">lambda</span></code>.
Функция <code><span class="func">call/cc</span></code> <em class="term">реифицирует</em> продолжение <i>k</i> в полноценный объект,
который становится значением переменной <code><span class="var">k</span></code>. Достаточно вызвать
функцию <code><span class="func">k</span></code>, чтобы передать её аргумент форме, вызвавшей <code><span class="func">call/cc</span></code>:</p>

<pre><sub><i>k</i></sub>(<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="func">+</span> <span class="num">1</span> (<span class="func">k</span> <span class="num">2</span>)))) <span class="math"><span class="rel">→</span></span> <span class="num">2</span></pre>

<!--\indexC{continue}-->
<p>Можно было бы создать особый объект «продолжение». Тогда их уже не получится
вызывать как функции, для этого необходимо специальное средство передачи
управления: функция <code><span class="func">continue</span></code>. Пример выше записывался бы тогда так:</p>

<pre><sub><i>k</i></sub>(<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="func">+</span> <span class="num">1</span> (<span class="func">continue</span> <span class="var">k</span> <span class="num">2</span>)))) <span class="math"><span class="rel">→</span></span> <span class="num">2</span></pre>

<p>Тем не менее, даже в этом случае можно легко сделать продолжение функцией,
обернув его в <code>(<span class="special">lambda</span> (<span class="var">v</span>) (<span class="func">continue</span> <i>k</i> <span class="var">v</span>))</code>. Некоторым людям нравится
использовать развёрнутую форму, так как она делает переход более заметным.</p>

<p>Вот и всё. Осталось только самое сложное — запомнить полное имя этой функции:
<code><span class="func">call-with-current-continuation</span></code>.
А теперь давайте перепишем наш пример с двоичным деревом, используя <code><span class="func">call/cc</span></code>:</p>

<!--\indexCS{find-symbol}{с переходами}-->
<pre>(<span class="special">define</span> (<span class="func">find-symbol</span> <span class="var">id</span> <span class="var">tree</span>)
  (<span class="func">call/cc</span>
   (<span class="special">lambda</span> (<span class="var">exit</span>)
     (<span class="special">define</span> (<span class="func">find</span> <span class="var">tree</span>)
       (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">tree</span>)
           (<span class="syntax">or</span> (<span class="func">find</span> (<span class="func">car</span> <span class="var">tree</span>))
               (<span class="func">find</span> (<span class="func">cdr</span> <span class="var">tree</span>)) )
           (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">tree</span> <span class="var">id</span>) (<span class="func">exit</span> <span class="hash">#t</span>) <span class="hash">#f</span>) ) )
     (<span class="func">find</span> <span class="var">tree</span>) ) ) )</pre>

<p>Продолжение вызова функции <code><span class="func">find-symbol</span></code> захватывается и превращается
в унарную функцию, связываемую с переменной <code><span class="var">exit</span></code>. Как только мы находим
нужный символ, поиск прерывается вызовом <code><span class="func">exit</span></code>, после чего мы никогда уже
не возвращаемся внутрь <code><span class="func">find-symbol</span></code>, так как дальше продолжаются вычисления,
следующие после вызова <code><span class="func">find-symbol</span></code>.</p>

<!--\indexR{продолжения (continuations)!время жизни!неограниченное}-->
<!--\indexR{присваивание!роль для продолжений}-->
<p id="escape/forms/immortal/par:reincarnate">В этом примере не очевидна неограниченность времени
жизни продолжения, потому что оно используется исключительно внутри самой же формы
<code><span class="func">call/cc</span></code>. Но теперь
мы можем сохранить продолжение в любой переменной, чего нельзя сделать с меткой
<code><span class="special">block</span></code>/<code><span class="special">catch</span></code>.</p>

<!--\indexC{fact}-->
<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span>)
  (<span class="syntax">let</span> ((<span class="var">r</span> <span class="num">1</span>) (<span class="var">k</span> '<span class="var">void</span>))
    (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">c</span>) (<span class="special">set!</span> <span class="var">k</span> <span class="var">c</span>) '<span class="var">void</span>))
    (<span class="special">set!</span> <span class="var">r</span> (<span class="func">*</span> <span class="var">r</span> <span class="var">n</span>))
    (<span class="special">set!</span> <span class="var">n</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))
    (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">r</span> (<span class="func">k</span> '<span class="var">recurse</span>)) ) )</pre>

<p class="noindent">Продолжение, которое передаётся через <code><span class="var">c</span></code> и сохраняется в <code><span class="var">k</span></code>, выглядит
так:</p>

<pre><i>k</i> = (<span class="func">lambda</span> (<i>u</i>)
      (<span class="func">set!</span> <span class="var">r</span> (<span class="func">*</span> <span class="var">r</span> <span class="var">n</span>))
      (<span class="func">set!</span> <span class="var">n</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))
      (<span class="func">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">r</span> (<span class="func">k</span> '<span class="var">recurse</span>)) )<div class="where"><div class="wrap">
<span class="var">r</span> <span class="math"><span class="rel">→</span></span> <span class="num">1</span>
<span class="var">k</span> <span class="math"><span class="rel">→</span></span> <i>k</i>
<span class="var">n</span></div></div></pre>

<p>Это же продолжение <i>k</i> связано с переменной <code><span class="var">k</span></code> внутри самого себя.
Рекурсия, как мы знаем, всегда означает какой-то цикл; в данном случае <code><span class="func">k</span></code>
вызывается до тех пор, пока <code><span class="var">n</span></code> не достигнет желаемого
значения. Всё это
вместе, естественно, вычисляет факториал.</p>

<p>В этом примере продолжение <i>k</i> используется вне создавшей его формы
<code><span class="func">call/cc</span></code>. Кстати, можно избавиться от избыточных переменных и аргументов,
просто возвращая это продолжение:</p>

<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span>)
  (<span class="syntax">let</span> ((<span class="var">r</span> <span class="num">1</span>) (<span class="var">k</span> (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">c</span>) <span class="var">c</span>))))
    (<span class="special">set!</span> <span class="var">r</span> (<span class="func">*</span> <span class="var">r</span> <span class="var">n</span>))
    (<span class="special">set!</span> <span class="var">n</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))
    (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">r</span> (<span class="func">k</span> <span class="var">k</span>)) ) )</pre>

<p><em class="term">Самоприменение</em> <code>(<span class="func">k</span> <span class="var">k</span>)</code> необходимо, так как нам необходимо поддерживать
правильное значение <code><span class="var">k</span></code>.
Это продолжение можно записать так:</p>

<pre>(<span class="special">lambda</span> (<i>u</i>)
  (<span class="syntax">let</span> ((<span class="var">k</span> <i>u</i>))
    (<span class="special">set!</span> <span class="var">r</span> (<span class="func">*</span> <span class="var">r</span> <span class="var">n</span>))
    (<span class="special">set!</span> <span class="var">n</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))
    (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">r</span> (<span class="func">k</span> <span class="var">k</span>)) ) )<div class="where"><div class="wrap">
<span class="var">r</span> <span class="math"><span class="rel">→</span></span> <span class="num">1</span>
<span class="var">n</span></div></div></pre>

<!--\indexR{продолжения (continuations)!сложность реализации}-->
<!--\indexR{стек!и продолжения}-->
<p>Неограниченность времени жизни усложняет реализацию продолжений и в общем случае
увеличивает стоимость их использования. (См. <span class="cite">[<a href="z1_bibliography.xhtml#cho88">CHO88</a>, <a href="z1_bibliography.xhtml#hdb90">HDB90</a>, <a href="z1_bibliography.xhtml#mat92">Mat92</a>]</span>.) Почему?
Потому, что в таком случае вложенные вычисления уже нельзя представлять в виде
стека, здесь требуется дерево. Если продолжения имеют исключительно динамическое
время жизни, то это просто переходы: с их помощью можно покинуть текущие
вычисления, но только один раз. В этом случае легко понять, когда вычисление
формы начинается и заканчивается: начинается при входе в неё, а заканчивается
с последним выражением или первым встреченным переходом.</p>

<!--\indexR{возвращаемые значения!многократно}-->
<!--\indexR{продолжения (continuations)!множественные возвраты}-->
<p>Если же продолжения живут неограниченно долго, то всё гораздо усложняется.
Вспомните форму <code>(<span class="func">call/cc</span> ...)</code> в примере с факториалом: она фактически
возвращает результат несколько раз. Если допускать такую возможность
(многократного возврата значений<a class="footref" href="zz_footnotes.xhtml#foot3.8"><sup>8</sup></a>), то уже не получится считать, что выполнение
функции окончено, когда она вернула значение.</p>

<!--\indexR{память!и \protect<code><span class="func">call/cc</span></code>}-->
<p><code><span class="func">call/cc</span></code> могущественна и в некотором смысле может манипулировать временем.
Программа прожила какой-то промежуток времени, наделала ошибок и решила взять
вторую попытку, перепрыгнув назад в прошлое (при этом она заранее предусмотрела
такой исход и оставила метку в нужном ей моменте времени). При этом она забирает
с собой весь прожитый опыт (свою память), так что вычисления после прыжка пойдут
уже другим путём. Естественно, ничто не запрещает ей сделать и третью попытку
или использовать эту силу не только для исправления ошибок, но и для собственной
выгоды.</p>

<!--\indexC{goto}-->
<p>С другой стороны, форма <code><span class="func">call/cc</span></code> очень похожа на оператор <code>goto</code>, который considered harmful. Однако <code><span class="func">call/cc</span></code> более ограничена, так как
позволяет лишь <em>вернуться</em> в те места программы, где мы уже были, но
<em>не отправиться</em> туда, где нас никогда не было.</p>

<p>Вначале бывает нелегко научиться пользоваться <code><span class="func">call/cc</span></code>, так как и её
аргумент, и продолжение являются унарными функциями. Возможно, в таком случае
вам поможет понимание <code><span class="func">call/cc</span></code> следующим образом:</p>

<pre><sub><i>k</i></sub>(<span class="func">call/cc</span> <span class="math"><span class="ord var">φ</span></span>) <span class="math"><span class="rel">→</span></span> <sub><i>k</i></sub>(<span class="math"><span class="ord var">φ</span></span> <i>k</i>)</pre>

<p class="noindent">где <i>k</i> является продолжением вызова <code><span class="func">call/cc</span></code>,
а <span class="math"><span class="ord var">φ</span></span> — какой-то
унарной функцией. Вызов <code><span class="func">call/cc</span></code> лишь превращает <i>k</i>
в объект языка, который можно передать как аргумент. Заметьте, что продолжением вызова
<span class="math"><span class="ord var">φ</span></span> является всё так же <i>k</i>, поэтому для
того, чтобы просто вернуть результат, не обязательно пользоваться переданным продолжением:</p>

<pre>(<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) <span class="num">1515</span>)) <span class="math"><span class="rel">→</span></span> <span class="num">1515</span></pre>

<p>Кого-то такое умолчательное поведение может расстраивать. В некоторых языках
<code><span class="func">call/cc</span></code> изымает захватываемое продолжение <i>k</i> из хода
вычислений: <i>k</i> больше не является её собственным продолжением, и для возврата значения
последующим вычислениям его надо обязательно явно передать правильному продолжению:</p>

<pre>(<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="func">k</span> <span class="num">1615</span>))) <span class="math"><span class="rel">→</span></span> <span class="num">1615</span></pre>

<!--\indexR{продолжения (continuations)!терминальное продолжение}-->
<!--\indexR{терминальное продолжение}-->
<p>Если этого не сделать, то продолжением формы <code><span class="func">call/cc</span></code> будет нечто, подобное чёрной дыре: <span class="math"><span class="ord var">λ</span><span class="ord var">u</span><span class="ord">.</span><span class="ord">⚫</span></span>. Оно поглощает все вычисления вместе с передаваемым значением. Ничто и никогда не возвращается назад, попав в
чёрную дыру. Исполнение программы состоит из вызовов функций, а они похожи на дыхание:
вдох-выдох — вход-выход. Необходимым условием жизни является
<em>продолжение</em> дыхания. Используя <code><span class="func">call/cc</span></code>, мы вмешиваемся в нормальный
ход исполнения, так что без определённых предосторожностей можно всерьёз забыть,
как дышать, и умереть.</p>


<h3 id="escape/forms/ssect:protection"><span class="wrap"><span class="seq">3.1.6.</span><span class="title">Защитные формы</span></span></h3>

<!--\indexC{unwind-protect}-->
<!--\indexC{car}-->
<!--\indexC{cdr}-->
<p>Осталось рассмотреть ещё один эффект, относящийся к продолжениям. Связан он
со специальной формой <code><span class="special">unwind-protect</span></code>.
Названием она обязана принципу первой реализации<a class="footref" href="zz_footnotes.xhtml#foot3.9"><sup>9</sup></a> и задуманному функциональному назначению. Вот синтаксис этой
формы:</p>

<pre>(<span class="special">unwind-protect</span> <i>форма</i>
  <i>формы-уборщики</i>... )</pre>

<p>Сначала вычисляется <i>форма</i>, её значение станет значением всей формы
<code><span class="special">unwind-protect</span></code>. Как только значение <i>формы</i> получено, вычисляются
<i>формы-уборщики</i>, и только потом <code><span class="special">unwind-protect</span></code> возвращает ранее
вычисленное значение. Она похожа на <code><span class="special">prog1</span></code> из <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> или <code><span class="special">begin0</span></code>
из некоторых версий Scheme, которые последовательно вычисляют формы подобно
<code><span class="special">begin</span></code>, но возвращают значение первой из них, а не последней. Вот только
<code><span class="special">unwind-protect</span></code> гарантирует выполнение <i>уборщиков</i> даже в случае, если
вычисление <i>формы</i> было прервано переходом. Поэтому:</p>

<pre>(<span class="special">let</span> ((<span class="var">a</span> '<span class="var">on</span>))          <span class="dialect"><span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span></span>
  (<span class="func">cons</span> (<span class="special">unwind-protect</span> (<span class="func">list</span> <span class="var">a</span>)
          (<span class="special">setq</span> <span class="var">a</span> '<span class="var">off</span>) )
        <span class="var">a</span> ) ) <span class="math"><span class="rel">→</span></span> ((<span class="var">on</span>) . <span class="var">off</span>)

(<span class="special">block</span> <span class="var">foo</span>
  (<span class="special">unwind-protect</span> (<span class="special">return-from</span> <span class="var">foo</span> <span class="num">1</span>)
    (<span class="func">print</span> <span class="num">2</span>) ) ) <span class="math"><span class="rel">→</span></span> <span class="num">1</span> <span class="comment">; и печатает <code><span class="num">2</span></code></span></pre>

<p>Данная форма полезна, когда состояние системы должно быть восстановлено вне
зависимости от результата производимых действий. Например, когда мы читаем файл,
то в конце он должен быть закрыт в любом случае. Другим примером является
эмуляция <code><span class="special">catch</span></code> с помощью <code><span class="special">block</span></code>. Если данные формы используются
одновременно, то возможна рассинхронизация состояния <code><span class="var">*active-catchers*</span></code>.
Этот недостаток можно исправить с помощью <code><span class="special">unwind-protect</span></code>, гарантируя
восстановление <code><span class="var">*active-catchers*</span></code>:</p>


<!--\indexCS{catch}{с помощью <code><span class="func">unwind-protect</span></code>}-->
<pre>(<span class="special">define-syntax</span> <span class="var">catch</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">catch</span> <span class="var">tag</span> . <span class="var">body</span>)
     (<span class="syntax">let</span> ((<span class="var">saved-catchers</span> <span class="var">*active-catchers*</span>))
       (<span class="special">unwind-protect</span>
         (<span class="special">block</span> <span class="var">label</span>
           (<span class="special">set!</span> <span class="var">*active-catchers*</span>
                 (<span class="func">cons</span> (<span class="func">cons</span> <span class="var">tag</span> (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">return-from</span> <span class="var">label</span> <span class="var">x</span>)))
                       <span class="var">*active-catchers*</span>) )
           . <span class="var">body</span> )
         (<span class="special">set!</span> <span class="var">*active-catchers*</span> <span class="var">saved-catchers</span>) ) ) ) ) )</pre>

<p>Что бы ни случилось, теперь <code><span class="var">*active-catchers*</span></code> будет иметь корректное
состояние при выходе из тела формы. Форму <code><span class="special">block</span></code> можно использовать внутри
<code><span class="syntax">catch</span></code> не опасаясь, что <code><span class="syntax">catch</span></code> не удалится из <code><span class="var">*active-catchers*</span></code>,
так как теперь за этим следит <code><span class="special">unwind-protect</span></code>. Это гораздо лучше, хотя всё
ещё не идеально: <code><span class="var">*active-catchers*</span></code> доступна не только <code><span class="syntax">catch</span></code> и
<code><span class="syntax">throw</span></code>, так что её состояние всё равно можно исказить (случайно или
намеренно).</p>

<p>Форма <code><span class="special">unwind-protect</span></code> обеспечивает защиту системы от противоречий, выполняя
определённые действия после завершения вычислений. Следовательно, эта форма
обязана знать, когда именно они завершаются. Но в присутствии продолжений
с неограниченным временем жизни <code><span class="special">unwind-protect</span></code> не может легко ответить на
этот вопрос<a class="footref" href="zz_footnotes.xhtml#foot3.10"><sup>10</sup></a>.</p>

<p>Как мы уже не раз говорили, семантика управляющих структур далека от точного
определения. Рассмотрим лишь несколько примеров, где нельзя однозначно сказать,
какой мы получим результат:</p>

<pre>(<span class="special">block</span> <span class="var">foo</span>
  (<span class="special">unwind-protect</span> (<span class="special">return-from</span> <span class="var">foo</span> <span class="num">1</span>)
    (<span class="special">return-from</span> <span class="var">foo</span> <span class="num">2</span>) ) )                          <span class="math"><span class="rel">→</span></span> <i>?</i>

(<span class="special">catch</span> '<span class="var">bar</span>
  (<span class="special">block</span> <span class="var">foo</span>
    (<span class="special">unwind-protect</span> (<span class="special">return-from</span> <span class="var">foo</span> (<span class="special">throw</span> '<span class="var">bar</span> <span class="num">1</span>))
      (<span class="special">throw</span> '<span class="var">something</span> (<span class="special">return-from</span> <span class="var">foo</span> <span class="num">2</span>)) ) ) )   <span class="math"><span class="rel">→</span></span> <i>?</i></pre>

<!--\indexCS{unwind-protect}{проблемы семантики}-->
<p id="escape/forms/protection/p:discard">Конечно, стремление к более точным определениям
управляющих структур естественно, однако нельзя игнорировать очевидную неопределённость,
привносимую продолжениями в понятие «после вычислений». Не всё можно выяснить только по
исходному коду. Продолжения по определению <em>динамичны</em>, так как являются
воплощением потока исполнения. Рассмотрим следующий пример:</p>

<pre>(<span class="special">block</span> <span class="var">bar</span>
  (<span class="special">unwind-protect</span> (<span class="special">return-from</span> <span class="var">bar</span> <span class="num">1</span>)
    (<span class="special">block</span> <span class="var">foo</span> <span class="math"><span class="ord var">π</span></span>) ) )</pre>

<p><code><span class="special">unwind-protect</span></code> вклинивается в поток исполнения и не даёт завершить переход,
который выполняется в охраняемой ей форме. Вместо этого данный переход
становится продолжением формы <code>(<span class="special">block</span> <span class="var">foo</span> ...)</code>. Если она просто вернёт
результат, то это продолжение активируется и форма <code>(<span class="special">block</span> <span class="var">bar</span> ...)</code>
передаст <code><span class="num">1</span></code> своему продолжению. Если же внутри <span class="math"><span class="ord var">π</span></span> будет выполнен переход,
то данное продолжение должно быть отброшено и заменено продолжением перехода.
В этом случае из-за <code><span class="special">unwind-protect</span></code> «после вычислений <code>(<span class="special">return-from</span> <span class="var">bar</span> <span class="num">1</span>)</code>» не наступает вообще.
(Мы обсудим этот феномен позже вместе деталями реализации данной формы.)</p>

<div class="bigskip"/>

<p>Конечно же, есть и другие управляющие формы. Особенно их жалует <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>,
в котором реализована даже старая <code><span class="special">prog</span></code>, только под названием <code><span class="special">tagbody</span></code>.
Её можно легко проэмулировать с помощью <code><span class="special">labels</span></code> и <code><span class="special">block</span></code>.
<span class="see">[см. упр. <a href="#escape/ex:tagbody">3.3</a>]</span>
Интересным фактом является то, что если продолжения
имеют исключительно динамическое время жизни, то для реализации любого
управления потоком исполнения достаточно форм <code><span class="special">block</span></code>, <code><span class="special">return-from</span></code> и
<code><span class="special">unwind-protect</span></code>. Аналогично, для продолжений с неограниченным временем жизни
достаточно одной <code><span class="func">call/cc</span></code>. Очевидно, что мы не сможем легко реализовать
<code><span class="func">call/cc</span></code>, имея лишь продолжения с динамическим временем жизни. Обратное
вполне возможно, хотя это и стрельба из пушки по воробьям. Способ станет вполне
очевидным после рассмотрения реализации интерпретатора с явными продолжениями.</p>


<h4><span class="wrap"><span class="title">Защита и динамические переменные</span></span></h4>

<!--\indexC{fluid-let}-->
<!--\indexCS{unwind-protect}{динамические переменные}-->
<!--\indexR{динамические переменные!\protect<code><span class="func">unwind-protect</span></code>}-->
<p>Некоторые реализации Scheme обеспечивают динамическое время жизни переменных
не так, как мы показывали ранее. Они делают это с помощью <code><span class="special">unwind-protect</span></code>
или аналогичного механизма. Идея состоит в том, чтобы «одолжить» нужную
лексическую переменную, восстановив впоследствии её значение обратно. Подобные
динамические переменные реализуются с помощью формы <code><span class="syntax">fluid-let</span></code>:</p>

<table class="nocaption code"><tbody><tr>
<td><pre>(<span class="syntax">fluid-let</span> ((<span class="var">x</span> <span class="math"><span class="ord var">α</span></span>))
  <span class="math"><span class="ord var">β</span></span>... ) </pre></td>
<td><span class="math"><span class="ord"/><span class="rel">≡</span><span class="ord"/></span></td>
<td><pre>(<span class="syntax">let</span> ((<i>tmp</i> <span class="var">x</span>))
  (<span class="special">set!</span> <span class="var">x</span> <span class="math"><span class="ord var">α</span></span>)
  (<span class="special">unwind-protect</span>
    (<span class="special">begin</span> <span class="math"><span class="ord var">β</span></span>...)
    (<span class="special">set!</span> <span class="var">x</span> <i>tmp</i>) ) )</pre></td>
</tr></tbody></table>

<p>В процессе вычисления <span class="math"><span class="ord var">β</span></span>
будет видна переменная <code><span class="var">x</span></code> со значением
<span class="math"><span class="ord var">α</span></span>;
предыдущее значение <code><span class="var">x</span></code> сохраняется на время
вычислений в локальной переменной <i>tmp</i> и восстанавливается после их
завершения. Это подразумевает, что есть такая лексическая переменная
<code><span class="var">x</span></code>,
которой можно воспользоваться. Обычно она глобальная, чтобы её было видно
отовсюду. Если она будет локальной, то её поведение будет (значительно)
отличаться от должного поведения динамической переменной в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>: ведь
тогда она будет правильно работать внутри <code><span class="syntax">fluid-let</span></code>, но не в связывающих
формах, вложенных во <code><span class="syntax">fluid-let</span></code>. Далее, очевидно, что такие переменные тоже
не дружат с <code><span class="func">call/cc</span></code>. В итоге получается нечто ещё более хитрое, нежели
обычные динамические переменные <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>.</p>


<h2 id="escape/sect:actors"><span class="wrap"><span class="seq">3.2.</span><span class="title">Участники вычислений</span></span></h2>

<!--\indexR{вычисления!контекст}-->
<!--\indexR{контекст вычислений}-->
<p>Сейчас мы считаем, что для проведения вычислений необходимы три вещи: выражение,
окружение и продолжение. Тактическая цель вычислений: определить значение
выражения в окружении. Стратегическая — передать это значение продолжению.</p>

<!--\indexR{записи активации}-->
<!--\indexR{фреймы стека}-->
<!--\indexR{стековые фреймы}-->
<p>Мы определим новый интерпретатор, чтобы показать, какие продолжения нужны на
каждом этапе вычислений. Так как обычно продолжения представляются снимками
фреймов стека (или записей активаций), то мы будем использовать объекты для
представления этих сущностей внутри разрабатываемого интерпретатора.</p>


<h3 id="escape/actors/ssect:review"><span class="wrap"><span class="seq">3.2.1.</span><span class="title">Краткий обзор объектов</span></span></h3>

<!--\indexR{объекты}-->
<!--\indexE{Meroon@\protect\MeroonMeroonet!вводное описание}-->
<p>В этом разделе мы не будем детально разбирать устройство объектной системы,
отложив эту задачу до одиннадцатой главы. Здесь рассматриваются лишь три макроса
и несколько правил именования. Такие макросы выражают суть объектов и в том
или ином виде присутствуют в любой объектной системе любого языка. Объекты же
используются для того, чтобы подсказать удобный вариант реализации продолжений.
Уж очень хорошо понятие записи активации, инкапсулирующей различные данные,
связанные с вызовами подпрограмм, укладывается в концепцию объектов с полями.
Также у нас будет в распоряжении наследование, которое поможет вынести общие
части реализации за скобки, уменьшая таким образом размер интерпретатора.</p>

<p>Я полагаю, что вы знакомы с философией, терминологией и подходами
объектно-ориентированного программирования, так что будет достаточно показать,
как здесь записываются известные вам идиомы, которые мы будем использовать.</p>

<!--\indexR{классы}-->
<!--\indexR{методы}-->
<!--\indexR{обобщённые функции}-->
<!--\indexR{функции!обобщённые}-->
<p>Объекты группируются в <em class="term">классы</em>; объекты одного класса имеют одинаковые
<em class="term">методы</em>; сообщения посылаются с помощью <em class="term">обобщённых функций</em>,
популяризованных Common Loops <span class="cite">[<a href="z1_bibliography.xhtml#bkk+86">BKK<sup>+</sup>86</a>]</span>, CLOS <span class="cite">[<a href="z1_bibliography.xhtml#bdg+88">BDG<sup>+</sup>88</a>]</span> и
ΤΕΛΟΣ <span class="cite">[<a href="z1_bibliography.xhtml#pnb93">PNB93</a>]</span>. Для нас важнейшей возможностью объектно-ориентированного
программирования является отделение обработки различных специальных форм и
примитивных функций от ядра интерпретатора. Но всё имеет свою цену: в этом
случае будет сложнее увидеть картину целиком, так как обработка будет размазана
по нескольким местам.</p>


<h4><span class="wrap"><span class="title">Определение классов</span></span></h4>

<!--\indexC{define-class}-->
<p>Классы определяется с помощью <code><span class="syntax">define-class</span></code> следующим образом:</p>

<pre>(<span class="syntax">define-class</span> <i>класс</i> <i>суперкласс</i>
  (<i>поля</i>...) )</pre>

<!--\indexR{поля}-->
<!--\indexR{аксессоры}-->
<p>Эта форма определяет класс с именем <i>класс</i>, который наследует поля и методы
<i>суперкласса</i>, а также имеет свои собственные <i>поля</i>. Вместе с классом
создаётся набор вспомогательных функций. Функция <code><span class="func">make-<i>класс</i></span></code> создаёт
объекты этого класса; количество и порядок её аргументов соответствуют порядку
указания полей при определении класса. Названия аксессоров чтения состоят из
имени класса и имени поля, разделённых дефисом. Названия аксессоров записи
аналогичны аксессорам чтения, только с <code>set-</code> в начале и восклицательным
знаком в конце. Возвращаемое значение аксессоров записи не определено. Предикат
<code><span class="func"><i>класс</i>?</span></code> проверяет, является ли объект
экземпляром данного класса.</p>

<!--\indexC{Object}-->
<p>Корнем иерархии наследования является класс <code><span class="class">Object</span></code>, не имеющий полей.</p>

<p>Например, определение</p>

<pre>(<span class="syntax">define-class</span> <span class="class">continuation</span> <span class="class">Object</span> (<span class="var">k</span>))</pre>

<p class="noindent">создаст следующие функции:</p>

<pre>(<span class="func">make-continuation</span> <span class="var">k</span>)         <span class="comment">; конструктор</span>
(<span class="func">continuation-k</span> <span class="var">c</span>)            <span class="comment">; аксессор чтения</span>
(<span class="func">set-continuation-k!</span> <span class="var">c</span> <span class="var">k</span>)     <span class="comment">; аксессор записи</span>
(<span class="func">continuation?</span> <span class="var">k</span>)             <span class="comment">; предикат принадлежности</span></pre>


<h4><span class="wrap"><span class="title">Определение обобщённых функций</span></span></h4>

<!--\indexC{define-generic}-->
<!--\indexR{обобщённые функции}-->
<p>Обобщённые функции определяются следующим образом:</p>

<pre>(<span class="syntax">define-generic</span> (<i>функция</i> <i>аргументы</i>)
  <span class="normal">[<code><i>трактовка-по-умолчанию</i>...</code>]</span>)</pre>


<!--\indexR{дискриминант}-->
<!--\indexR{обобщённые функции!дискриминант}-->
<p>Эта форма определяет обобщённую <i>функцию</i>; формы
<i>трактовки-по-умолчанию</i> станут её телом, если при вызове функции
не найдётся подходящего специализированного варианта. Список аргументов
указывается как обычно, за исключением того, что один из них является
<em class="term">дискриминантом</em>; дискриминант записывается в скобках:</p>

<pre>(<span class="syntax">define-generic</span> (<span class="func">invoke</span> (<span class="var">f</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">wrong</span> <span class="string">"Not a function"</span> <span class="var">f</span> <span class="var">r</span> <span class="var">k</span>) )</pre>

<p>Таким образом определяется обобщённая функция <code><span class="func">invoke</span></code>, для которой можно
в последующем задать специализированные варианты. Данная функция имеет четыре
аргумента, первый из них — <code><span class="var">f</span></code> — это дискриминант. Если для
класса <code><span class="var">f</span></code> не найдётся специализированного варианта функции (метода
класса <code><span class="var">f</span></code>), то будет выбран вариант по умолчанию: вызов <code><span class="func">wrong</span></code>.</p>


<h4><span class="wrap"><span class="title">Определение методов</span></span></h4>

<!--\indexC{define-method}-->
<p>Форма <code><span class="syntax">define-method</span></code> используется для специализации обобщённых функций
конкретными методами.</p>

<pre>(<span class="syntax">define-method</span> (<i>функция</i> <i>аргументы</i>)
  <i>тело</i>... )</pre>

<p>Аргументы указываются аналогично <code><span class="syntax">define-generic</span></code>. Класс дискриминанта, для
которого создаётся метод, указывается после него. Например, мы можем создать
метод <code><span class="func">invoke</span></code> для класса <code><span class="class">primitive</span></code> следующим образом:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">primitive</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
  ((<span class="func">primitive-address</span> <span class="var">f</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>) )</pre>

<p>На этом мы заканчиваем обзор объектной системы и переходим к написанию
интерпретатора. Детали реализации, а также другие возможности объектов будут
рассмотрены в одиннадцатой главе. Здесь мы ограничимся наиболее простыми и
известными из них, чтобы облегчить понимание и уменьшить количество возможных
проблем.</p>


<h3 id="escape/actors/ssect:interpreter"><span class="wrap"><span class="seq">3.2.2.</span><span class="title">Интерпретатор</span></span></h3>

<!--\indexR{соглашения именования}-->
<!--\indexE{e @\protect<code><span class="func">e</span></code> (выражения)}-->
<!--\indexE{r @\protect<code><span class="func">r</span></code> (лексическое окружение)}-->
<!--\indexE{k @\protect<code><span class="func">k</span></code> (продолжения)}-->
<!--\indexE{v @\protect<code><span class="func">v</span></code> (значения)}-->
<!--\indexE{f @\protect<code><span class="func">f</span></code> (функции)}-->
<!--\indexE{n @\protect<code><span class="func">n</span></code> (идентификаторы)}-->
<p>Функция <code><span class="func">evaluate</span></code> имеет три аргумента: выражение, окружение и продолжение.
Начинает она свою работу с выяснения смысла выражения, чтобы выбрать правильный
метод его вычисления, который хранится в специализированной функции. Перед тем,
как продолжить, давайте договоримся о правилах именования переменных, которых
теперь будет довольно много. Первое правило: сущность «список <i>x</i>» будем
называть <code><i>x</i>*</code>. Второе: сущности интерпретатора будем называть
одной-двумя буквами для краткости:</p>

<table class="term-def">
<tbody>
<tr><td class="left"><code><span class="var">e</span></code>,
                           <code><span class="var">et</span></code>,
                           <code><span class="var">ec</span></code>,
                           <code><span class="var">ef</span></code></td>
    <td class="right">выражения, формы</td></tr>
<tr><td class="left"><code><span class="var">r</span></code></td>
    <td class="right">окружения</td></tr>
<tr><td class="left"><code><span class="var">k</span></code>,
                     <code><span class="var">kk</span></code></td>
    <td class="right">продолжения</td></tr>
<tr><td class="left"><code><span class="var">v</span></code></td>
    <td class="right">значения (числа, пары, замыкания и т. д.)</td></tr>
<tr><td class="left"><code><span class="var">f</span></code></td>
    <td class="right">функции</td></tr>
<tr><td class="left"><code><span class="var">n</span></code></td>
    <td class="right">идентификаторы</td></tr>
</tbody>
</table>

<p>Всё, теперь принимаемся за интерпретатор. Для простоты он считает все атомы,
кроме переменных, автоцитированными значениями.</p>

<!--\indexC{evaluate}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">evaluate-variable</span> <span class="var">e</span> <span class="var">r</span> <span class="var">k</span>))
            (<span class="syntax">else</span>        (<span class="func">evaluate-quote</span> <span class="var">e</span> <span class="var">r</span> <span class="var">k</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">evaluate-quote</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
        ((<span class="var">if</span>)     (<span class="func">evaluate-if</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
        ((<span class="var">begin</span>)  (<span class="func">evaluate-begin</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
        ((<span class="var">set!</span>)   (<span class="func">evaluate-set!</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
        ((<span class="var">lambda</span>) (<span class="func">evaluate-lambda</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
        (<span class="syntax">else</span>     (<span class="func">evaluate-application</span> (<span class="func">car</span> <span class="var">e</span>) (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>)) ) ) )</pre>

<p>Собственно интерпретатор состоит из трёх функций: <code><span class="func">evaluate</span></code>, <code><span class="func">invoke</span></code> и
<code><span class="func">resume</span></code>. Две последние являются обобщёнными и знают, как вызывать вызываемое
и продолжать продолжаемое. Все вычисления в конечном счёте сводятся к обмену
значениями между этими функциями. Вдобавок мы введём ещё две полезные обобщённые
функции для работы с переменными: <code><span class="func">lookup</span></code> и <code><span class="func">update!</span></code>.</p>

<!--\indexC{invoke}-->
<!--\indexC{resume}-->
<!--\indexC{lookup}-->
<!--\indexC{update"!}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">invoke</span> (<span class="var">f</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">wrong</span> <span class="string">"Not a function"</span> <span class="var">f</span> <span class="var">r</span> <span class="var">k</span>) )

(<span class="syntax">define-generic</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">continuation</span>) <span class="var">v</span>)
  (<span class="func">wrong</span> <span class="string">"Unknown continuation"</span> <span class="var">k</span>) )

(<span class="syntax">define-generic</span> (<span class="func">lookup</span> (<span class="var">r</span> <span class="class">environment</span>) <span class="var">n</span> <span class="var">k</span>)
  (<span class="func">wrong</span> <span class="string">"Not an environment"</span> <span class="var">r</span> <span class="var">n</span> <span class="var">k</span>) )

(<span class="syntax">define-generic</span> (<span class="func">update!</span> (<span class="var">r</span> <span class="class">environment</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="func">wrong</span> <span class="string">"Not an environment"</span> <span class="var">r</span> <span class="var">n</span> <span class="var">k</span>) )</pre>

<p>Все сущности, которыми мы будем оперировать, наследуются от трёх базовых
классов:</p>

<!--\indexC{value}-->
<!--\indexC{environment}-->
<!--\indexC{continuation}-->
<pre>(<span class="syntax">define-class</span> <span class="class">value</span>        <span class="class">Object</span> ())
(<span class="syntax">define-class</span> <span class="class">environment</span>  <span class="class">Object</span> ())
(<span class="syntax">define-class</span> <span class="class">continuation</span> <span class="class">Object</span> (<span class="var">k</span>))</pre>

<p>Классы значений являются наследниками <code><span class="class">value</span></code>, классы окружений —
наследники <code><span class="class">environment</span></code>, классы продолжений — <code><span class="class">continuation</span></code>.</p>


<h3 id="escape/actors/ssect:quoting"><span class="wrap"><span class="seq">3.2.3.</span><span class="title">Цитирование</span></span></h3>

<p>Специальная форма цитирования всё так же является наиболее простой, её задача
сводится к передаче значения в неизменной форме текущему продолжению:</p>


<!--\indexC{evaluate-quotation}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate-quotation</span> <span class="var">v</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">resume</span> <span class="var">k</span> <span class="var">v</span>) )</pre>


<h3 id="escape/actors/ssect:alternatives"><span class="wrap"><span class="seq">3.2.4.</span><span class="title">Ветвление</span></span></h3>

<p>Условный оператор использует два продолжения: текущее и продолжение вычисления
условия, которое выберет и вычислит необходимую ветку. Для этого продолжения мы
создадим отдельный класс. После вычисления условия ещё остаётся вычисление той
или иной ветки, а значит, в продолжении необходимо хранить сами ветки и
окружение для их вычисления. Результат вычисления одной из веток надо будет
передать продолжению условной формы, которое тоже надо где-то хранить. Таким
образом, мы пишем:</p>

<!--\indexC{if-cont}-->
<!--\indexC{evaluate-if}-->
<!--\indexCS{resume}{<code><span class="func">if-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">if-cont</span> <span class="class">continuation</span> (<span class="var">et</span> <span class="var">ef</span> <span class="var">r</span>))

(<span class="special">define</span> (<span class="func">evaluate-if</span> <span class="var">ec</span> <span class="var">et</span> <span class="var">ef</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">ec</span> <span class="var">r</span> (<span class="func">make-if-cont</span> <span class="var">k</span> <span class="var">et</span> <span class="var">ef</span> <span class="var">r</span>)) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">if-cont</span>) <span class="var">v</span>)
  (<span class="func">evaluate</span> (<span class="special">if</span> <span class="var">v</span> (<span class="func">if-cont-et</span> <span class="var">k</span>) (<span class="func">if-cont-ef</span> <span class="var">k</span>))
            (<span class="func">if-cont-r</span> <span class="var">k</span>)
            (<span class="func">if-cont-k</span> <span class="var">k</span>) ) )</pre>

<p>Форма вначале вычисляет условие <code><span class="var">ec</span></code> в своём окружении <code><span class="var">r</span></code>, но с новым
продолжением. Как только мы заканчиваем вычислять условие, результат передаётся
<code><span class="func">resume</span></code>, которая вызывает специализацию для нашего класса продолжений.
В этом продолжении мы выполняем собственно выбор, вычисляем одну их сохранённых
веток в сохранённом окружении и передаём результат сохранённому продолжению всей
условной формы.<a class="footref" href="zz_footnotes.xhtml#foot3.11"><sup>11</sup></a></p>


<h3 id="escape/actors/ssect:sequence"><span class="wrap"><span class="seq">3.2.5.</span><span class="title">Последовательность</span></span></h3>

<p>Здесь нам тоже потребуются два продолжения: текущее и продолжение вычисления
оставшихся форм.</p>

<!--\indexC{begin-cont}-->
<!--\indexC{evaluate-begin}-->
<!--\indexCS{resume}{<code><span class="func">begin-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">begin-cont</span> <span class="class">continuation</span> (<span class="var">e*</span> <span class="var">r</span>))

(<span class="special">define</span> (<span class="func">evaluate-begin</span> <span class="var">e*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
    (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e*</span>))
        (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> (<span class="func">make-begin-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>))
        (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> <span class="var">k</span>) )
    (<span class="func">resume</span> <span class="var">k</span> <span class="var">empty-begin-value</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">begin-cont</span>) <span class="var">v</span>)
  (<span class="func">evaluate-begin</span> (<span class="func">cdr</span> (<span class="func">begin-cont-e*</span> <span class="var">k</span>))
                  (<span class="func">begin-cont-r</span> <span class="var">k</span>)
                  (<span class="func">begin-cont-k</span> <span class="var">k</span>) ) )</pre>

<p>Случаи <code>(<span class="special">begin</span>)</code> и <code>(<span class="special">begin</span> <span class="math"><span class="ord var">π</span></span>)</code> тривиальны.
Если же <code><span class="special">begin</span></code>
передано больше выражений, то вычисление первого из них продолжается
<code>(<span class="func">make-begin-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>)</code>. Это продолжение принимает значение
<code><span class="var">v</span></code> с помощью <code><span class="func">resume</span></code>,
игнорирует его и продолжает оставшиеся вычисления
в том же окружении и с тем же продолжением.<a class="footref" href="zz_footnotes.xhtml#foot3.12"><sup>12</sup></a></p>


<h3 id="escape/actors/ssect:variables"><span class="wrap"><span class="seq">3.2.6.</span><span class="title">Окружения</span></span></h3>

<p>Значения переменных хранятся в окружениях. Они тоже представляются объектами:</p>

<!--\indexC{null-env}-->
<!--\indexC{full-env}-->
<!--\indexC{variable-env}-->
<pre>(<span class="syntax">define-class</span> <span class="class">null-env</span> <span class="class">environment</span> ())
(<span class="syntax">define-class</span> <span class="class">full-env</span> <span class="class">environment</span> (<span class="var">others</span> <span class="var">name</span>))
(<span class="syntax">define-class</span> <span class="class">variable-env</span> <span class="class">full-env</span> (<span class="var">value</span>))</pre>

<p>Нам потребуются два типа окружений: пустое начальное окружение
<code><span class="class">null-env</span></code> и
окружения с переменными <code><span class="class">variable-env</span></code>.
Последние хранят одну привязку имени
<code><span class="var">name</span></code> к значению
<code><span class="var">value</span></code>, а также ссылку на остальные привязки этого
окружения в поле <code><span class="var">others</span></code>.
То есть это обычный А-список, разве что для
хранения каждой привязки используется объект с тремя полями, а не две точечных
пары.</p>

<p>Для нахождения значения переменной мы делаем следующее:</p>

<!--\indexC{evaluate-variable}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate-variable</span> <span class="var">n</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">lookup</span> <span class="var">r</span> <span class="var">n</span> <span class="var">k</span>) )

(<span class="syntax">define-method</span> (<span class="func">lookup</span> (<span class="var">r</span> <span class="class">null-env</span>) <span class="var">n</span> <span class="var">k</span>)
  (<span class="func">wrong</span> <span class="string">"Unknown variable"</span> <span class="var">n</span> <span class="var">r</span> <span class="var">k</span>) )

(<span class="syntax">define-method</span> (<span class="func">lookup</span> (<span class="var">r</span> <span class="class">full-env</span>) <span class="var">n</span> <span class="var">k</span>)
  (<span class="func">lookup</span> (<span class="func">full-env-others</span> <span class="var">r</span>) <span class="var">n</span> <span class="var">k</span>) )

(<span class="syntax">define-method</span> (<span class="func">lookup</span> (<span class="var">r</span> <span class="class">variable-env</span>) <span class="var">n</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">eqv?</span> <span class="var">n</span> (<span class="func">variable-env-name</span> <span class="var">r</span>))
      (<span class="func">resume</span> <span class="var">k</span> (<span class="func">variable-env-value</span> <span class="var">r</span>))
      (<span class="func">lookup</span> (<span class="func">variable-env-others</span> <span class="var">r</span>) <span class="var">n</span> <span class="var">k</span>) ) )</pre>

<p>Обобщённая функция <code><span class="func">lookup</span></code> проходит по окружению, пока не найдёт подходящую
привязку: с совпадающим именем и хранящую значение переменной. Найденное
значение передаётся исходному продолжению с помощью <code><span class="func">resume</span></code>.</p>

<p>Изменение значения происходит похожим образом:</p>

<!--\indexC{set"!-cont}-->
<!--\indexC{evaluate-set"!}-->
<!--\indexCS{resume}{<code><span class="func">set"!-cont</span></code>}-->
<!--\indexCS{update"!}{<code><span class="func">null-env</span></code>}-->
<!--\indexCS{update"!}{<code><span class="func">full-env</span></code>}-->
<!--\indexCS{update"!}{<code><span class="func">variable-env</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">set!-cont</span> <span class="class">continuation</span> (<span class="var">n</span> <span class="var">r</span>))

(<span class="special">define</span> (<span class="func">evaluate-set!</span> <span class="var">n</span> <span class="var">e</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">r</span> (<span class="func">make-set!-cont</span> <span class="var">k</span> <span class="var">n</span> <span class="var">r</span>)) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">set!-cont</span>) <span class="var">v</span>)
  (<span class="func">update!</span> (<span class="func">set!-cont-r</span> <span class="var">k</span>) (<span class="func">set!-cont-n</span> <span class="var">k</span>) (<span class="func">set!-cont-k</span> <span class="var">k</span>) <span class="var">v</span>) )

(<span class="syntax">define-method</span> (<span class="func">update!</span> (<span class="var">r</span> <span class="class">null-env</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="func">wrong</span> <span class="string">"Unknown variable"</span> <span class="var">n</span> <span class="var">r</span> <span class="var">k</span>) )

(<span class="syntax">define-method</span> (<span class="func">update!</span> (<span class="var">r</span> <span class="class">full-env</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="func">update!</span> (<span class="func">full-env-others</span> <span class="var">r</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>) )

(<span class="syntax">define-method</span> <span class="func">(update!</span> (<span class="var">r</span> <span class="class">variable-env</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="special">if</span> (<span class="func">eqv?</span> <span class="var">n</span> (<span class="func">variable-env-name</span> <span class="var">r</span>))
      (<span class="special">begin</span> (<span class="func">set-variable-env-value!</span> <span class="var">r</span> <span class="var">v</span>)
             (<span class="func">resume</span> <span class="var">k</span> <span class="var">v</span>) )
      (<span class="func">update!</span> (<span class="func">variable-env-others</span> <span class="var">r</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>) ) )</pre>

<p>Нам потребовалось вспомогательное продолжение, так как присваивание проходит
в два этапа: сначала надо вычислить присваиваемое значение, потом присвоить его
переменной. Класс <code><span class="class">set!-cont</span></code> представляет необходимые продолжения, его метод
<code><span class="func">resume</span></code> лишь вызывает <code><span class="func">update!</span></code> для установки значения, после чего
продолжает дальнейшие вычисления.</p>


<h3 id="escape/actors/ssect:functions"><span class="wrap"><span class="seq">3.2.7.</span><span class="title">Функции</span></span></h3>

<p>Создать функцию легко, с этим справится
<code><span class="func">make-function</span></code>:</p>

<!--\indexC{function}-->
<!--\indexC{evaluate-lambda}-->
<pre>(<span class="syntax">define-class</span> <span class="class">function</span> <span class="class">value</span> (<span class="var">variables</span> <span class="var">body</span> <span class="var">env</span>))

(<span class="special">define</span> (<span class="func">evaluate-lambda</span> <span class="var">n*</span> <span class="var">e*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">resume</span> <span class="var">k</span> (<span class="func">make-function</span> <span class="var">n*</span> <span class="var">e*</span> <span class="var">r</span>)) )</pre>

<p>Чуть сложнее будет вызвать созданную функцию. Обратите внимание на неявное
использование <code><span class="func">progn</span></code>/<code><span class="func">begin</span></code> для тела функций.</p>

<!--\indexCS{invoke}{<code><span class="func">function</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">function</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="syntax">let</span> ((<span class="var">env</span> (<span class="func">extend-env</span> (<span class="func">function-env</span> <span class="var">f</span>)
                         (<span class="func">function-variables</span> <span class="var">f</span>)
                         <span class="var">v*</span> )))
    (<span class="func">evaluate-begin</span> (<span class="func">function-body</span> <span class="var">f</span>) <span class="var">env</span> <span class="var">k</span>) ) )</pre>

<p>Может показаться странным, что функция принимает текущее окружение
<code><span class="var">r</span></code>, но
никак не использует его. Это сделано по нескольким причинам. Во-первых, обычно
при компиляции текущие окружение и продолжение считаются чем-то вроде
глобальных динамических переменных и передаются через жёстко заданные регистры,
которые никак не выкинуть из реализации. Во-вторых, некоторые функции (о них
поговорим позже, когда будем рассматривать рефлексию) могут изменять текущее
окружение; например, отладочные функции по запросу пользователя могут изменять
значения произвольных переменных.</p>

<p>Следующая функция расширяет окружение переменных. И выполняет проверку
согласованности количества имён и связываемых с ними значений.</p>

<!--\indexC{extend-env}-->
<pre>(<span class="special">define</span> (<span class="func">extend-env</span> <span class="var">env</span> <span class="var">names</span> <span class="var">values</span>)
  (<span class="syntax">cond</span> ((<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">names</span>) (<span class="func">pair?</span> <span class="var">values</span>))
         (<span class="func">make-variable-env</span>
          (<span class="func">extend-env</span> <span class="var">env</span> (<span class="func">cdr</span> <span class="var">names</span>) (<span class="func">cdr</span> <span class="var">values</span>))
          (<span class="func">car</span> <span class="var">names</span>)
          (<span class="func">car</span> <span class="var">values</span>) ) )
        ((<span class="syntax">and</span> (<span class="func">null?</span> <span class="var">names</span>) (<span class="func">null?</span> <span class="var">values</span>)) <span class="var">env</span>)
        ((<span class="func">symbol?</span> <span class="var">names</span>) (<span class="func">make-variable-env</span> <span class="var">env</span> <span class="var">names</span> <span class="var">values</span>))
        (<span class="syntax">else</span> (<span class="func">wrong</span> <span class="string">"Arity mismatch"</span>)) ) )</pre>

<p>Осталось только определить собственно применение функций. Здесь надо помнить
о том, что функция применяется к списку аргументов.</p>

<!--\indexC{evfun-cont}-->
<!--\indexC{apply-cont}-->
<!--\indexC{argument-cont}-->
<!--\indexC{gather-cont}-->
<!--\indexC{evaluate-application}-->
<!--\indexCS{resume}{<code><span class="func">evfun-cont</span></code>}-->
<!--\indexC{no-more-arguments}-->
<!--\indexC{evaluate-arguments}-->
<!--\indexCS{resume}{<code><span class="func">argument-cont</span></code>}-->
<!--\indexCS{resume}{<code><span class="func">gather-cont</span></code>}-->
<!--\indexCS{resume}{<code><span class="func">apply-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">evfun-cont</span>    <span class="class">continuation</span> (<span class="var">e*</span> <span class="var">r</span>))
(<span class="syntax">define-class</span> <span class="class">apply-cont</span>    <span class="class">continuation</span> (<span class="var">f</span>  <span class="var">r</span>))
(<span class="syntax">define-class</span> <span class="class">argument-cont</span> <span class="class">continuation</span> (<span class="var">e*</span> <span class="var">r</span>))
(<span class="syntax">define-class</span> <span class="class">gather-cont</span>   <span class="class">continuation</span> (<span class="var">v</span>))

(<span class="special">define</span> (<span class="func">evaluate-application</span> <span class="var">e</span> <span class="var">e*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">r</span> (<span class="func">make-evfun-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>)) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">evfun-cont</span>) <span class="var">f</span>)
  (<span class="func">evaluate-argument</span>s (<span class="func">evfun-cont-e*</span> <span class="var">k</span>)
                      (<span class="func">evfun-cont-r</span> <span class="var">k</span>)
                      (<span class="func">make-apply-cont</span> (<span class="func">evfun-cont-k</span> <span class="var">k</span>) <span class="var">f</span>
                                       (<span class="func">evfun-cont-r</span> <span class="var">k</span>) ) ) )
(<span class="special">define</span> <span class="var">no-more-arguments</span> <span class="hash">'()</span>)

(<span class="special">define</span> (<span class="func">evaluate-arguments</span> <span class="var">e*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
      (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> (<span class="func">make-argument-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>))
      (<span class="func">resume</span> <span class="var">k</span> <span class="var">no-more-arguments</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">argument-cont</span>) <span class="var">v</span>)
  (<span class="func">evaluate-arguments</span> (<span class="func">cdr</span> (<span class="func">argument-cont-e*</span> <span class="var">k</span>))
                      (<span class="func">argument-cont-r</span> <span class="var">k</span>)
                      (<span class="func">make-gather-cont</span> (<span class="func">argument-cont-k</span> <span class="var">k</span>) <span class="var">v</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">gather-cont</span>) <span class="var">v*</span>)
  (<span class="func">resume</span> (<span class="func">gather-cont-k</span> <span class="var">k</span>) (<span class="func">cons</span> (<span class="func">gather-cont-v</span> <span class="var">k</span>) <span class="var">v*</span>)) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">apply-cont</span>) <span class="var">v</span>)
  (<span class="func">invoke</span> (<span class="func">apply-cont-f</span> <span class="var">k</span>) <span class="var">v</span>
          (<span class="func">apply-cont-r</span> <span class="var">k</span>)
          (<span class="func">apply-cont-k</span> <span class="var">k</span>) ) )</pre>

<p>На первый взгляд, здесь всё слишком сложно, но только на первый. Вычисления
проводятся слева направо, так что первой вычисляется сама функция с продолжением
<code><span class="class">evfun-cont</span></code>. Это продолжение должно вычислить аргументы функции и передать
их продолжению, которое применит функцию к списку значений аргументов.
В процессе вычисления аргументов мы обращаемся к продолжениям <code><span class="class">gather-cont</span></code>,
которые последовательно собирают вычисленные аргументы в список.</p>

<!--\indexR{продолжения (continuations)!иллюстрация стека}-->
<p>Давайте рассмотрим на примере, что происходит при вычислении <code>(<span class="func">cons</span> <span class="var">foo</span> <span class="var">bar</span>)</code>. Пусть переменная <code><span class="var">foo</span></code> имеет значение <span class="math"><span class="ord num">33</span></span>, а <code><span class="var">bar</span></code>
равна <span class="math"><span class="ord">−</span><span class="ord num">77</span></span>. Стек продолжений показан справа, а вычисляемое выражение слева. <i>k</i> — это текущее продолжение, <i>r</i> — текущее окружение.
Функция-значение переменной <code><span class="var">cons</span></code> записывается как
<i>cons</i>.</p>

<table id="ch3-eval-stack">
<tbody>
<tr><td class="left"><code><i>evaluate</i> (<span class="func">cons</span> <span class="var">foo</span> <span class="var">bar</span>) <i>r</i> </code></td><td class="right"><code> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>evaluate</i> <span class="var">cons</span> <i>r</i> </code></td><td class="right"><code> <span class="cont">evfun-cont</span> (<span class="var">foo</span> <span class="var">bar</span>) <i>r</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>resume</i> <i>cons</i> </code></td><td class="right"><code> <span class="cont">evfun-cont</span> (<span class="var">foo</span> <span class="var">bar</span>) <i>r</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>evaluate-arguments</i> (<span class="var">foo</span> <span class="var">bar</span>) <i>r</i> </code></td><td class="right"><code> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>evaluate</i> <span class="var">foo</span> <i>r</i> </code></td><td class="right"><code> <span class="cont">argument-cont</span> (<span class="var">foo</span> <span class="var">bar</span>) <i>r</i> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>resume</i> <span class="value">33</span> </code></td><td class="right"><code> <span class="cont">argument-cont</span> (<span class="var">foo</span> <span class="var">bar</span>) <i>r</i> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>evaluate-arguments</i> (<span class="var">bar</span>) <i>r</i> </code></td><td class="right"><code> <span class="cont">gather-cont</span> <span class="value">33</span> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>evaluate</i> <span class="var">bar</span> <i>r</i> </code></td><td class="right"><code><span class="cont">argument-cont</span> () <i>r</i> <span class="cont">gather-cont</span> <span class="value">33</span> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>resume</i> <span class="value">–77</span> </code></td><td class="right"><code> <span class="cont">argument-cont</span> () <i>r</i> <span class="cont">gather-cont</span> <span class="value">33</span> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>evaluate-arguments</i> () <i>r</i> </code></td><td class="right"><code> <span class="cont">gather-cont</span> <span class="value">–77</span> <span class="cont">gather-cont</span> <span class="value">33</span> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>resume</i> <span class="value">()</span> </code></td><td class="right"><code><span class="cont">gather-cont</span> <span class="value">–77</span> <span class="cont">gather-cont</span> <span class="value">33</span> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>resume</i> <span class="value">(–77)</span> </code></td><td class="right"><code> <span class="cont">gather-cont</span> <span class="value">33</span> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>resume</i> <span class="value">(33 –77)</span> </code></td><td class="right"><code> <span class="cont">apply-cont</span> <i>cons</i> <i>k</i></code></td></tr>
<tr><td class="left"><code><i>invoke</i> <i>cons</i> <span class="value">(33 –77)</span></code></td><td class="right"><code> <i>k</i></code></td></tr>
</tbody>
</table>


<h2 id="escape/sect:init"><span class="wrap"><span class="seq">3.3.</span><span class="title">Инициализация интерпретатора</span></span></h2>

<p>Перед погружением в сокровенные тайны устройства управляющих форм, давайте
сначала подготовим наш интерпретатор к запуску. Этот раздел похож на
раздел <a href="ch01_basics.xhtml#basics/sect:global-environment">1.7</a>.
Неплохо было бы вначале научить наш интерпретатор нескольким полезным вещам вроде
<code><span class="func">car</span></code>, поэтому объявим
пару макросов, которые помогут нам наполнить его глобальное окружение.</p>

<!--\indexC{definitial}-->
<!--\indexC{defprimitive}-->
<!--\indexC{primitive}-->
<!--\indexC{r.init}-->
<!--\indexC{cons}-->
<!--\indexC{car}-->
<pre>(<span class="special">define-syntax</span> <span class="var">definitial</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">definitial</span> <span class="var">name</span>)
     (<span class="syntax">definitial</span> <span class="var">name</span> '<span class="var">void</span>) )
    ((<span class="syntax">definitial</span> <span class="var">name</span> <span class="var">value</span>)
     (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">r.init</span> (<span class="func">make-variable-env</span> <span class="var">r.init</span> '<span class="var">name</span> <span class="var">value</span>))
            '<span class="var">name</span> ) ) ) )

(<span class="syntax">define-class</span> <span class="class">primitive</span> <span class="class">value</span> (<span class="var">name</span> <span class="var">address</span>))

(<span class="special">define-syntax</span> <span class="var">defprimitive</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">defprimitive</span> <span class="var">name</span> <span class="var">value</span> <span class="var">arity</span>)
     (<span class="syntax">definitial</span> <span class="var">name</span>
       (<span class="func">make-primitive</span>
        '<span class="var">name</span> (<span class="special">lambda</span> (<span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
                (<span class="special">if</span> (<span class="func">=</span> <span class="var">arity</span> (<span class="func">length</span> <span class="var">v*</span>))
                    (<span class="func">resume</span> <span class="var">k</span> (<span class="func">apply</span> <span class="var">value</span> <span class="var">v*</span>))
                    (<span class="func">wrong</span> <span class="string">"Incorrect arity"</span> '<span class="var">name</span> <span class="var">v*</span>) ) ) ) ) ) ) )

(<span class="special">define</span> <span class="var">r.init</span> (<span class="func">make-null-env</span>))

(<span class="syntax">defprimitive</span> <span class="var">cons</span> <span class="var">cons</span> <span class="num">2</span>)
(<span class="syntax">defprimitive</span> <span class="var">car</span> <span class="var">car</span> <span class="num">1</span>)</pre>

<p>Создаваемые примитивные функции должны вызываться той же функцией <code><span class="func">invoke</span></code>,
которая обрабатывает обычные функции. Каждый примитив имеет два поля. Первое из
них служит для упрощения отладки: оно хранит имя примитива. Естественно, это
лишь подсказка, так как ничто не мешает в дальнейшем связать один и тот же
примитив с разными именами.<a class="footref" href="zz_footnotes.xhtml#foot3.13"><sup>13</sup></a> Второе поле хранит «адрес» примитива, ссылку на соответствующую
функцию языка реализации интерпретатора. В итоге примитивы вызываются с помощью
<code><span class="func">invoke</span></code> следующим образом:</p>

<!--\indexCS{invoke}{<code><span class="func">primitive</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">primitive</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
  ((<span class="func">primitive-address</span> <span class="var">f</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>) )</pre>

<p>Для запуска нашего прекрасного интерпретатора остаётся лишь определить начальное
продолжение-заглушку. Это продолжение будет печатать на экран всё, что ему
передают.</p>

<!--\indexC{bottom-cont}-->
<!--\indexCS{resume}{<code><span class="func">bottom-cont</span></code>}-->
<!--\indexC{chapter3-interpreter}-->
<pre>(<span class="syntax">define-class</span> <span class="class">bottom-cont</span> <span class="class">continuation</span> (<span class="var">f</span>))

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">bottom-cont</span>) <span class="var">v</span>)
  ((<span class="func">bottom-cont-f</span> <span class="var">k</span>) <span class="var">v</span>) )

(<span class="special">define</span> (<span class="func">chapter3-interpreter</span>)
  (<span class="special">define</span> (<span class="func">toplevel</span>)
    (<span class="func">evaluate</span> (<span class="func">read</span>)
              <span class="var">r.init</span>
              (<span class="func">make-bottom-cont</span> '<span class="var">void</span> <span class="var">display</span>) )
    (<span class="func">toplevel</span>) )
  (<span class="func">toplevel</span>) )</pre>

<p>Заметьте, что мы могли бы легко написать похожий интерпретатор на истинно
объектно-ориентированном языке, например на Smalltalk
<span class="cite">[<a href="z1_bibliography.xhtml#gr83">GR83</a>]</span>, получив
заодно доступ к его хвалёному отладчику и среде разработки. Для полного счастья
останется только добавить те несколько строчек, что открывают гору маленьких
окошек с контекстными подсказками.</p>


<h2 id="escape/sect:implementation"><span class="wrap"><span class="seq">3.4.</span><span class="title">Реализация управляющих форм</span></span></h2>

<p>Начнём с самой мощной формы — <code><span class="func">call/cc</span></code>. Парадоксально, но факт: это самая
простая форма, если смотреть на количество кода. Благодаря используемому нами
объектному подходу и явному присутствию продолжений в интерпретаторе,
преобразование их в полноценные объекты языка становится тривиальным.</p>


<h3 id="escape/implementation/ssect:call/cc"><span class="wrap"><span class="seq">3.4.1.</span><span class="title">Реализация <code><span class="func">call/cc</span></code></span></span></h3>

<!--\indexCS{call/cc}{реализация}-->
<p>Функция <code><span class="func">call/cc</span></code> берёт текущее продолжение <i>k</i>,
превращает его в объект, понятный <code><span class="func">invoke</span></code>, и применяет
к нему свой аргумент — унарную функцию. Следующий код чуть ли не буквально записывает это
определение:</p>

<!--\indexC{call/cc}-->
<pre>(<span class="syntax">definitial</span> <span class="var">call/cc</span>
  (<span class="func">make-primitive</span>
   '<span class="var">call/cc</span>
   (<span class="special">lambda</span> (<span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
     (<span class="special">if</span> (<span class="func">=</span> <span class="num">1</span> (<span class="func">length</span> <span class="var">v*</span>))
         (<span class="func">invoke</span> (<span class="func">car</span> <span class="var">v*</span>) (<span class="func">list</span> <span class="var">k</span>) <span class="var">r</span> <span class="var">k</span>)
         (<span class="func">wrong</span> <span class="string">"Incorrect arity"</span> '<span class="var">call/cc</span> <span class="var">v*</span>) ) ) ) )</pre>

<p>Хоть тут и немного строчек, всё же стоит кое-что объяснить. <code><span class="func">call/cc</span></code> это
функция, но мы определяем её с помощью <code><span class="syntax">defprimitive</span></code>, так как это
единственный способ для функции добраться до <code><span class="var">k</span></code>. Переменная <code><span class="func">call/cc</span></code>
(это всё же Lisp<sub>1</sub>) связывается с объектом класса <code><span class="class">primitive</span></code>. Для вызова
объектов этого класса необходим «адрес» функции, которому у нас соответствуют
функции языка определения вида <code>(<span class="special">lambda</span> (<span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>) ...)</code>. После проверки на
арность первый аргумент <code><span class="func">call/cc</span></code> применяется к захваченному продолжению.
Само продолжение мы никак не трогаем, оно остаётся объектом языка определения.
Так как сохранённые «сырые» продолжения могут быть впоследствии переданы
<code><span class="func">invoke</span></code> напрямую, то её надо научить обращаться с ними:</p>

<!--\indexCS{invoke}{<code><span class="func">continuation</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">continuation</span>) <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="num">1</span> (<span class="func">length</span> <span class="var">v*</span>))
      (<span class="func">resume</span> <span class="var">f</span> (<span class="func">car</span> <span class="var">v*</span>))
      (<span class="func">wrong</span> <span class="string">"Continuations expect one argument"</span> <span class="var">v*</span> <span class="var">r</span> <span class="var">k</span>) ) )</pre>


<h3 id="escape/implementation/ssect:catch"><span class="wrap"><span class="seq">3.4.2.</span><span class="title">Реализация <code><span class="special">catch</span></code></span></span></h3>

<!--\indexCS{catch}{реализация}-->
<!--\indexCS{throw}{реализация}-->
<p>Форма <code><span class="special">catch</span></code> по-своему интересна, так как требует разительно иного подхода,
нежели форма <code><span class="special">block</span></code>, которую мы рассмотрим чуть позже. Как обычно, начнём
с добавления анализа <code><span class="special">catch</span></code> и <code><span class="special">throw</span></code> в <code><span class="func">evaluate</span></code>:</p>

<pre>...
((<span class="var">catch</span>) (<span class="func">evaluate-catch</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
((<span class="var">throw</span>) (<span class="func">evaluate-throw</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
...</pre>

<p>Здесь решено сделать <code><span class="special">throw</span></code> специальной формой, а не функцией. В первую
очередь с целью походить на <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>. Далее определим правила обработки
формы <code><span class="special">catch</span></code>:</p>

<!--\indexC{catch-cont}-->
<!--\indexC{labeled-cont}-->
<!--\indexC{evaluate-catch}-->
<!--\indexCS{resume}{<code><span class="func">catch-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">catch-cont</span>   <span class="class">continuation</span> (<span class="var">body</span> <span class="var">r</span>))
(<span class="syntax">define-class</span> <span class="class">labeled-cont</span> <span class="class">continuation</span> (<span class="var">tag</span>))

(<span class="special">define</span> (<span class="func">evaluate-catch</span> <span class="var">tag</span> <span class="var">body</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">tag</span> <span class="var">r</span> (<span class="func">make-catch-cont</span> <span class="var">k</span> <span class="var">body</span> <span class="var">r</span>)) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">catch-cont</span>) <span class="var">v</span>)
  (<span class="func">evaluate-begin</span> (<span class="func">catch-cont-body</span> <span class="var">k</span>)
                  (<span class="func">catch-cont-r</span> <span class="var">k</span>)
                  (<span class="func">make-labeled-cont</span> (<span class="func">catch-cont-k</span> <span class="var">k</span>) <span class="var">v</span>) ) )</pre>

<p>Как видите, <code><span class="special">catch</span></code> вычисляет первый аргумент (метку), связывает с ней своё
продолжение, создавая таким образом помеченный блок, и, наконец, последовательно
вычисляет формы, составляющие её тело. Когда продолжение этого блока получает
значение, оно просто перебрасывает его сохранённому продолжению самой формы
<code><span class="special">catch</span></code>. Форма <code><span class="special">throw</span></code> чуть более сложная:</p>

<!--\indexC{throw-cont}-->
<!--\indexC{throwing-cont}-->
<!--\indexC{evaluate-throw}-->
<!--\indexCS{resume}{<code><span class="func">throw-cont</span></code>}-->
<!--\indexC{catch-lookup}-->
<!--\indexCS{resume}{<code><span class="func">throwing-cont</span></code>}-->
<!--\indexC{eqv"?}-->
<pre>(<span class="syntax">define-class</span> <span class="class">throw-cont</span>    <span class="class">continuation</span> (<span class="var">form</span> <span class="var">r</span>))
(<span class="syntax">define-class</span> <span class="class">throwing-cont</span> <span class="class">continuation</span> (<span class="var">tag</span> <span class="var">cont</span>))

(<span class="special">define</span> (<span class="func">evaluate-throw</span> <span class="var">tag</span> <span class="var">form</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">tag</span> <span class="var">r</span> (<span class="func">make-throw-cont</span> <span class="var">k</span> <span class="var">form</span> <span class="var">r</span>)) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">throw-cont</span>) <span class="var">tag</span>)
  (<span class="func">catch-lookup</span> <span class="var">k</span> <span class="var">tag</span> <span class="var">k</span>) )

(<span class="syntax">define-generic</span> (<span class="func">catch-lookup</span> (<span class="var">k</span>) <span class="var">tag</span> <span class="var">kk</span>)
  (<span class="func">wrong</span> <span class="string">"Not a continuation"</span> <span class="var">k</span> <span class="var">tag</span> <span class="var">kk</span>) )

(<span class="syntax">define-method</span> (<span class="func">catch-lookup</span> (<span class="var">k</span> <span class="class">continuation</span>) <span class="var">tag</span> <span class="var">kk</span>)
  (<span class="func">catch-lookup</span> (<span class="func">continuation-k</span> <span class="var">k</span>) <span class="var">tag</span> <span class="var">kk</span>) )

(<span class="syntax">define-method</span> (<span class="func">catch-lookup</span> (<span class="var">k</span> <span class="class">bottom-cont</span>) <span class="var">tag</span> <span class="var">kk</span>)
  (<span class="func">wrong</span> <span class="string">"No associated catch"</span> <span class="var">k</span> <span class="var">tag</span> <span class="var">kk</span>) )

(<span class="syntax">define-method</span> (<span class="func">catch-lookup</span> (<span class="var">k</span> <span class="class">labeled-cont</span>) <span class="var">tag</span> <span class="var">kk</span>)
  (<span class="special">if</span> (<span class="func">eqv?</span> <span class="var">tag</span> (<span class="func">labeled-cont-tag</span> <span class="var">k</span>))  <span class="comment">; внимание на компаратор</span>
      (<span class="func">evaluate</span> (<span class="func">throw-cont-form</span> <span class="var">kk</span>)
                (<span class="func">throw-cont-r</span> <span class="var">kk</span>)
                (<span class="func">make-throwing-cont</span> <span class="var">kk</span> <span class="var">tag</span> <span class="var">k</span>) )
      (<span class="func">catch-lookup</span> (<span class="func">labeled-cont-k</span> <span class="var">k</span>) <span class="var">tag</span> <span class="var">kk</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">throwing-cont</span>) <span class="var">v</span>)
  (<span class="func">resume</span> (<span class="func">throwing-cont-cont</span> <span class="var">k</span>) <span class="var">v</span>) )</pre>


<!--\indexR{переходы (escapes)!вложенные}-->
<p>Форма <code><span class="special">throw</span></code> вычисляет первый аргумент и пытается найти продолжение
с совпадающей меткой. Если в процессе поиска она добирается до начального
продолжения, то сигнализирует об ошибке. Если же нет, то вычисляется второй
аргумент <code><span class="special">throw</span></code> и его значение передаётся найденному продолжению. Но
передаётся оно по-хитрому: через <code><span class="class">throwing-cont</span></code>. Дело в том, что в процессе
вычисления этого значения тоже может возникнуть переход. Если бы продолжением
данного вычисления было продолжение, сохранённое в метке внешней формы
<code><span class="special">throw</span></code>, то вложенная форма <code><span class="special">throw</span></code> начинала бы поиски <code><span class="special">catch</span></code> так, как
будто бы переход на внешнюю метку уже произошёл. Но это не так, так что поиск
следует вести от текущей формы <code><span class="special">throw</span></code>, потому и создаётся специальное
промежуточное продолжение. В итоге, когда мы пишем:</p>

<pre>(<span class="special">catch</span> <span class="num">2</span>
  (<span class="func">*</span> <span class="num">7</span> (<span class="special">catch</span> <span class="num">1</span>
         (<span class="func">*</span> <span class="num">3</span> (<span class="special">catch</span> <span class="num">2</span>
                (<span class="special">throw</span> <span class="num">1</span> (<span class="special">throw</span> <span class="num">2</span> <span class="num">5</span>)) )) )) )</pre>

<p class="noindent">то получаем <code>(<span class="func">*</span> <span class="num">7</span> <span class="num">3</span> <span class="num">5</span>)</code>, а не <code><span class="num">5</span></code>.</p>

<p>Кроме того, реализация <code><span class="special">throw</span></code> как специальной формы позволяет отлавливать больше ошибок.</p>

<pre>(<span class="special">catch</span> <span class="num">2</span> (<span class="func">*</span> <span class="num">7</span> (<span class="special">throw</span> <span class="num">1</span> (<span class="special">throw</span> <span class="num">2</span> <span class="num">3</span>))))</pre>

<p class="noindent">Эта форма гарантированно вернёт не <code><span class="num">3</span></code>, а ошибку <code><span class="string">"No associated catch"</span></code>,
так как действительно нет <code><span class="special">catch</span></code> с меткой <code><span class="num">1</span></code> и не важно, что она
вроде бы как не используется.</p>


<h3 id="escape/implementation/ssect:block"><span class="wrap"><span class="seq">3.4.3.</span><span class="title">Реализация <code><span class="special">block</span></code></span></span></h3>

<!--\indexCS{block}{реализация}-->
<!--\indexCS{return-from}{реализация}-->
<p>Для реализации лексических меток переходов необходимо решить две проблемы.
Первая: гарантировать динамическое время жизни продолжений. Вторая: обеспечить
лексическую видимость меток. Для решения второй задачи мы, естественно,
воспользуемся лексическими окружениями, где лексическая область видимости есть
«из коробки». Над первой же придётся немного поработать самостоятельно. Чтобы
не было путаницы, у <code><span class="special">block</span></code> будет личный класс окружений для хранения
привязок меток к продолжениям.</p>

<p>Начинаем как обычно: добавляем распознавание формы <code><span class="special">block</span></code> в <code><span class="func">evaluate</span></code> и
описываем необходимые функции-обработчики.</p>

<!--\indexC{block-cont}-->
<!--\indexC{block-env}-->
<!--\indexC{evaluate-block}-->
<!--\indexCS{resume}{<code><span class="func">block-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">block-cont</span> <span class="class">continuation</span> (<span class="var">label</span>))
(<span class="syntax">define-class</span> <span class="class">block-env</span> <span class="class">full-env</span> (<span class="var">cont</span>))

(<span class="special">define</span> (<span class="func">evaluate-block</span> <span class="var">label</span> <span class="var">body</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="syntax">let</span> ((<span class="var">k</span> (<span class="func">make-block-cont</span> <span class="var">k</span> <span class="var">label</span>)))
    (<span class="func">evaluate-begin</span> <span class="var">body</span>
                    (<span class="func">make-block-env</span> <span class="var">r</span> <span class="var">label</span> <span class="var">k</span>)
                    <span class="var">k</span> ) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">block-cont</span>) <span class="var">v</span>)
  (<span class="func">resume</span> (<span class="func">block-cont-k</span> <span class="var">k</span>) <span class="var">v</span>) )</pre>

<p>С нормальным поведением закончили, переходим к
<code><span class="special">return-from</span></code>. Сначала
добавляем её в <code><span class="func">evaluate</span></code>:</p>

<pre>...
((<span class="var">block</span>)       (<span class="func">evaluate-block</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
((<span class="var">return-from</span>) (<span class="func">evaluate-return-from</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">r</span> <span class="var">k</span>))
...</pre>

<p class="noindent">Затем описываем обработку:</p>

<!--\indexC{return-from-cont}-->
<!--\indexC{evaluate-return-from}-->
<!--\indexCS{resume}{<code><span class="func">return-from-cont</span></code>}-->
<!--\indexC{block-lookup}-->
<!--\indexC{unwind}-->
<!--\indexCS{unwind}{<code><span class="func">continuation</span></code>}-->
<!--\indexCS{unwind}{<code><span class="func">bottom-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">return-from-cont</span> <span class="class">continuation</span> (<span class="var">r</span> <span class="var">label</span>))

(<span class="special">define</span> (<span class="func">evaluate-return-from</span> <span class="var">label</span> <span class="var">form</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">form</span> <span class="var">r</span> (<span class="func">make-return-from-cont</span> <span class="var">k</span> <span class="var">r</span> <span class="var">label</span>)) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">return-from-cont</span>) <span class="var">v</span>)
  (<span class="func">block-lookup</span> (<span class="func">return-from-cont-r</span> <span class="var">k</span>)
                (<span class="func">return-from-cont-label</span> <span class="var">k</span>)
                (<span class="func">return-from-cont-k</span> <span class="var">k</span>)
                <span class="var">v</span> ) )

(<span class="syntax">define-generic</span> (<span class="func">block-lookup</span> (<span class="var">r</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="func">wrong</span> <span class="string">"Not an environment"</span> <span class="var">r</span> <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>) )

(<span class="syntax">define-method</span> (<span class="func">block-lookup</span> (<span class="var">r</span> <span class="class">block-env</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">n</span> (<span class="func">block-env-name</span> <span class="var">r</span>))
      (<span class="func">unwind</span> <span class="var">k</span> <span class="var">v</span> (<span class="func">block-env-cont</span> <span class="var">r</span>))
      (<span class="func">block-lookup</span> (<span class="func">block-env-others</span> <span class="var">r</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">block-lookup</span> (<span class="var">r</span> <span class="class">full-env</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="func">block-lookup</span> (<span class="func">variable-env-others</span> <span class="var">r</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>) )

(<span class="syntax">define-method</span> (<span class="func">block-lookup</span> (<span class="var">r</span> <span class="class">null-env</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="func">wrong</span> <span class="string">"Unknown block label"</span> <span class="var">n</span> <span class="var">r</span> <span class="var">k</span> <span class="var">v</span>) )

(<span class="syntax">define-generic</span> (<span class="func">unwind</span> (<span class="var">k</span>) <span class="var">v</span> <span class="var">ktarget</span>))

(<span class="syntax">define-method</span> (<span class="func">unwind</span> (<span class="var">k</span> <span class="class">continuation</span>) <span class="var">v</span> <span class="var">ktarget</span>)
  (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">k</span> <span class="var">ktarget</span>)
      (<span class="func">resume</span> <span class="var">k</span> <span class="var">v</span>)
      (<span class="func">unwind</span> (<span class="func">continuation-k</span> <span class="var">k</span>) <span class="var">v</span> <span class="var">ktarget</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">unwind</span> (<span class="var">k</span> <span class="class">bottom-cont</span>) <span class="var">v</span> <span class="var">ktarget</span>)
  (<span class="func">wrong</span> <span class="string">"Obsolete continuation"</span> <span class="var">v</span>) )</pre>

<p>После вычисления необходимого значения функция <code><span class="func">block-lookup</span></code> отправляется
на поиски продолжения, связанного с меткой <code><span class="var">tag</span></code> в лексическом окружении
формы <code><span class="special">return-from</span></code>. Если такое продолжение существует, то дальше с помощью
<code><span class="func">unwind</span></code> она убеждается в том, что оно является частью текущего продолжения.</p>

<p>Поиск именованного блока, хранящего нужное продолжение, реализуется обобщённой
функцией <code><span class="func">block-lookup</span></code>. Она обучена пропускать ненужные окружения с обычными
переменными, останавливаясь только на экземплярах <code><span class="class">block-env</span></code>, хранящих
нужные нам <code><span class="class">block-cont</span></code>. Аналогично и <code><span class="func">lookup</span></code> пропускает экземпляры
<code><span class="class">block-env</span></code>, останавливаясь лишь на <code><span class="class">variable-env</span></code>. Именно с этой целью
данные классы наследуются от общего предка: <code><span class="class">full-env</span></code>. Это позволяет
безболезненно добавлять новые классы окружений, которые не будут мешать уже
существующим.</p>

<p>Наконец, обобщённая функция <code><span class="func">unwind</span></code> передаёт вычисленное значение найденному
продолжению, но только если оно ещё актуально — то есть доступно из текущего
продолжения.</p>


<h3 id="escape/implementation/ssect:unwind-protect"><span class="wrap"><span class="seq">3.4.4.</span><span class="title">Реализация <code><span class="special">unwind-protect</span></code></span></span></h3>

<!--\indexCS{unwind-protect}{реализация}-->
<p>Форма <code><span class="special">unwind-protect</span></code> является самой сложной для реализации; нам понадобится
изменить определения форм <code><span class="special">catch</span></code> и <code><span class="special">block</span></code>, чтобы они вели себя
правильно, когда находятся внутри <code><span class="special">unwind-protect</span></code>. Это хороший пример
возможности, чьё введение требует переработки всего, что уже написано до этого.
Но отсутствие <code><span class="special">unwind-protect</span></code> приводит к другим сложностям в будущем, так
что оно того стоит.</p>

<p>Начнём с определения поведения самой формы <code><span class="special">unwind-protect</span></code> (которая, как мы
уже говорили, мало чем отличается от <code><span class="special">prog1</span></code>):</p>

<!--\indexC{unwind-protect-cont}-->
<!--\indexC{protect-return-cont}-->
<!--\indexC{evaluate-unwind-protect}-->
<!--\indexCS{resume}{<code><span class="func">unwind-protect-cont</span></code>}-->
<!--\indexCS{resume}{<code><span class="func">protect-return-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">unwind-protect-cont</span> <span class="class">continuation</span> (<span class="var">cleanup</span> <span class="var">r</span>))
(<span class="syntax">define-class</span> <span class="class">protect-return-cont</span> <span class="class">continuation</span> (<span class="var">value</span>))

(<span class="special">define</span> (<span class="func">evaluate-unwind-protect</span> <span class="var">form</span> <span class="var">cleanup</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="func">evaluate</span> <span class="var">form</span> <span class="var">r</span>
            (<span class="func">make-unwind-protect-cont</span> <span class="var">k</span> <span class="var">cleanup</span> <span class="var">r</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">unwind-protect-cont</span>) <span class="var">v</span>)
  (<span class="func">evaluate-begin</span> (<span class="func">unwind-protect-cont-cleanup</span> <span class="var">k</span>)
                  (<span class="func">unwind-protect-cont-r</span> <span class="var">k</span>)
                  (<span class="func">make-protect-return-cont</span>
                   (<span class="func">unwind-protect-cont-k</span> <span class="var">k</span>) <span class="var">v</span> ) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">protect-return-cont</span>) <span class="var">v</span>)
  (<span class="func">resume</span> (<span class="func">protect-return-cont-k</span> <span class="var">k</span>) (<span class="func">protect-return-cont-value</span> <span class="var">k</span>)) )</pre>

<p>Далее необходимо доработать <code><span class="special">catch</span></code> и <code><span class="special">block</span></code>, чтобы они выполняли
действия, предписанные <code><span class="special">unwind-protect</span></code>, даже в случае выхода из них
с помощью <code><span class="special">throw</span></code> или <code><span class="special">return-from</span></code>. Для <code><span class="special">catch</span></code> необходимо изменить
обработку <code><span class="class">throwing-cont</span></code>:</p>


<!--\indexCS{resume}{<code><span class="func">throwing-cont</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">throwing-cont</span>) <span class="var">v</span>)
  (<span class="func">unwind</span> (<span class="func">throwing-cont-k</span> <span class="var">k</span>) <span class="var">v</span> (<span class="func">throwing-cont-cont</span> <span class="var">k</span>)) )</pre>

<p class="noindent">И научить <code><span class="func">unwind</span></code> выполнять сохранённые действия в процессе обхода стека:</p>

<!--\indexC{unwind-cont}-->
<!--\indexCS{unwind}{<code><span class="func">unwind-protect-cont</span></code>}-->
<!--\indexCS{resume}{<code><span class="func">unwind-cont</span></code>}-->
<pre>(<span class="syntax">define-class</span> <span class="class">unwind-cont</span> <span class="class">continuation</span> (<span class="var">value</span> <span class="var">target</span>))

(<span class="syntax">define-method</span> (<span class="func">unwind</span> (<span class="var">k</span> <span class="class">unwind-protect-cont</span>) <span class="var">v</span> <span class="var">target</span>)
  (<span class="func">evaluate-begin</span> (<span class="func">unwind-protect-cont-cleanup</span> <span class="var">k</span>)
                  (<span class="func">unwind-protect-cont-r</span> <span class="var">k</span>)
                  (<span class="func">make-unwind-cont</span>
                   (<span class="func">unwind-protect-cont-k</span> <span class="var">k</span>) <span class="var">v</span> <span class="var">target</span> ) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">unwind-cont</span>) <span class="var">v</span>)
  (<span class="func">unwind</span> (<span class="func">unwind-cont-k</span> <span class="var">k</span>)
          (<span class="func">unwind-cont-value</span> <span class="var">k</span>)
          (<span class="func">unwind-cont-target</span> <span class="var">k</span>) ) )</pre>

<!--\indexR{раскрутка стека (unwinding)}-->
<p>Теперь, чтобы передать значение при переходе, нам недостаточно просто его отдать
нужному продолжению. Нам необходимо подняться по стеку продолжений с помощью
<code><span class="func">unwind</span></code> (<em class="term">раскрутить</em> стек) от текущего до целевого продолжения,
выполняя по пути соответствующую уборку. Продолжения форм-уборщиков имеют тип
<code><span class="class">unwind-cont</span></code>. Их обработка с помощью <code><span class="func">resume</span></code> вызывает продолжение уборки
до достижения цели на случай вложенных форм <code><span class="special">unwind-protect</span></code>, а также
устанавливает правильное продолжение на случай переходов внутри самих
форм-уборщиков (тот самый процесс отбрасывания продолжений, который
рассматривался в разделе <a href="#escape/forms/protection/p:discard">3.1.6</a>.</p>

<p>Что касается <code><span class="special">block</span></code>, то тут даже делать ничего не надо. Как вы помните,
<code><span class="func">block-lookup</span></code> уже вызывает <code><span class="func">unwind</span></code> для раскрутки стека с целью проверки
актуальности перехода:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">block-lookup</span> (<span class="var">r</span> <span class="class">block-env</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>)
  (<span class="special">if</span> (<span class="func">eq?</span> <span class="var">n</span> (<span class="func">block-env-name</span> <span class="var">r</span>))
      (<span class="func">unwind</span> <span class="var">k</span> <span class="var">v</span> (<span class="func">block-env-cont</span> <span class="var">r</span>))
      (<span class="func">block-lookup</span> (<span class="func">block-env-others</span> <span class="var">r</span>) <span class="var">n</span> <span class="var">k</span> <span class="var">v</span>) ) )</pre>

<p class="noindent">Так что остаётся только сказать спасибо обобщённым функциям.</p>

<!--\indexCS{block}{и <code><span class="func">unwind-protect</span></code>}-->
<p>Может показаться, что с появлением <code><span class="special">unwind-protect</span></code> форма <code><span class="special">block</span></code>
перестала быть быстрее <code><span class="special">catch</span></code>, ведь они обе вынуждены пользоваться медленной
<code><span class="func">unwind</span></code>. В общем случае, конечно, да, но в частностях, коих большинство, это
не так: <code><span class="special">unwind-protect</span></code> является специальной формой, так что она не может
быть спутана с обычной функцией, её всегда надо использовать явно. А если
<code><span class="special">return-from</span></code> прямо видит метку соответствующего <code><span class="special">block</span></code> (то есть когда
между ними нет <code><span class="special">lambda</span></code>- или <code><span class="special">unwind-protect</span></code>-форм), то <code><span class="func">unwind</span></code> будет
работать так же быстро, как и раньше.</p>

<div class="bigskip"/>

<!--\indexCS{unwind-protect}{ограничения \CommonLisp}-->
<p>В <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> (CLtL2 <span class="cite">[<a href="z1_bibliography.xhtml#ste90">Ste90</a>]</span>) присутствует ещё одно интересное
ограничение, касающееся переходов из форм-уборщиков. Эти переходы не могут вести
внутрь той формы, из которой в теле <code><span class="special">unwind-protect</span></code> был вызван выход.
Введено такое ограничение с целью недопущения бесконечных циклов из переходов,
любые попытки выбраться из которых пресекаются <code><span class="special">unwind-protect</span></code>.
<span class="see">[см. упр. <a href="#escape/ex:eternal">3.9</a>]</span>
Следовательно, следующая программа выдаст ошибку, так
как форма-уборщик хочет прыгнуть ближе, чем прыжок на <code><span class="num">1</span></code>, который уже
в процессе.</p>

<pre>(<span class="special">catch</span> <span class="num">1</span>                  <span class="dialect"><span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span></span>
  (<span class="special">catch</span> <span class="num">2</span>
    (<span class="special">unwind-protect</span> (<span class="special">throw</span> <span class="num">1</span> '<span class="var">foo</span>)
      (<span class="special">throw</span> <span class="num">2</span> '<span class="var">bar</span>) ) ) )         <span class="math"><span class="rel">→</span></span> <i>ошибка!</i></pre>


<h2 id="escape/sect:comparing"><span class="wrap"><span class="seq">3.5.</span><span class="title">Сравнение <code><span class="func">call/cc</span></code> и <code><span class="special">catch</span></code></span></span></h2>

<p>Благодаря объектам, продолжения можно представлять связным списком блоков.
Некоторые из этих блоков доступны прямо в лексическом окружении; до других
необходимо пробираться, проходя через несколько промежуточных продолжений;
третьи вызывают выполнение определённых действий, когда через них проходят.</p>

<!--\indexR{продолжения (continuations)!время жизни!динамическое}-->
<p>В языках вроде Лиспа, где есть продолжения с динамическим временем жизни, стек
вызовов и продолжения являются синонимами. Когда мы пишем <code>(<span class="func">evaluate</span> <span class="var">ec</span> <span class="var">r</span>
(<span class="func">make-if-cont</span> <span class="var">k</span> <span class="var">et</span> <span class="var">ef</span> <span class="var">r</span>))</code>, мы явно кладём в стек блок кода, который будет
обрабатывать значение, которое вернёт условие <code><span class="special">if</span></code>-формы. И наоборот, когда
мы пишем <code>(<span class="func">evaluate-begin</span> (<span class="func">cdr</span> (<span class="func">begin-cont-e*</span> <span class="var">k</span>)) (<span class="func">begin-cont-r</span> <span class="var">k</span>)
(<span class="func">begin-cont-k</span> <span class="var">k</span>))</code>, то это значит, что текущий блок <code><span class="var">k</span></code> надо выбросить и
поставить на его место <code>(<span class="func">begin-cont-k</span> <span class="var">k</span>)</code>. Можно легко убедиться в том, что
такие блоки действительно выбрасываются, в стеке не остаются недовыполненные
куски продолжений. Таким образом, когда мы выходим из блока, все продолжения,
указывающие на него и, возможно, сохранённые в других блоках, становятся
недействительными. Обычно продолжения неявно хранятся в стеке или даже
в нескольких стеках, согласованных между собой, а переходы между ними
компилируются в примитивы языка Си: <code>setjmp</code>/<code>longjmp</code>.
<span class="see">[см. раздел <a href="ch10_compiling_into_c.xhtml#cc/sect:call/cc">10.11</a>]</span></p>

<!--\indexC{let/cc}-->
<p>В диалекте <span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span> <span class="cite">[<a href="z1_bibliography.xhtml#pe92">PE92</a>]</span> есть специальная форма <code><span class="special">let/cc</span></code> со следующим
синтаксисом:</p>

<pre>(<span class="special">let/cc</span> <i>переменная</i> <i>формы</i>...)  <span class="dialect"><span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span></span></pre>

<!--\indexC{bind-exit}-->
<p id="escape/comparing/par:bind-exit">В диалекте Dylan <span class="cite">[<a href="z1_bibliography.xhtml#app92b">App92b</a>]</span> тоже есть подобная форма:</p>

<pre>(<span class="special">bind-exit</span> (<i>переменная</i>) <i>формы</i>...)  <span class="dialect">Dylan</span></pre>

<p class="noindent">Эта форма связывает текущее продолжение с <i>переменной</i>, имеющей область
видимости, ограниченную телом <code><span class="special">let/cc</span></code> или <code><span class="special">bind-exit</span></code>. В этом случае
продолжение несомненно является полноценным объектом, имеющим интерфейс унарной
функции. Но его <em>полезное</em> время жизни динамическое, его можно использовать
лишь во время вычисления тела формы <code><span class="special">let/cc</span></code> или <code><span class="special">bind-exit</span></code>. Точнее, само
продолжение, хранящееся в <i>переменной</i>, имеет неограниченное время жизни, но
становится бесполезным при выходе из связывающей формы. Это характерная для
<span class="sc">E<span class="c">u</span>L<span class="c">isp</span></span> и Dylan черта, но её нет как в Scheme (где продолжения истинно
неограниченны), так и в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> (где они вообще объекты второго класса).
Тем не менее, такое поведение можно проэмулировать в Scheme:</p>

<pre>(<span class="special">define-syntax</span> <span class="var">let/cc</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">let/cc</span> <span class="var">variable</span> . <span class="var">body</span>)
     (<span class="special">block</span> <span class="var">variable</span>
       (<span class="syntax">let</span> ((<span class="var">variable</span> (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">return-from</span> <span class="var">variable</span> <span class="var">x</span>))))
         . <span class="var">body</span> ) ) ) ) )</pre>

<!--\indexR{продолжения (continuations)!варианты представления}-->
<p>В мире Scheme продолжения больше нельзя считать неявной частью стека, так как
они могут храниться во внешних структурах данных. Поэтому приходится применять
другую модель: древовидную, которую иногда называют <em class="term">стек-кактус</em> или
<em class="term">спагетти-стек</em>. Наиболее простой способ её реализовать: вообще
не пользоваться аппаратным стеком, размещая все фреймы в куче.</p>

<p>Такой подход унифицирует выделение памяти под структуры данных и, по
мнению <span class="cite">[<a href="z1_bibliography.xhtml#as94">AS94</a>]</span>, облегчает портирование. Тем не менее, он приводит
к фрагментации, что вынуждает явно хранить ссылки между продолжениями. (Хотя
в <span class="cite">[<a href="z1_bibliography.xhtml#mb93">MB93</a>]</span> приведено несколько вариантов решения этих проблем.) Как правило,
ради эффективности в аппаратный стек стараются поместить максимум данных о ходе
исполнения программы, так что каноническая реализация <code><span class="func">call/cc</span></code> делает снимки
стека и сохраняет в куче именно их; таким образом, продолжения — это как раз
такие снимки стека. Конечно, существуют и другие варианты реализации,
рассмотренные, например, в <span class="cite">[<a href="z1_bibliography.xhtml#cho88">CHO88</a>, <a href="z1_bibliography.xhtml#hdb90">HDB90</a>]</span>, где используются разделяемые
копии, отложенное копирование, частичное копирование и т. д. Естественно,
каждый из этих вариантов даёт свои преимущества, но за определённую плату.</p>

<p>Форма <code><span class="func">call/cc</span></code> больше похожа на <code><span class="special">block</span></code>, нежели на <code><span class="special">catch</span></code>. Оба типа
продолжений имеют лексическую область видимости, они различаются только временем
жизни. В некоторых диалектах, вроде <span class="cite">[<a href="z1_bibliography.xhtml#im89">IM89</a>]</span>, есть урезанный вариант
<code><span class="func">call/cc</span></code>. Называется он <code><span class="func">call/ep</span></code> (от <em class="term">call with exit procedure</em>);
эта <em>процедура выхода</em> хорошо видна в <code><span class="special">block</span></code>/<code><span class="special">return-from</span></code>, равно
как и в <code><span class="special">let/cc</span></code>. Интерфейс у <code><span class="func">call/ep</span></code> такой же, как и у <code><span class="func">call/cc</span></code>:</p>

<!--\indexC{call/ep}-->
<pre>(<span class="func">call/ep</span> (<span class="special">lambda</span> (<span class="var">exit</span>) ...))</pre>

<!--\indexR{объекты!второго класса}-->
<p>Переменная <code><span class="var">exit</span></code> унарной функции-аргумента связывается с продолжением формы
<code><span class="func">call/ep</span></code> на время вычисления тела этой функции. Схожесть с <code><span class="special">block</span></code>
налицо, разве что мы используем обычное окружение переменных, а не отдельное
окружение лексических меток. Основное их отличие в том, что <code><span class="func">call/ep</span></code> делает
продолжение полноценным объектом, который можно использовать так же, как любой
другой объект вроде чисел, замыканий или списков. Имея <code><span class="special">block</span></code>, мы тоже можем
создать функционально аналогичный объект, написав <code>(<span class="special">lambda</span> (<span class="var">x</span>) (<span class="special">return-from</span> <i>метка</i> <span class="var">x</span>))</code>. Но все возможные места выхода из <code><span class="special">block</span></code> известны статически
(это соответствующие формы <code><span class="special">return-from</span></code>), тогда как в <code><span class="func">call/ep</span></code> совсем
по-другому: например, по выражению <code>(<span class="func">call/ep</span> <span class="var">foo</span>)</code> нельзя понять, может ли
произойти переход или нет. Единственный способ это узнать — проанализировать
<code><span class="var">foo</span></code>, но эта функция может быть определена в совершенно другом месте, а то и
вовсе генерироваться динамически. Следовательно, функция <code><span class="func">call/ep</span></code> более
сложна для компилятора, чем специальная форма <code><span class="special">block</span></code>, но вместе с тем имеет
и больше возможностей.</p>

<p>Продолжая сравнивать <code><span class="func">call/ep</span></code> и <code><span class="special">block</span></code>, мы замечаем больше отличий.
Например, для формы <code><span class="func">call/ep</span></code>, в которой аргумент записан в виде явной
<code><span class="special">lambda</span></code>-формы, можно не создавать замыкание. Следовательно, эффективный
компилятор должен отделять случай <code>(<span class="func">call/ep</span> (<span class="special">lambda</span> <span class="var">...</span>))</code> от остальных. Это
похоже на специальные формы, так как они тоже трактуются по-особенному. В Scheme
принято использовать функции как основной инструмент построения абстракций,
тогда как специальные формы являются чем-то вроде подсказок компилятору. Они
часто одинаково мощны, вопрос лишь в балансе сложности — кому важнее
облегчить жизнь: пользователю или, наоборот, разработчику языка.</p>

<div class="bigskip"/>

<p>Подводя итог, если вам нужна мощь за адекватную цену, то <code><span class="func">call/cc</span></code> к вашим
услугам, так как она позволяет реализовать все мыслимые управляющие конструкции:
переходы, сопрограммы, частичные продолжения и так далее. Если же вам нужны
только «нормальные» вещи (а Лисп уже не раз показывал, что можно писать
удивительные программы и без <code><span class="func">call/cc</span></code>), то используйте управляющие формы
<span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>, простые и компилирующиеся в эффективный машинный код.</p>


<h2 id="escape/sect:pr-cont"><span class="wrap"><span class="seq">3.6.</span><span class="title">Продолжения в программировании</span></span></h2>

<!--\indexE{CPS}-->
<!--\indexR{стиль передачи продолжений (CPS)}-->
<!--\indexR{продолжения (continuations)|seealso{стиль передачи продолжений (CPS)}}-->
<p>Существует стиль программирования, называемый «<em class="term">стилем передачи
продолжений</em>» (continuation passing style, CPS). В нём во главу угла
ставится явное указание не только того, что возвращать в качестве результата
функции, но и кому. После завершения вычислений функция не возвращает результат
абстрактному получателю куда-то «наверх», а применяет конкретного получателя,
представленного продолжением, к результату. В общем, если у нас есть вычисление
<code>(<span class="func">foo</span> (<span class="func">bar</span>))</code>, то оно выворачивается наизнанку, преобразуясь в следующий вид:
<code>(<span class="func">new-bar</span> <span class="var">foo</span>)</code>, где <code><span class="func">foo</span></code> и является продолжением, которому
<code><span class="func">new-bar</span></code> передаст результат вычислений. Давайте рассмотрим
данное преобразование на примере многострадального факториала. Пусть мы хотим вычислить
<span class="math"><span class="ord var">n</span><span class="open">(</span><span class="ord var">n</span><span class="ord">!</span><span class="close">)</span></span>:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">k</span> <span class="num">1</span>)
      (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) (<span class="special">lambda</span> (<span class="func">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>)))) ) )

(<span class="func">fact</span> <span class="var">n</span> (<span class="special">lambda</span> (<span class="func">r</span>) (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>))) <span class="math"><span class="rel">→</span></span> <span class="math"><span class="ord var">n</span><span class="open">(</span><span class="ord var">n</span><span class="ord">!</span><span class="close">)</span></span></pre>

<p>Факториал теперь принимает дополнительный аргумент <code><span class="var">k</span></code>: получателя
вычисленного факториала. Если результат равен единице, то к ней просто
применяется <code><span class="var">k</span></code>. Если же результат сразу сказать нельзя, то следует ожидаемый
рекурсивный вызов. Проблема состоит в том, что хорошо было бы сначала умножить
факториал <span class="math"><span class="open">(</span><code class="ord"><span class="var">n</span></code><span class="binop">−</span><span class="ord num">1</span><span class="close">)</span></span> на <code><span class="var">n</span></code> и только потом уже передавать произведение
получателю, а форма <code>(<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) <span class="var">k</span>)))</code> делает всё наоборот! Поэтому
и мы всё сделаем шиворот-навыворот: пусть получатель сам умножает результат
на <code><span class="var">n</span></code>. Настоящий получатель оборачивается в функцию:
<code>(<span class="special">lambda</span> (<span class="func">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>)))</code>, и передаётся следующему рекурсивному вызову.</p>

<p>Такое определение факториала даёт возможность вычислять различные величины
с помощью одного и того же определения. Например, обычный факториал: <code>(<span class="func">fact</span> <i>n</i> (<span class="special">lambda</span> (<span class="var">x</span>) <span class="var">x</span>))</code>, или удвоенный: <code>(<span class="func">fact</span> <i>n</i> (<span class="special">lambda</span> (<span class="var">x</span>) (<span class="func">*</span> <span class="num">2</span> <span class="var">x</span>)))</code>,
или что-то более сложное.</p>


<h3 id="escape/pr-cont/ssect:multiple"><span class="wrap"><span class="seq">3.6.1.</span><span class="title">Составные значения</span></span></h3>

<!--\indexR{возвращаемые значения!множественные}-->
<!--\indexR{множественные значения}-->
<p>Продолжения очень удобно использовать для обработки составных величин.
Существуют вычисления, результатом которых является не одна величина, а
несколько. Например, в <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> целочисленное деление (<code><span class="func">truncate</span></code>)
одновременно возвращает частное и остаток. Пусть у нас тоже есть подобная
функция — назовём её <code><span class="func">divide</span></code>, — которая принимает два числа и
продолжение, вычисляет частное и остаток от деления, а затем применяет
переданное продолжение к этим величинам. Например, вот так можно проверить
правильность выполнения деления этой функцией:</p>

<pre>(<span class="func">let*</span> ((<span class="var">p</span> (<span class="func">read</span>)) (<span class="var">q</span> (<span class="func">read</span>)))
  (<span class="func">divide</span> <span class="var">p</span> <span class="var">q</span> (<span class="special">lambda</span> (<span class="var">quotient</span> <span class="var">remainder</span>)
                (<span class="func">=</span> <span class="var">p</span> (<span class="func">+</span> (<span class="func">*</span> <span class="var">quotient</span> <span class="var">q</span>) <span class="var">remainder</span>)) )) )</pre>

<p>Менее тривиальный пример — вычисление коэффициентов Безу.<a class="footref" href="zz_footnotes.xhtml#foot3.14"><sup>14</sup></a> Соотношение Безу утверждает, что для любых целых чисел
<span class="math"><span class="ord var">n</span></span>
и <span class="math"><span class="ord var">p</span></span>
можно найти такую пару целых <span class="math"><span class="ord var">u</span></span> и
<span class="math"><span class="ord var">v</span></span>, что
<span class="math"><span class="ord var">u</span><span class="ord var">n</span><span class="binop">+</span><span class="ord var">v</span><span class="ord var">p</span><span class="rel">=</span><span class="ord func">НОД</span><span class="open">(</span><span class="ord var">n</span><span class="punct">,</span><span class="ord var">p</span><span class="close">)</span></span>.
Для вычисления коэффициентов <span class="math"><span class="ord var">u</span></span> и
<span class="math"><span class="ord var">v</span></span> можно использовать расширенный алгоритм
Евклида.</p>

<!--\indexC{bezout}-->
<pre>(<span class="special">define</span> (<span class="func">bezout</span> <span class="var">n</span> <span class="var">p</span> <span class="var">k</span>)  <span class="comment">; пусть <span class="math"><span class="ord var">n</span><span class="rel">&gt;</span><span class="ord var">p</span></span></span>
  (<span class="func">divide</span>
   <span class="var">n</span> <span class="var">p</span> (<span class="special">lambda</span> (<span class="var">q</span> <span class="var">r</span>)
         (<span class="special">if</span> (<span class="func">=</span> <span class="var">r</span> <span class="num">0</span>)
             (<span class="func">k</span> <span class="num">0</span> <span class="num">1</span>)    <span class="comment">; т. к. <span class="math"><span class="ord num">0</span><span class="binop">⋅</span><span class="ord var">q</span><span class="ord var">p</span><span class="binop">+</span><span class="ord num">1</span><span class="binop">⋅</span><span class="ord var">p</span><span class="rel">=</span><span class="ord var">p</span></span></span>
             (<span class="func">bezout</span>
              <span class="var">p</span> <span class="var">r</span> (<span class="special">lambda</span> (<span class="var">u</span> <span class="var">v</span>)
                    (<span class="func">k</span> <span class="var">v</span> (<span class="func">-</span> <span class="var">u</span> (<span class="func">*</span> <span class="var">v</span> <span class="var">q</span>))) ) ) ) ) ) )</pre>

<p>Функция <code><span class="func">bezout</span></code> использует <code><span class="func">divide</span></code>, чтобы сохранить в <code><span class="var">q</span></code> и <code><span class="var">r</span></code>
частное и остаток от деления <code><span class="var">n</span></code> на <code><span class="var">p</span></code>. Если <span class="math"><span class="ord var">n</span></span> делится нацело на <span class="math"><span class="ord var">p</span></span>,
то очевидно, что их наибольший общий делитель равен <span class="math"><span class="ord var">p</span></span> и есть тривиальное
решение: <span class="math"><span class="ord num">0</span></span> и <span class="math"><span class="ord num">1</span></span>. Если остаток не равен нулю, то… попробуйте доказать
правильность этого алгоритма самостоятельно; для этого не надо быть экспертом
в теории чисел, достаточно знать свойства НОД. А здесь мы ограничимся простой
проверкой:</p>

<pre>(<span class="func">bezout</span> <span class="num">1991</span> <span class="num">1960</span> <span class="var">list</span>) <span class="math"><span class="rel">→</span></span> (<span class="num">-569</span> <span class="num">578</span>)</pre>


<h3 id="escape/pr-cont/ssect:tail-recusion"><span class="wrap"><span class="seq">3.6.2.</span><span class="title">Хвостовая рекурсия</span></span></h3>

<p>В примере с вычислением факториала с помощью продолжений вызов <code><span class="func">fact</span></code> в конце
концов приводил к ещё одному вызову <code><span class="func">fact</span></code>. Если мы проследим за вычислением
<code>(<span class="func">fact</span> <span class="num">3</span> <span class="var">list</span>)</code>, то, отбрасывая очевидные шаги, получим следующую картину:</p>

<pre>(<span class="func">fact</span> <span class="num">3</span> <span class="var">list</span>)
<span class="math"><span class="rel">≡</span></span> (<span class="func">fact</span> <span class="num">2</span> (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>))))<div class="where"><div class="wrap">
<span class="var">n</span> <span class="math"><span class="rel">→</span></span> <span class="num">3</span>
<span class="var">k</span> <span class="math"><span class="rel">≡</span></span> <span class="var">list</span></div></div>
<span class="math"><span class="rel">≡</span></span> (<span class="func">fact</span> <span class="num">1</span> (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>))))<div class="where"><div class="wrap">
<span class="var">n</span> <span class="math"><span class="rel">→</span></span> <span class="num">2</span>
<span class="var">k</span> <span class="math"><span class="rel">→</span></span> (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>)))</div><div class="where">

<div class="wrap">
<span class="var">n</span> <span class="math"><span class="rel">→</span></span> <span class="num">3</span>
<span class="var">k</span><span class="math"> <span class="rel">≡</span></span> <span class="var">list</span></div></div></div>
<span class="math"><span class="rel">≡</span></span> (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="num">1</span>))<div class="where"><div class="wrap">
<span class="var">n</span> <span class="math"><span class="rel">→</span></span> <span class="num">2</span>
<span class="var">k</span> <span class="math"><span class="rel">→</span></span> (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>)))</div><div class="where">

<div class="wrap">
<span class="var">n</span> <span class="math"><span class="rel">→</span></span> <span class="num">3</span>
<span class="var">k</span> <span class="math"><span class="rel">≡</span></span> <span class="var">list</span></div></div></div>
<span class="math"><span class="rel">≡</span></span> (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="num">2</span>))<div class="where"><div class="wrap">
<span class="var">n</span> <span class="math"><span class="rel">→</span></span> <span class="num">3</span>
<span class="var">k</span> <span class="math"><span class="rel">≡</span></span> <span class="var">list</span></div></div>
<span class="math"><span class="rel">→</span></span> (<span class="func">6</span>)</pre>

<!--\indexR{рекурсия!хвостовая}-->
<!--\indexR{хвостовые вызовы!рекурсивные}-->
<!--\indexR{вызов!хвостовой}-->
<p>Когда <code><span class="func">fact</span></code> вызывает <code><span class="func">fact</span></code>, вторая функция вычисляется с тем же
продолжением, что и первая. Такое явление называется <em class="term">хвостовой рекурсией</em>
— почему рекурсия, понятно, а хвостовая, потому что этот вызов выполняется
в «хвосте» вычислений: сразу же после него следует выход из функции. Хвостовая
рекурсия — это частный случай хвостового вызова. Хвостовой вызов происходит
тогда, когда текущее вычисление может быть полностью заменено вызываемым.
То есть вызов происходит из <em class="term">хвостовой позиции</em>, если он выполняется
с <em>неизменным продолжением</em>.</p>

<p>В примере с вычислением коэффициентов Безу функция <code><span class="func">bezout</span></code> вызывает
<code><span class="func">divide</span></code> из хвостовой позиции. Функция <code><span class="func">divide</span></code> вызывает своё продолжение
из хвостовой позиции. Это продолжение рекурсивно вызывает <code><span class="func">bezout</span></code> опять-таки
из хвостовой позиции.</p>

<p>Но в классическом факториале <code>(<span class="func">*</span> <span class="var">n</span> (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>)))</code> рекурсивный вызов
<code><span class="func">fact</span></code> происходит не из хвостовой позиции. Он <em>завёрнут</em> в продолжение,
так как значение <code>(<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>))</code> ещё ожидается для умножения на <code><span class="var">n</span></code>;
вызов тут не является последней необходимой операцией, всё вычисление нельзя
свести к нему.</p>

<p>Хвостовые вызовы позволяют отбрасывать ненужные окружения и фреймы стека, так
как при таких вызовах они больше никогда не будут использоваться. Следовательно,
их можно не сохранять, экономя таким образом драгоценную стековую память.
Подобные оптимизации были детально изучены французским лисп-сообществом, что
позволило существенно ускорить интерпретацию <span class="cite">[<a href="z1_bibliography.xhtml#gre77">Gre77</a> <a href="z1_bibliography.xhtml#cha80">Cha80</a> <a href="z1_bibliography.xhtml#sj87">SJ87</a>]</span>;
см. также <span class="cite">[<a href="z1_bibliography.xhtml#han90">Han90</a>]</span>.</p>

<div class="bigskip"/>

<!--\indexCS{evaluate-begin}{хвостовая рекурсия}-->
<p>Оптимизация хвостовой рекурсии — это очень желанное свойство интерпретатора;
не только для пользователя, но и для самого интерпретатора. Самое очевидное
место, где она была бы полезной, — это форма <code><span class="special">begin</span></code>. До сих пор она
определялась следующим образом:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate-begin</span> <span class="var">e*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e*</span>))
          (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> (<span class="func">make-begin-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>))
          (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> <span class="var">k</span>) )
      (<span class="func">resume</span> <span class="var">k</span> <span class="var">empty-begin-value</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">begin-cont</span>) <span class="var">v</span>)
  (<span class="func">evaluate-begin</span> (<span class="func">cdr</span> (<span class="func">begin-cont-e*</span> <span class="var">k</span>))
                  (<span class="func">begin-cont-r</span> <span class="var">k</span>)
                  (<span class="func">begin-cont-k</span> <span class="var">k</span>) ) )</pre>

<p>Заметьте, здесь каждый вызов является хвостовым. Также здесь используется одна
небольшая оптимизация. Можно определить эту форму проще:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate-begin</span> <span class="var">e*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
      (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> (<span class="func">make-begin-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>))
      (<span class="func">resume</span> <span class="var">k</span> <span class="var">empty-begin-value</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">begin-cont</span>) <span class="var">v</span>)
  (<span class="syntax">let</span> ((<span class="var">e*</span> (<span class="func">cdr</span> (<span class="func">begin-cond-e*</span> <span class="var">k</span>))))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
        (<span class="func">evaluate-begin</span> <span class="var">e*</span> (<span class="func">begin-cont-r</span> <span class="var">k</span>) (<span class="func">begin-cont-k</span> <span class="var">k</span>))
        (<span class="func">resume</span> (<span class="func">begin-cont-k</span> <span class="var">k</span>) <span class="var">v</span>) ) ) )</pre>

<p>Но первый вариант предпочтительнее, так как в этом случае при вычислении
последнего оставшегося выражения мы не тратим время на создание лишнего
продолжения <code>(<span class="func">make-begin-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>)</code>, которое фактически равно <code><span class="var">k</span></code>, а
сразу же переходим в нужное продолжение. Конечно, в Лиспе есть сборка мусора, но
это не означает, что можно мусорить ненужными объектами на каждом шагу. Это
небольшая, но важная оптимизация, ведь каждый <code><span class="special">begin</span></code>
когда-нибудь заканчивается!</p>

<!--\indexCS{evaluate-arguments}{хвостовая рекурсия}-->
<p>Аналогично можно оптимизировать и вычисление аргументов функции, переписав его
следующим образом:</p>

<pre>(<span class="syntax">define-class</span> <span class="class">no-more-argument-cont</span> <span class="class">continuation</span> ())

(<span class="special">define</span> (<span class="func">evaluate-arguments</span> <span class="var">e*</span> <span class="var">r</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">e*</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">e*</span>))
          (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> (<span class="func">make-argument-cont</span> <span class="var">k</span> <span class="var">e*</span> <span class="var">r</span>))
          (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e*</span>) <span class="var">r</span> (<span class="func">make-no-more-argument-cont</span> <span class="var">k</span>)) )
      (<span class="func">resume</span> <span class="var">k</span> <span class="var">no-more-arguments</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">resume</span> (<span class="var">k</span> <span class="class">make-no-more-argument-cont</span>) <span class="var">v</span>)
  (<span class="func">resume</span> (<span class="func">no-more-argument-cont-k</span> <span class="var">k</span>) (<span class="func">list</span> <span class="var">v</span>)) )</pre>

<p>Это новое продолжение, хранящее список из последнего вычисленного значения,
избавляет нас от необходимости передавать окружение <code><span class="var">r</span></code> целиком. Данный приём
впервые использован Митчеллом Уондом и Дэниелом Фридманом в <span class="cite">[<a href="z1_bibliography.xhtml#wan80b">Wan80b</a>]</span>.</p>


<h2 id="escape/sect:partial"><span class="wrap"><span class="seq">3.7.</span><span class="title">Частичные продолжения</span></span></h2>

<!--\indexR{продолжения (continuations)!частичные продолжения}-->
<p>Среди прочих вопросов, поднимаемых продолжениями, есть ещё один довольно
интересный: что именно случается с отбрасываемым при переходе кодом? Другими
словами, с тем куском продолжения (или стека), который находится между
положениями до прыжка и после. Мы говорили, что такой <em class="term">срез</em> стека
не сохраняется при переходе. Но он вовсе не является бесполезным: ведь если бы
через него не перешагнули, то он бы принял какое-то значение, выполнил
определённые действия и передал бы полученное значение своему продолжению.
То есть вёл бы себя как обычная функция. Во многих работах, вроде
<span class="cite">[<a href="z1_bibliography.xhtml#ffdm87">FFDM87</a>,
<a href="z1_bibliography.xhtml#ff87">FF87</a>,
<a href="z1_bibliography.xhtml#fel88">Fel88</a>,
<a href="z1_bibliography.xhtml#df90">DF90</a>,
<a href="z1_bibliography.xhtml#hd90">HD90</a>,
<a href="z1_bibliography.xhtml#qs91">QS91</a>,
<a href="z1_bibliography.xhtml#mq94">MQ94</a>]</span>, приводятся способы сохранения и
приёмы использования этих срезов — <em class="term">частичных продолжений</em>
(partial/delimited continuations).</p>

<p>Рассмотрим следующий простой пример:</p>

<pre>(<span class="func">+</span> <span class="num">1</span> (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="special">set!</span> <span class="var">foo</span> <span class="var">k</span>) <span class="num">2</span>))) <span class="math"><span class="rel">→</span></span> <span class="num">3</span>
(<span class="func">foo</span> <span class="num">3</span>)                                     <span class="math"><span class="rel">→</span></span> <span class="num">4</span></pre>

<p class="noindent">Какое именно продолжение хранится в <code><span class="var">foo</span></code>?
Казалось бы <span class="math"><span class="ord var">λ</span><span class="ord var">u</span><span class="ord">.</span><span class="ord num">1</span><span class="binop">+</span><span class="ord var">u</span></span>,
но чему тогда равно <code>(<span class="func">foo</span> (<span class="func">foo</span> <span class="num">4</span>))</code>?</p>

<pre>(<span class="func">foo</span> (<span class="func">foo</span> <span class="num">4</span>))                               <span class="math"><span class="rel">→</span></span> <span class="num">5</span></pre>

<!--\indexR{композициональность!продолжений}-->
<!--\indexR{продолжения (continuations)!композициональность}-->
<p>Получается <code><span class="num">5</span></code>, а не ожидаемое значение <code><span class="num">6</span></code>, которое бы получилось при
правильной композиции функций. Дело в том, что вызов продолжения означает
отбрасывание всех последующих вычислений ради продолжения других вычислений.
Таким образом, вызов продолжения внутри <code><span class="func">foo</span></code> приводит к вычислению значения
<span class="math"><span class="ord var">λ</span><span class="ord var">u</span><span class="ord">.</span><span class="ord num">1</span><span class="binop">+</span><span class="ord var">u</span></span>
при <span class="math"><span class="ord var">u</span><span class="rel">=</span><span class="num ord">4</span></span>, которое становится значением всего выражения, и
второй вызов <code><span class="func">foo</span></code> вообще не происходит — он не нужен, ведь значение
выражения уже вычислено и передано продолжению! Именно в этом проблема: мы
захватили обычное продолжение, а не частичное. Обычные продолжения
<em class="term">активируются</em> и полностью заменяют стек собой, а <em>не вызываются</em>
как функции.</p>

<p>Возможно, так будет понятнее. В <code><span class="var">foo</span></code> мы сохранили <code>(<span class="func">+</span> <span class="num">1</span> <span class="hash">[]</span>)</code>. Это всё,
что ещё осталось вычислить. Так как аргументы передаются по значению, то
вычисление аргумента-продолжения в <code>(<span class="func">foo</span> (<span class="func">foo</span> <span class="num">4</span>))</code> фактически завершает
вычисления, отбрасывает <code>(<span class="func">foo</span> <span class="hash">[]</span>)</code> и возвращает значение формы <code>(<span class="func">+</span> <span class="num">1</span> <span class="num">4</span>)</code>,
которое, очевидно, равно <code><span class="num">5</span></code>.</p>

<!--\indexR{продолжения (continuations)!и интерактивная сессия}-->
<!--\indexR{интерактивная сессия (REPL)!продолжения}-->
<!--\indexE{REPL!продолжения}-->
<p>Частичные продолжения представляют собой лишь часть оставшихся вычислений, тогда
как обычные продолжения — это <em>все</em> оставшиеся вычисления.
В статьях <span class="cite">[<a href="z1_bibliography.xhtml#fwfd88">FWFD88</a>,
<a href="z1_bibliography.xhtml#df90">DF90</a>, <a href="z1_bibliography.xhtml#hd90">HD90</a>,
<a href="z1_bibliography.xhtml#qs91">QS91</a>]</span> приводятся способы захвата частичных и,
следовательно, поддающихся композиции продолжений. Предположим, теперь
с <code><span class="var">foo</span></code> связано продолжение <code><span class="hash">[</span>(<span class="func">+</span> <span class="num">1</span> <span class="hash">[]</span>)<span class="hash">]</span></code>, где внешние квадратные скобки
означают, что оно ведёт себя как функция. Тогда <code>(<span class="func">foo</span> (<span class="func">foo</span> <span class="num">4</span>))</code> будет
эквивалентно уже <code>(<span class="func">foo</span> <span class="hash">[</span>(<span class="func">+</span> <span class="num">1</span> <span class="hash">[</span><span class="num">4</span><span class="hash">]</span>)<span class="hash">]</span>)</code>, что превращается в <code>(<span class="func">+</span> <span class="num">1</span> <span class="num">5</span>)</code>,
которое в итоге даёт <code><span class="num">6</span></code>. Захваченное продолжение <code><span class="hash">[</span>(<span class="func">+</span> <span class="num">1</span> <span class="hash">[]</span>)<span class="hash">]</span></code> определяет
не все последующие вычисления, которые когда-либо произойдут, а только их часть
вплоть до момента возврата значения. Для интерактивной сессии продолжением
обычных продолжений является <em class="term">главный цикл</em>
(он же <code><span class="func">toplevel</span></code>), именно
ему продолжения передают своё значение, а он выводит его на экран, читает
следующее выражение из входного потока, вычисляет его и так далее. Продолжение
частичных продолжений неизвестно, именно поэтому они конечны и ведут себя как
обычные функции — ведь функции тоже не знают, кому они вернут значение.</p>

<p>Давайте взглянем на наш пример с <code>(<span class="special">set!</span> <span class="var">foo</span> <span class="var">k</span>)</code> с другой стороны. Оставим всё
по-прежнему, но объединим эти два выражения в явную последовательность:</p>

<pre>(<span class="special">begin</span> (<span class="func">+</span> <span class="num">1</span> (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="special">set!</span> <span class="var">foo</span> <span class="var">k</span>) <span class="num">2</span>)))
       (<span class="func">foo</span> <span class="num">3</span>) )</pre>

<p>Бабах! Мы получили бесконечный цикл, так как <code><span class="var">foo</span></code> оказывается теперь
связанной с <code>(<span class="special">begin</span> (<span class="func">+</span> <span class="num">1</span> <span class="hash">[]</span>) (<span class="func">foo</span> <span class="num">3</span>))</code>, что приводит к рекурсии. Как видим,
главный цикл — это не только последовательное вычисление выражений. Если мы
хотим правильно его проэмулировать, то вдобавок необходимо изменять продолжение
каждого вычисляемого в главном цикле выражения:</p>

<pre>(<span class="syntax">let</span> (<span class="var">foo</span> <span class="var">sequel</span> <span class="var">print?</span>)
  (<span class="special">define-syntax</span> <span class="var">toplevel</span>
    (<span class="syntax">syntax-rules</span> ()
      ((<span class="syntax">toplevel</span> <span class="var">e</span>) (<span class="func">toplevel-eval</span> (<span class="special">lambda</span> () <span class="var">e</span>))) ) )
  (<span class="special">define</span> (<span class="func">toplevel-eval</span> <span class="var">thunk</span>)
    (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>)
               (<span class="special">set!</span> <span class="var">print?</span> <span class="hash">#t</span>)
               (<span class="special">set!</span> <span class="var">sequel</span> <span class="var">k</span>)
               (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">thunk</span>)))
                 (<span class="syntax">when</span> <span class="var">print?</span> (<span class="func">display</span> <span class="var">v</span>) (<span class="special">set!</span> <span class="var">print?</span> <span class="hash">#f</span>))
                 (<span class="func">sequel</span> <span class="var">v</span>) ) )) )
  (<span class="syntax">toplevel</span> (<span class="func">+</span> <span class="num">1</span> (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) (<span class="special">set!</span> <span class="var">foo</span> <span class="var">k</span>) <span class="num">2</span>))))
  (<span class="syntax">toplevel</span> (<span class="func">foo</span> <span class="num">3</span>))
  (<span class="syntax">toplevel</span> (<span class="func">foo</span> (<span class="func">foo</span> <span class="num">4</span>))) )</pre>

<p>Каждый раз, когда мы хотим вычислить выражение с помощью <code><span class="syntax">toplevel</span></code>, его
продолжение — <em>продолжение</em> работы <code><span class="syntax">toplevel</span></code> — сохраняется
в переменной <code><span class="var">sequel</span></code>. Любое продолжение, захватываемое внутри <code><span class="func">thunk</span></code>,
теперь будет ограничено текущей вычисляемой формой. Аналогичным образом применяя
присваивание, можно сохранить любой срез стека в виде частичного продолжения.
Как видим, все продолжения с неограниченным временем жизни для своего создания
требуют побочных эффектов.</p>


<!--\indexR{присваивание!роль для продолжений}-->
<p>Частичные продолжения явно указывают, когда необходимо остановить вычисления.
Этот эффект может быть полезен в некоторых случаях, а также интересен сам по
себе. Мы вполне можем даже переписать нашу <code><span class="func">call/cc</span></code> так, чтобы она
захватывала именно частичные продолжения вплоть до <code><span class="syntax">toplevel</span></code>. Естественно,
кроме них потребуются также и переходы на тот случай, когда мы действительно
не заинтересованы в сохранении срезов стека. Но, с другой стороны, частичные
продолжения в реальности используются довольно редко; сложно привести пример
программы, где частичные продолжения были бы действительно полезны, но при этом
не усложняли бы её сильнее обычных. Тем не менее, они важны как ещё один пример
управляющей формы, которую можно реализовать на Scheme с помощью <code><span class="func">call/cc</span></code>
и присваивания.</p>


<h2 id="escape/sect:conclusions"><span class="wrap"><span class="seq">3.8.</span><span class="title">Заключение</span></span></h2>

<p>Продолжения вездесущи. Если вы понимаете продолжения, вы одновременно овладели
ещё одним стилем программирования, получили широчайшие возможности управления
ходом вычислений и знаете, во что вам обойдётся это управление. Продолжения
тесно связаны с потоком исполнения, так как они динамически определяют всё, что
ещё осталось сделать. Поэтому они так важны и полезны для обработки исключений.</p>

<p>Интерпретатор, определённый в этой главе, довольно мощный, но легко понятный
только по частям. Это обычное дело для объектно-ориентированного стиля: есть
много маленьких и простых кусочков, но не так просто составить понимание цельной
картины того, как они работают вместе. Интерпретатор модульный и легко
расширяется новыми возможностями. Он не особо быстрый, так как в процессе работы
создаёт целую гору объектов, которые удаляются тут же после использования.
Конечно, это является одной из задач компилятора: выяснить, какие из объектов
действительно стоит создавать и сохранять.</p>



<h2 id="escape/sect:exercises"><span class="wrap"><span class="seq">3.9.</span><span class="title">Упражнения</span></span></h2>

<h5 class="exercise" id="escape/ex:cc-cc">Упражнение <span class="seq">3.1</span></h5>
<p>Что вернёт <code>(<span class="func">call/cc</span> <span class="var">call/cc</span>)</code>? Зависит ли ответ от порядка вычислений?</p>


<h5 class="exercise" id="escape/ex:cc-cc-cc-cc">Упражнение <span class="seq">3.2</span></h5>
<p>А что вернёт <code>((<span class="func">call/cc</span> <span class="var">call/cc</span>) (<span class="func">call/cc</span> <span class="var">call/cc</span>))</code>?</p>


<h5 class="exercise" id="escape/ex:tagbody">Упражнение <span class="seq">3.3</span></h5>
<!--\indexC{tagbody}-->
<!--\indexC{go}-->
<p>Реализуйте пару <code><span class="special">tagbody</span></code>/<code><span class="special">go</span></code> с помощью <code><span class="special">block</span></code>, <code><span class="special">catch</span></code> и
<code><span class="special">labels</span></code>. Напомним синтаксис этой формы из <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>:</p>

<pre>(<span class="special">tagbody</span>
          <i>выражения<sub>0</sub></i>...
  <span class="llap"><i>метка<sub>1</sub></i></span>        <i>выражения<sub>1</sub></i>...
          ...
  <span class="llap"><i>метка<sub>i</sub></i></span>        <i>выражения<sub>i</sub></i>...
          ... )</pre>

<p>Все <i>выражения<sub>i</sub></i> (и только они) могут содержать безусловные переходы
<code>(<span class="special">go</span> <i>метка</i>)</code> и возвраты <code>(<span class="special">return</span> <i>значение</i>)</code>. Если <code><span class="special">return</span></code>
не будет, то форма <code><span class="special">tagbody</span></code> возвращает <code><span class="var">nil</span></code>.</p>


<h5 class="exercise" id="escape/ex:arity-optimize">Упражнение <span class="seq">3.4</span></h5>
<p>Вы скорее всего заметили, что функции при вызове проверяют фактическую арность:
количество переданных им аргументов. Измените механизм создания функций так,
чтобы правильная арность рассчитывалась только один раз. Можете считать, что
функции бывают только фиксированной арности.</p>


<h5 class="exercise" id="escape/ex:apply">Упражнение <span class="seq">3.5</span></h5>
<p>Определите функцию <code><span class="func">apply</span></code> для интерпретатора из этой главы.</p>


<h5 class="exercise" id="escape/ex:dotted">Упражнение <span class="seq">3.6</span></h5>
<p>Реализуйте поддержку функций переменной арности для интерпретатора из этой
главы.</p>


<h5 class="exercise" id="escape/ex:evaluate">Упражнение <span class="seq">3.7</span></h5>
<p>Измените функцию запуска интерпретатора так, чтобы она вызывала <code><span class="func">evaluate</span></code>
только единожды.</p>


<h5 class="exercise" id="escape/ex:cc-value">Упражнение <span class="seq">3.8</span></h5>
<p>Способ реализации продолжений из раздела
<a href="#escape/implementation/ssect:call/cc">3.4.1</a> отделяет продолжения от других
значений. Поэтому мы вынуждены реализовывать метод <code><span class="func">invoke</span></code> лично для класса
продолжений, представляемых функциями языка определения. Переопределите
<code><span class="func">call/cc</span></code> так, чтобы она возвращала объекты определяемого языка, являющиеся
экземплярами класса-наследника <code><span class="class">value</span></code>, соответствующего продолжениям.</p>


<h5 class="exercise" id="escape/ex:eternal">Упражнение <span class="seq">3.9</span></h5>
<!--\indexR{бесконечный цикл}-->
<p>Напишите на <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> функцию <code><span class="func">eternal-return</span></code>, принимающую замыкание и
вызывающую его в бесконечном цикле. Этот цикл должен быть истинно бесконечным:
перекройте абсолютно все выходы из него.</p>


<h5 class="exercise" id="escape/ex:crazy-cc">Упражнение <span class="seq">3.10</span></h5>
<p>Рассмотрим следующую хитроумную функцию (спасибо за неё Алану Бодену):</p>


<!--\indexR{коробки}-->
<!--\indexC{make-box}-->
<pre>(<span class="special">define</span> (<span class="func">make-box</span> <span class="var">value</span>)
  (<span class="syntax">let</span> ((<span class="var">box</span>
         (<span class="func">call/cc</span>
          (<span class="special">lambda</span> (<span class="var">exit</span>)
            (<span class="syntax">letrec</span>
             ((<span class="var">behavior</span>
               (<span class="func">call/cc</span>
                (<span class="special">lambda</span> (<span class="var">store</span>)
                  (<span class="func">exit</span> (<span class="special">lambda</span> (<span class="var">msg</span> . <span class="var">new</span>)
                          (<span class="func">call/cc</span>
                           (<span class="special">lambda</span> (<span class="var">caller</span>)
                             (<span class="syntax">case</span> <span class="var">msg</span>
                               ((<span class="var">get</span>) (<span class="func">store</span> (<span class="func">cons</span> (<span class="func">car</span> <span class="var">behavior</span>)
                                                   <span class="var">caller</span> )))
                               ((<span class="var">set</span>)
                                (<span class="func">store</span>
                                 (<span class="func">cons</span> (<span class="func">car</span> <span class="var">new</span>)
                                       <span class="var">caller</span> ) ) ) ) ) ) )) ) ) ))
             ((<span class="func">cdr</span> <span class="var">behavior</span>) (<span class="func">car</span> <span class="var">behavior</span>)) ) ) ) ))
    (<span class="func">box</span> '<span class="var">set</span> <span class="var">value</span>)
    <span class="var">box</span> ) )</pre>

<p>Предположим, в <code><span class="var">box1</span></code> лежит значение <code>(<span class="func">make-box</span> <span class="num">33</span>)</code>, тогда что получится
в результате следующих вычислений?</p>

<pre>(<span class="func">box1</span> '<span class="var">get</span>)
(<span class="special">begin</span> (<span class="func">box1</span> '<span class="var">set</span> <span class="num">44</span>) (<span class="func">box1</span> '<span class="var">get</span>))</pre>


<h5 class="exercise" id="escape/ex:generic-evaluate">Упражнение <span class="seq">3.11</span></h5>
<p>Среди всех наших функций только <code><span class="func">evaluate</span></code> не является обобщённой. Можно
создать класс программ, от которого будут наследоваться подклассы программ
с различным синтаксисом. Правда, в этом случае мы не сможем хранить программы
как S-выражения, они должны быть объектами. Соответственно, функция
<code><span class="func">evaluate</span></code> уже должна быть обобщённой. Это позволит легко вводить новые
специальные формы (возможно, даже прямо из определяемого языка). Воплотите эту
идею в жизнь.</p>


<h5 class="exercise" id="escape/ex:throw">Упражнение <span class="seq">3.12</span></h5>
<p>Реализуйте оператор <code><span class="func">throw</span></code> как функцию, а не специальную форму.</p>


<h5 class="exercise" id="escape/ex:cps-speed">Упражнение <span class="seq">3.13</span></h5>
<p>Сравните скорость выполнения обычного кода и переписанного в стиле передачи
продолжений.</p>


<h5 class="exercise" id="escape/ex:the-current-cc">Упражнение <span class="seq">3.14</span></h5>
<!--\indexC{the-current-continuation}-->
<p>Реализуйте <code><span class="func">call/cc</span></code> с помощью функции <code><span class="func">the-current-continuation</span></code>, которая
определяется следующим образом:</p>

<pre>(<span class="special">define</span> (<span class="func">the-current-continuation</span>)
  (<span class="func">call/cc</span> (<span class="special">lambda</span> (<span class="var">k</span>) <span class="var">k</span>)) )</pre>


<h2><span class="wrap"><span class="title">Рекомендуемая литература</span></span></h2>

<p>Годный, нетривиальный пример использования продолжений приведён в
<span class="cite">[<a href="z1_bibliography.xhtml#wan80a">Wan80a</a>]</span>. Также стоит почитать <span class="cite">[<a href="z1_bibliography.xhtml#hfw84">HFW84</a>]</span> об эмуляции сопрограмм.
В <span class="cite">[<a href="z1_bibliography.xhtml#dr87">dR87</a>]</span> прекрасно рассказано о развитии понимания важности рефлексии
для управляющих форм.</p>

</body>
</html>
