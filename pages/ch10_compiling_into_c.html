<!DOCTYPE html>
<html>

<head>
    <title>10 – Компиляция в Си</title>
    <link rel="stylesheet" type="text/css" href="css/zz_lisp.css">
</head>

<body>

<div class="substrate">
<div class="body">

<h1 id="chapter:cc"><span class="wrap"><span class="seq">Глава 10.</span><span class="title">Компиляция в Си</span></span></h1>

<!--\indexR{язык!целевой}-->
<p class="noindent"><span class="initial">И</span><span class="sc"><span class="c">ещё одна глава</span></span> о компиляции.
Но в этот раз мы разберём несколько новых подходов, в частности, плоские окружения, а ещё
у нас сменился целевой язык: теперь им будет Си. Подобное сочетание языков
поднимает несколько своеобразных вопросов, стоящих рассмотрения. С одной
стороны, брак с представителем более высокого сословия сулит определённые
выгоды: например, бесплатные низкоуровневые оптимизации и доступ к огромному
количеству библиотек на все случаи жизни. Но роз без шипов не бывает, так что
взамен мы отдаём хвостовую рекурсию и вдобавок получаем кучу проблем со сборкой
мусора.</p>

<div class="bigskip"></div>

<!--\indexR{компиляция!в язык высокого уровня}-->
<p>Компиляция в язык высокого уровня, вроде Си, интересна во многих отношениях. Так
как целевой язык несомненно богаче ассемблера, то всё же можно надеяться на
несколько более близкий к оригиналу результат, нежели бесформенный ералаш
байт-кодов. Далее, компиляторы Си существуют практически для любой платформы,
что благотворно сказывается на переносимости. Более того, эти компиляторы
не вчера родились и имеют в своём распоряжении существенный арсенал оптимизаций,
а также неплохо справляются с рутинными низкоуровневыми задачами вроде
распределения регистров, расположения данных в памяти, выбора режимов адресации
— обо всём этом можно забыть, сфокусировавшись исключительно на
высокоуровневом аспекте компиляции.</p>

<p>С другой стороны, выбор языка высокого уровня в качестве целевого накладывает
определённые философские и практические ограничения. Подобные языки обычно
разрабатываются под определённый стиль программирования и, чаще всего, без
особого внимания к вопросу кодогенерации. В результате обнаруживаются
разнообразные «стеклянные стены» вроде не более 32 аргументов у функций, или
16 максимальных уровней вложенности блоков, и так далее. Нормальные пользователи
их даже не замечают, а вот глупые программы-генераторы то и дело натыкаются.
Бывает, что какой-то жалкий макрос раздувает программу в 5, 10, а то и в 20 раз
при переводе на Си, а потом этого монстра ещё пытаются скормить компилятору.</p>

<p>Более того, если модель исполнения целевого языка имеет мало общего с моделью
языка исходного, это плохо сказывается как на сложности самого процесса
преобразования, так и на эффективности использования возможностей целевого
языка. Си разрабатывался как язык системного программирования (изначально для
написания UNIX), поэтому в нём намеренно применяется явное управление памятью.
Вследствие этого могут возникать невероятно каверзные ошибки, если программист
не будет предельно осторожен с указателями, — иначе это лишь вопрос времени,
когда программа выйдет из-под контроля и начнёт творить непоправимое. В Лиспе
подобная ситуация невозможна в принципе, это безопасный язык в плане управления
памятью.</p>

<p>Вдобавок ко всему, Си не особо подходит для функционального стиля
программирования, где вызовы функций и рекурсия случаются на каждом шагу.
Компиляторы тщательнее оптимизируют императивные аспекты языка, поэтому
программисты стараются избегать менее эффективных в данном случае функциональных
алгоритмов, что даёт разработчикам компиляторов моральное право уделять меньше
внимания их оптимизации, так как они всё равно редко используются. Такой вот
замкнутый круг.</p>

<p>Как бы то ни было, нельзя сказать, что Си непопулярен в качестве целевого языка
компиляции Лиспа. Достаточно упомянуть Kyoto <span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span>
<span class="cite">[<a href="z1_bibliography.html#yh85">YH85</a>]</span> (а также
улучшенный Уильямом Скэлтером AKCL), WCL <span class="cite">[<a href="z1_bibliography.html#hen92b">Hen92b</a>]</span>,
CLICC <span class="cite">[<a href="z1_bibliography.html#hof93">Hof93</a>]</span>,
ECoLisp <span class="cite">[<a href="z1_bibliography.html#att95">Att95</a>]</span>,
Scheme<span class="math"><span class="rel">→</span></span>C <span class="cite">[<a href="z1_bibliography.html#bar89">Bar89</a>]</span>,
Sqil <span class="cite">[<a href="z1_bibliography.html#sen91">Sén91</a>]</span>,
ILOG Talk <span class="cite">[<a href="z1_bibliography.html#ilo94">ILO94</a>]</span>,
Bigloo <span class="cite">[<a href="z1_bibliography.html#ser94">Ser94</a>]</span>.</p>

<p>Наш компилятор им не соперник. Это лишь набросок, однако имеющий достаточное
количество интересных деталей. Конечно, можно было бы пойти простым путём
(кто-то поправит: тривиальным) — взять компилятор в байт-код из
<a href="ch07_compilation.html">седьмой главы</a> и переработать его, чтобы он
выводил код на Си, а не байты. Ведь для каждой машинной инструкции определена её
операционная семантика, так что не составит труда перевести их все на Си. Однако
нас ожидает совершенно иной путь, пролегающий сквозь страну плоских окружений.
<span class="see">[см. раздел <a href="ch06_fast_interpretation.html#fast/fast/variations/ssect:flat">6.1.9</a>]</span> Рассматриваемый компилятор будет
многопроходным. Объектное представление обрабатываемых программ значительно
облегчит их анализ и трансформацию. По сути, именно систематический
объектно-ориентированный подход делает излагаемый в данной главе материал столь
элегантным и расширяемым.</p>


<h2 id="cc/sect:objectification"><span class="wrap"><span class="seq">10.1.</span><span class="title">Объектификация</span></span></h2>

<!--\indexR{объектификация}-->
<p>В разделе <a href="ch09_macros.html#macros/macrosystem/ssect:object">9.11.1</a>
рассматривался алгоритм преобразования программ в объектную форму. Он раскрывает
все макросы и в конечном итоге возвращает готовый объект класса
<code><span class="class">Program</span></code>. Чтобы разбавить это весьма
лаконичное описание, вашему вниманию предлагается
рисунок <a href="#cc/objectification/pic:result">10.1</a> с результатом объектификации
следующей далее программы. В ней, если присмотреться, можно найти каждый
изученный нами существенный аспект Scheme. Страницы не безграничны, так что
имена классов записаны сокращённо, а часть дерева и вовсе не показана. На
протяжении этой главы мы не раз будем возвращаться к данному примеру.</p>

<pre>(<span class="special">begin</span>
  (<span class="special">set!</span> <span class="var">index</span> <span class="num">1</span>)
  ((<span class="special">lambda</span> (<span class="var">cnter</span> . <span class="var">tmp</span>)
     (<span class="special">set!</span> <span class="var">tmp</span> (<span class="func">cnter</span> (<span class="special">lambda</span> (<span class="var">i</span>) (<span class="special">lambda</span> <span class="var">x</span> (<span class="func">cons</span> <span class="var">i</span> <span class="var">x</span>)))))
     (<span class="special">if</span> <span class="var">cnter</span> (<span class="func">cnter</span> <span class="var">tmp</span>) <span class="var">index</span>) )
   (<span class="special">lambda</span> (<span class="var">f</span>)
     (<span class="special">set!</span> <span class="var">index</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">index</span>))
     (<span class="func">f</span> <span class="var">index</span>) )
   '<span class="var">foo</span>) )        <span class="math"><span class="rel">→</span></span> (<span class="num">2</span> <span class="num">3</span>)</pre>

<div class="image" id="cc/objectification/pic:result">
<img src="images/png26.png" alt="Структура объектифицированного фрагмента кода" style="width: 5.94in">
<span class="caption">Рис. 10.1. Объектифицированный код.</span>
</div>


<h2 id="cc/sect:code-walk"><span class="wrap"><span class="seq">10.2.</span><span class="title">Обход кода</span></span></h2>

<!--\indexR{обход кода}-->
<!--\indexR{синтаксическое дерево}-->
<p>Обход кода является чрезвычайно важным приёмом при построении компиляторов.
<span class="cite">[<a href="z1_bibliography.html#cur89">Cur89</a>,
<a href="z1_bibliography.html#wat93">Wat93</a>]</span>
Суть его состоит в обходе построенного ранее дерева,
представляющего обрабатываемую программу. В процессе него собирается информация,
в узлах дерева оставляются разнообразные пометки, и так далее; всё это делается
ради облегчения следующего этапа — кодогенерации. Порядок обхода, а также
используемые структуры данных сильно зависят от поставленных целей, поэтому
какого-либо универсального алгоритма не существует. Если вдуматься, то все наши
интерпретаторы — это именно обходчики кода, которые исполняют его в процессе;
и предобработчик <code><span class="func">meaning</span></code> из <a href="ch06_fast_interpretation.html">главы про быструю интерпретацию</a>
также является специализированным обходчиком.</p>

<!--\indexR{метаметод}-->
<!--\indexR{методы!метаметоды}-->
<p>Мы будем использовать всего один способ обхода дерева, но выполняемые в это
время действия могут быть различными. Для такого случая отлично подходит идиома
<em class="term">метаметода</em> (или метода высшего порядка, если хотите). Функция
<code><span class="func">update-walk!</span></code> принимает следующие аргументы: обобщённую функцию <i>g</i>,
объект <i>o</i> класса <code><span class="class">Program</span></code>, а также неопределённое количество
дополнительных аргументов для <i>g</i>. Для каждого поля <i>f</i> объекта <i>o</i>,
содержащего экземпляр <code><span class="class">Program</span></code>, она заменяет его значение результатом
аппликации <code>(<i>g</i> <i>f</i>)</code>. Возвращаемым значением <code><span class="func">update-walk!</span></code>
является обновлённый объект. Надеюсь, теперь вам стало понятно, зачем класс
<code><span class="class">Arguments</span></code>, представляющий аргументы аппликаций, сделан наследником
<code><span class="class">Program</span></code>: ведь аргументы тоже вычисляются и их надо исследовать в процессе
обхода.</p>

<!--\indexC{update-walk"!}-->
<pre>(<span class="special">define</span> (<span class="func">update-walk!</span> <span class="var">g</span> <span class="var">o</span> . <span class="var">args</span>)
  (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">field</span>)
              (<span class="syntax">let</span> ((<span class="var">vf</span> (<span class="func">field-value</span> <span class="var">o</span> <span class="var">field</span>)))
                (<span class="syntax">when</span> (<span class="func">Program?</span> <span class="var">vf</span>)
                  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="special">if</span> (<span class="func">null?</span> <span class="var">args</span>) (<span class="func">g</span> <span class="var">vf</span>)
                               (<span class="func">apply</span> <span class="var">g</span> <span class="var">vf</span> <span class="var">args</span>) )))
                    (<span class="func">set-field-value!</span> <span class="var">o</span> <span class="var">v</span> <span class="var">field</span>) ) ) ) )
            (<span class="func">Class-fields</span> (<span class="func">object-&gt;class</span> <span class="var">o</span>)) )
  <span class="var">o</span> )</pre>

<p>Может показаться, что такой подход чересчур уж всё упрощает, но это
действительно весьма удобная функция для преобразования программ, как вы сами
убедитесь в дальнейшем. Очевидно, что некоторые этапы различных трансформаций
возможно объединить и выполнить за один обход дерева, ускорив тем самым
обработку. Однако, мы оградим себя от соблазна во имя чёткого разделения
эффектов применяемых трансформаций.</p>


<h2 id="cc/sect:boxes"><span class="wrap"><span class="seq">10.3.</span><span class="title">Пакуем коробки</span></span></h2>

<!--\indexR{преобразование!в коробочный стиль}-->
<!--\indexR{коробки!преобразование}-->
<p>Для начала давайте заменим все локальные присваивания операциями над коробками.
Подобное преобразование уже разбиралось ранее
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.html#assignment/assignment/ssect:boxes">4.1.1</a>]</span>, поэтому оно будет хорошим примером
использования <code><span class="func">update-walk!</span></code>.</p>

<p>Итак, каждое присваивание локальной переменной должно быть изменено на помещение
соответствующего значения в коробку. Естественно, обращения к переменным тоже
преобразуются в извлечения значений из соответствующих коробок. Интерфейсом
к обходчику кода служат обобщённые функции, так что приведённые выше
преобразования надо выразить в виде одной из них. Как вы помните, коробочное
преобразование выполнялось рекурсивно для всего выражения — точно так же
должна действовать и обобщённая функция. Её совместная работа с обходчиком —
это залог успеха и основа могущества данного союза.</p>

<!--\indexC{insert-box"!}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Program</span>))
  (<span class="func">update-walk!</span> <span class="var">insert-box!</span> <span class="var">o</span>) )</pre>

<p>Мы введём три новых класса узлов синтаксического дерева для представления новых
понятий, необходимых при работе с коробками. Подробно каждый из классов будет
рассмотрен позже, вместе с соответствующими этапами преобразования.</p>

<!--\indexC{Box-Read}-->
<!--\indexC{Box-Write}-->
<!--\indexC{Box-Creation}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Box-Read</span>     <span class="class">Program</span> (<span class="var">reference</span>))
(<span class="syntax">define-class</span> <span class="class">Box-Write</span>    <span class="class">Program</span> (<span class="var">reference</span> <span class="var">form</span>))
(<span class="syntax">define-class</span> <span class="class">Box-Creation</span> <span class="class">Program</span> (<span class="var">variable</span>))</pre>

<p>Благодаря удачному решению помечать во время объектификации изменяемые локальные
переменные флагом <code><span class="var">mutable?</span></code>, заменить обращения к подобным переменным
вызовами <code><span class="func">Box-Read</span></code> становится элементарно:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Local-Reference</span>))
  (<span class="special">if</span> (<span class="func">Local-Variable-mutable?</span> (<span class="func">Local-Reference-variable</span> <span class="var">o</span>))
      (<span class="func">make-Box-Read</span> <span class="var">o</span>)
      <span class="var">o</span> ) )</pre>

<p>Преобразование присваиваний сравнимо по сложности. Присваивание локальной
переменной однозначно переводится в <code><span class="func">Box-Write</span></code>. Нужно только не забыть
о рекурсивной природе преобразования и вызвать обходчик для выражения,
вычисляющего новое значение переменной.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Local-Assignment</span>))
  (<span class="func">make-Box-Write</span> (<span class="func">Local-Assignment-reference</span> <span class="var">o</span>)
                  (<span class="func">insert-box!</span> (<span class="func">Local-Assignment-form</span> <span class="var">o</span>)) ) )</pre>

<p>В данный момент программа считает, что все изменяемые переменные уже разложены
по коробкам; нам остаётся лишь оправдать её ожидания. Локальные изменяемые
переменные создаются исключительно <code><span class="special">lambda</span></code>- и <code><span class="syntax">let</span></code>-формами, то есть
узлами классов <code><span class="class">Function</span></code> и <code><span class="class">Fix-Let</span></code><a class="footref" href="zz_footnotes.html#foot10.1"><sup>1</sup></a>.
Идея состоит в том, чтобы поместить создание коробок перед
телом этих форм. <span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.html#ch4-box-transform">4.1.1</a>]</span> Просто и
понятно, так что приступаем к написанию соответствующих специализаций функции
<code><span class="func">insert-box!</span></code>. Каждая из них заказывает у вспомогательной функции необходимое
количество коробок, после чего вставляет полученные экземпляры <code><span class="class">Box-Creation</span></code>
куда следует.</p>

<!--\indexC{boxify-mutable-variables}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Function</span>))
  (<span class="func">set-Function-body!</span>
   <span class="var">o</span> (<span class="func">insert-box!</span>
      (<span class="func">boxify-mutable-variables</span> (<span class="func">Function-body</span> <span class="var">o</span>)
                                (<span class="func">Function-variables</span> <span class="var">o</span>) ) ) )
  <span class="var">o</span> )

(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Fix-Let</span>))
  (<span class="func">set-Fix-Let-arguments!</span> <span class="var">o</span> (<span class="func">insert-box!</span> (<span class="func">Fix-Let-arguments</span> <span class="var">o</span>)))
  (<span class="func">set-Fix-Let-body!</span>
   <span class="var">o</span> (<span class="func">insert-box!</span>
      (<span class="func">boxify-mutable-variables</span> (<span class="func">Fix-Let-body</span> <span class="var">o</span>)
                                (<span class="func">Fix-Let-variables</span> <span class="var">o</span>) ) ) )
  <span class="var">o</span> )

(<span class="special">define</span> (<span class="func">boxify-mutable-variables</span> <span class="var">form</span> <span class="var">variables</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">variables</span>)
      (<span class="special">if</span> (<span class="func">Local-Variable-mutable?</span> (<span class="func">car</span> <span class="var">variables</span>))
          (<span class="func">make-Sequence</span>
           (<span class="func">make-Box-Creation</span> (<span class="func">car</span> <span class="var">variables</span>))
           (<span class="func">boxify-mutable-variables</span> <span class="var">form</span> (<span class="func">cdr</span> <span class="var">variables</span>)) )
          (<span class="func">boxify-mutable-variables</span> <span class="var">form</span> (<span class="func">cdr</span> <span class="var">variables</span>)) )
      <span class="var">form</span> ) )</pre>

<p>Готово. Мы полностью определили коробочное преобразование с помощью всего лишь
четырёх предельно понятных методов. Результат его выполнения можно увидеть на
рисунке <a href="#cc/boxes/pic:result">9.2</a> (показана только изменившаяся часть).</p>

<div class="image" id="cc/boxes/pic:result">
<img src="images/png27.png" alt="Объектифицированный фрагмент, использующий присваивания, после коробочного преобразования" style="width: 3.05in">
<span class="caption">Рис. 10.2. <code>(<span class="special">lambda</span> (<span class="var">cnter</span> . <span class="var">tmp</span>) (<span class="special">set!</span> <span class="var">tmp</span> ...) (<span class="special">if</span> ... (... <span class="var">tmp</span>) ...))</code>.</span>
</div>


<h2 id="cc/sect:no-nest"><span class="wrap"><span class="seq">10.4.</span><span class="title">Избавляемся от вложенных функций</span></span></h2>

<!--\indexR{функции!вложенные}-->
<!--\indexR{лямбда-поднятие@$\lambda$-поднятие}-->
<!--\indexE{lambda-lifting@$\lambda$-lifting}-->
<!--\indexR{комбинаторы}-->
<!--\indexR{свободные переменные}-->
<!--\indexR{переменные!свободные}-->
<p>Язык Си не позволяет определять функции внутри других функций. Иными словами,
вложенные <code><span class="special">lambda</span></code>-формы нельзя прямо перевести на Си. Следовательно, от них
необходимо избавиться, преобразовав программу в набор комбинаторов — функций
без свободных переменных. К счастью, это довольно известное преобразование,
называемое <em class="term"><span class="math"><span class="ord var">λ</span></span>-поднятием</em> (<span class="math"><span class="ord var">λ</span></span>-lifting) — в результате
него <code><span class="special">lambda</span></code>-формы поднимаются вверх, до самой поверхности, не оставляя
ни одной свободной переменной в глубине программы. Существует множество
вариантов реализации подобного преобразования, по-разному обращающихся
с исходными функциями и сохраняющих те или иные их аспекты, например:
<span class="cite">[<a href="z1_bibliography.html#ws94">WS94</a>,
<a href="z1_bibliography.html#kh89">KH89</a>,
<a href="z1_bibliography.html#ch94">CH94</a>]</span>.</p>

<!--\indexR{замыкания (closures)}-->
<!--\indexC{invoke}-->
<p>Результатом вычисления любой <code><span class="special">lambda</span></code>-формы является замыкание — сущность,
сохраняющая в себе окружение, где она была создана. При вызове замыкания
специальная функция (известная как <code><span class="func">invoke</span></code>) берёт на себя работу по
организации вычисления тела данного замыкания в правильном окружении,
составленном из аргументов функции, находящихся в окружении вызова, и свободных
переменных, извлекаемых из замкнутого окружения. Фактически, это единственная
функция, которой известна истинная природа замыканий, поэтому мы можем довольно
легко изменить их структуру, не потревожив остальные части программы: ведь
каждая аппликация в конечном итоге выполняется <code><span class="func">invoke</span></code>.</p>

<!--\indexR{ОО-подъём}-->
<!--\indexE{OO-lifting}-->
<p>Рассмотрим упомянутое преобразование на примере <em class="term">ОО-подъёма</em>, описанного
в <span class="cite">[<a href="z1_bibliography.html#que94">Que94</a>]</span>. Как обычно, морской свинкой будет факториал:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">k</span> <span class="num">1</span>)
      (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>))) ) ) )</pre>

<p>От <code><span class="special">lambda</span></code>-формы со свободными переменными <code><span class="var">k</span></code> и <code><span class="var">n</span></code> можно избавиться
следующим образом:</p>

<pre>(<span class="syntax">define-class</span> <span class="class">Fact-Closure</span> <span class="class">Object</span> (<span class="var">n</span> <span class="var">k</span>))

(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">Fact-Closure</span>) <span class="var">r</span>)
  (<span class="func">invoke</span> (<span class="func">Fact-Closure-k</span> <span class="var">f</span>) (<span class="func">*</span> (<span class="func">Fact-Closure-n</span> <span class="var">f</span>) <span class="var">r</span>)) )

(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">invoke</span> <span class="var">k</span> <span class="num">1</span>)
      (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) (<span class="func">make-Fact-Closure</span> <span class="var">n</span> <span class="var">k</span>)) ) )</pre>

<!--\indexR{плоские окружения}-->
<!--\indexR{окружение!плоское}-->
<p>Суть преобразования состоит в замене неявной структуры создаваемого анонимного
замыкания явным объектом класса <code><span class="class">Fact-Closure</span></code>, содержащим все необходимые
свободные переменные (здесь это <code><span class="var">n</span></code> и <code><span class="var">k</span></code>). После этого остаётся только
научить <code><span class="func">invoke</span></code> корректным образом обрабатывать подобные объекты.</p>


<!--\indexR{преобразование!замыканий в комбинаторы}-->
<p>Для выполнения такого преобразования вначале надо как-то получить и где-то
сохранить список свободных переменных обрабатываемых функций. Для этого введём
новый класс преобразованных функций — <code><span class="class">Flat-Function</span></code>, а их свободные
переменные будем собирать в списки из <code><span class="class">Free-Environment</span></code>, заканчивающиеся на
<code><span class="class">No-Free</span></code>. Как и их братья <code><span class="class">Arguments</span></code> и <code><span class="class">No-Argument</span></code>, эти два класса
являются наследниками <code><span class="class">Program</span></code>, потому что представляют вычислимые понятия.
Обращения к свободным переменным тоже будут преобразованы в специальные объекты
класса <code><span class="class">Free-Reference</span></code>.</p>

<!--\indexC{Flat-Function}-->
<!--\indexC{Free-Environment}-->
<!--\indexC{Free-Reference}-->
<!--\indexC{No-Free}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Flat-Function</span>    <span class="class">Function</span>  (<span class="var">free</span>))
(<span class="syntax">define-class</span> <span class="class">Free-Environment</span> <span class="class">Program</span>   (<span class="var">first</span> <span class="var">others</span>))
(<span class="syntax">define-class</span> <span class="class">No-Free</span>          <span class="class">Program</span>   ())
(<span class="syntax">define-class</span> <span class="class">Free-Reference</span>   <span class="class">Reference</span> ())</pre>

<p>Реализуется это преобразование, естественно, с помощью обходчика кода. Функция
<code><span class="func">lift!</span></code> будет служить удобным интерфейсом, а всю чёрную работу мы переложим
на обобщённую функцию <code><span class="func">lift-procedures!</span></code>. Помимо обрабатываемой функции, она
принимает два вспомогательных аргумента: абстракцию <code><span class="var">flatfun</span></code>, которая
в конечном итоге будет содержать все свободные переменные, и список <code><span class="var">vars</span></code>,
где лежат все переменные, который на данный момент связаны. По умолчанию
<code><span class="func">lift-procedures!</span></code> просто рекурсивно вызывается для всех дочерних узлов
обрабатываемой программы.</p>

<!--\indexC{lift"!}-->
<!--\indexC{lift-procedures"!}-->
<pre>(<span class="special">define</span> (<span class="func">lift!</span> <span class="var">o</span>)
  (<span class="func">lift-procedures!</span> <span class="var">o</span> <span class="hash">#f</span> <span class="hash">'()</span>) )

(<span class="syntax">define-generic</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Program</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="func">update-walk!</span> <span class="var">lift-procedures!</span> <span class="var">o</span> <span class="var">flatfun</span> <span class="var">vars</span>) )</pre>

<p>Преобразование определяется всего тремя методами. Первый из них отвечает за
обработку обращений к свободным переменным и поддержание списка <code><span class="var">flatfun</span></code>
в адекватном состоянии. Функция <code><span class="func">adjoin-free-variable!</span></code> помогает с занесением
новых свободных переменных в этот список.</p>

<!--\indexC{adjoin-free-variable"!}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Local-Reference</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">Local-Reference-variable</span> <span class="var">o</span>)))
    (<span class="special">if</span> (<span class="func">memq</span> <span class="var">v</span> <span class="var">vars</span>) <span class="var">o</span>
        (<span class="special">begin</span> (<span class="func">adjoin-free-variable!</span> <span class="var">flatfun</span> <span class="var">o</span>)
               (<span class="func">make-Free-Reference</span> <span class="var">v</span>) ) ) ) )

(<span class="special">define</span> (<span class="func">adjoin-free-variable!</span> <span class="var">flatfun</span> <span class="var">ref</span>)
  (<span class="syntax">when</span> (<span class="func">Flat-Function?</span> <span class="var">flatfun</span>)
    (<span class="syntax">let</span> <span class="func">check</span> ((<span class="var">free*</span> (<span class="func">Flat-Function-free</span> <span class="var">flatfun</span>)))
      (<span class="special">if</span> (<span class="func">No-Free?</span> <span class="var">free*</span>)
          (<span class="func">set-Flat-Function-free!</span>
           <span class="var">flatfun</span> (<span class="func">make-Free-Environment</span>
                    <span class="var">ref</span> (<span class="func">Flat-Function-free</span> <span class="var">flatfun</span>) ) )
          (<span class="syntax">unless</span> (<span class="func">eq?</span> (<span class="func">Reference-variable</span> <span class="var">ref</span>)
                       (<span class="func">Reference-variable</span>
                        (<span class="func">Free-Environment-first</span> <span class="var">free*</span>) ) )
            (<span class="func">check</span> (<span class="func">Free-Environment-others</span> <span class="var">free*</span>)) ) ) ) ) )</pre>

<!--\indexR{приводимые!формы}-->
<!--\indexR{форма!приводимая}-->
<p>Как известно, форма <code><span class="syntax">let</span></code> создаёт локальные привязки, поэтому перед
обработкой тела <code><span class="class">Fix-Let</span></code> необходимо поместить все свежесозданные связанные
переменные в список <code><span class="var">vars</span></code>. Ещё одним неоспоримым фактом является то, что
приводимые формы, к которым относится <code><span class="syntax">let</span></code>, лишь вводят новые переменные и
не требуют создания замыканий. Это очень важная оптимизация, и мы отнюдь
не хотим её лишиться.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Fix-Let</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="func">set-Fix-Let-arguments!</span>
   <span class="var">o</span> (<span class="func">lift-procedures!</span> (<span class="func">Fix-Let-arguments</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">vars</span>) )
  (<span class="syntax">let</span> ((<span class="var">newvars</span> (<span class="func">append</span> (<span class="func">Fix-Let-variables</span> <span class="var">o</span>) <span class="var">vars</span>)))
    (<span class="func">set-Fix-Let-body!</span>
     <span class="var">o</span> (<span class="func">lift-procedures!</span> (<span class="func">Fix-Let-body</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">newvars</span>) )
    <span class="var">o</span> ) )</pre>

<p>Наконец, остался самый сложный случай — абстракции. Тело абстракции
анализируется и все её свободные переменные собираются в объекте
<code><span class="class">Flat-Function</span></code>. Так как свободные переменные вложенной абстракции сами могут
оказаться свободными в содержащей её абстракции, то для них обходчик вызывается
ещё раз, чтобы протолкнуть их как можно выше. Сейчас самое время порадоваться
принятому ранее решению сделать список свободных переменных наследником
<code><span class="class">Program</span></code>.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Function</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="syntax">let*</span> ((<span class="var">localvars</span> (<span class="func">Function-variables</span> <span class="var">o</span>))
         (<span class="var">body</span>      (<span class="func">Function-body</span> <span class="var">o</span>))
         (<span class="var">newfun</span> (<span class="func">make-Flat-Function</span> <span class="var">localvars</span> <span class="var">body</span> (<span class="func">make-No-Free</span>))) )
    (<span class="func">set-Flat-Function-body!</span>
     <span class="var">newfun</span> (<span class="func">lift-procedures!</span> <span class="var">body</span> <span class="var">newfun</span> <span class="var">localvars</span>) )
    (<span class="syntax">let</span> ((<span class="var">free*</span> (<span class="func">Flat-Function-free</span> <span class="var">newfun</span>)))
      (<span class="func">set-Flat-Function-free!</span>
       <span class="var">newfun</span> (<span class="func">lift-procedures!</span> <span class="var">free*</span> <span class="var">flatfun</span> <span class="var">vars</span>) ) )
    <span class="var">newfun</span> ) )</pre>

<p>Как полагается, на рисунке <a href="#cc/no-nest/pic:result">10.3</a> показан результат
применения рассмотренного преобразования к нашему бессменному примеру.</p>

<div class="image" id="cc/no-nest/pic:result">
<img src="images/png28.png" alt="Объектифицированный фрагмент, использующий вложенные абстракции" style="width: 3.87in">
<span class="caption">Рис. 10.3. <code>(<span class="special">lambda</span> (<span class="var">i</span>) (<span class="special">lambda</span> <span class="var">x</span> (<span class="func">cons</span> <span class="var">i</span> <span class="var">x</span>)))</code>.</span>
</div>


<h2 id="cc/sect:collecting"><span class="wrap"><span class="seq">10.5.</span><span class="title">Собираем цитаты и функции</span></span></h2>

<!--\indexR{миграция!цитат}-->
<!--\indexR{миграция!вложенных функций}-->
<p>Предыдущее преобразование не изменяло расположения функций: вложенные
<code><span class="special">lambda</span></code>-формы так и остались вложенными,
пусть и без свободных переменных.
Нет, мы не забыли об этом! Просто немного задержались, чтобы выполнить перенос
вместе со следующим преобразованием — извлечением цитат. Во время следующего
обхода кода мы извлечём все используемые цитаты и определения функций, чтобы
перенести их на глобальный уровень, как этого требует Си. Здесь понадобятся
всего два метода.</p>

<p>Функция <code><span class="func">extract-things!</span></code> преобразовывает объекты <code><span class="class">Program</span></code> в объекты
<code><span class="class">Flattened-Program</span></code>. Новый класс является наследником <code><span class="class">Program</span></code> и имеет
три дополнительных поля: <code><span class="var">form</span></code> для собственно программы, <code><span class="var">quotations</span></code> для
списка цитат и <code><span class="var">definitions</span></code> для определений функций. До значений цитат можно
добраться через глобальные переменные нового класса <code><span class="class">Quotation-Variable</span></code>.
Функции мы просто пронумеруем, выдав каждой из них уникальный <code><span class="var">index</span></code>.
Наконец, создание замыканий перекладывается на новый тип узлов синтаксического
дерева — <code><span class="class">Closure-Creation</span></code>. (Не волнуйтесь, скоро вам станет ясно, почему
всё сделано именно так.)</p>

<!--\indexC{Flattened-Program}-->
<!--\indexC{Quotation-Variable}-->
<!--\indexC{Function-Definition}-->
<!--\indexC{Closure-Creation}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Flattened-Program</span>   <span class="class">Program</span> (<span class="var">form</span> <span class="var">quotations</span> <span class="var">definitions</span>))
(<span class="syntax">define-class</span> <span class="class">Quotation-Variable</span>  <span class="class">Variable</span> (<span class="var">value</span>))
(<span class="syntax">define-class</span> <span class="class">Function-Definition</span> <span class="class">Flat-Function</span> (<span class="var">index</span>))
(<span class="syntax">define-class</span> <span class="class">Closure-Creation</span>    <span class="class">Program</span> (<span class="var">index</span> <span class="var">variables</span> <span class="var">free</span>))</pre>

<p>Строго говоря, <code><span class="func">extract-things!</span></code> работает не одна, а вместе с обобщённой
функцией <code><span class="func">extract!</span></code>. Взаимодействие подразумевает обмен информацией. Дабы
не прибегать для этого к глобальным переменным (например, ради распараллеливания
компиляции), мы будем возвращать результат через специальный аргумент,
передаваемый обобщённой функции.</p>

<!--\indexC{extract-things}-->
<!--\indexC{extract"!}-->
<pre>(<span class="special">define</span> (<span class="func">extract-things!</span> <span class="var">o</span>)
  (<span class="syntax">let</span> ((<span class="var">result</span> (<span class="func">make-Flattened-Program</span> <span class="var">o</span> <span class="hash">'()</span> <span class="hash">'()</span>)))
    (<span class="func">set-Flattened-Program-form!</span> <span class="var">result</span> (<span class="func">extract!</span> <span class="var">o</span> <span class="var">result</span>))
    <span class="var">result</span> ) )

(<span class="syntax">define-generic</span> (<span class="func">extract!</span> (<span class="var">o</span> <span class="class">Program</span>) <span class="var">result</span>)
  (<span class="func">update-walk!</span> <span class="var">extract!</span> <span class="var">o</span> <span class="var">result</span>) )</pre>

<p>Цитаты просто собираются в отведённом для них поле, а все обращения к ним
заменяются обращениями к соответствующим глобальным переменным,
инициализированным значениями исходных цитат.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">extract!</span> (<span class="var">o</span> <span class="class">Constant</span>) <span class="var">result</span>)
  (<span class="syntax">let*</span> ((<span class="var">qv*</span> (<span class="func">Flattened-Program-quotations</span> <span class="var">result</span>))
         (<span class="var">qv</span>  (<span class="func">make-Quotation-Variable</span> (<span class="func">length</span> <span class="var">qv*</span>)
                                       (<span class="func">Constant-value</span> <span class="var">o</span>) )) )
    (<span class="func">set-Flattened-Program-quotations!</span> <span class="var">result</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">qv*</span>))
    (<span class="func">make-Global-Reference</span> <span class="var">qv</span>) ) )</pre>

<p>Абстракции находятся в узлах типа <code><span class="class">Flat-Function</span></code>, которые преобразуются
в экземпляры <code><span class="class">Closure-Creation</span></code>. Процесс можно было бы оптимизировать,
избежав дублирования кода для одинаковых абстракций, научив
<code><span class="func">adjoin-definition!</span></code> отыскивать повторения. Также может показаться странным,
что столько внимания уделяется спискам свободных переменных изначальных
абстракций. Это делается исключительно для облегчения определения арности
функций во время генерации Си-кода.</p>

<!--\indexC{adjoin-definition"!}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">extract!</span> (<span class="var">o</span> <span class="class">Flat-Function</span>) <span class="var">result</span>)
  (<span class="syntax">let*</span> ((<span class="var">newbody</span>   (<span class="func">extract!</span> (<span class="func">Flat-Function-body</span> <span class="var">o</span>) <span class="var">result</span>))
         (<span class="var">variables</span> (<span class="func">Flat-Function-variables</span> <span class="var">o</span>))
         (<span class="var">freevars</span>  (<span class="syntax">let</span> <span class="func">extract</span> ((<span class="var">free</span> (<span class="func">Flat-Function-free</span> <span class="var">o</span>)))
                      (<span class="special">if</span> (<span class="func">Free-Environment?</span> <span class="var">free</span>)
                          (<span class="func">cons</span> (<span class="func">Reference-variable</span>
                                 (<span class="func">Free-Environment-first</span> <span class="var">free</span>) )
                                (<span class="func">extract</span>
                                 (<span class="func">Free-Environment-others</span> <span class="var">free</span>) ) )
                          <span class="hash">'()</span> ) ))
         (<span class="var">index</span> (<span class="func">adjoin-definition!</span>
                 <span class="var">result</span> <span class="var">variables</span> <span class="var">newbody</span> <span class="var">freevars</span> )) )
    (<span class="func">make-Closure-Creation</span> <span class="var">index</span> <span class="var">variables</span> (<span class="func">Flat-Function-free</span> <span class="var">o</span>)) ) )

(<span class="special">define</span> (<span class="func">adjoin-definition!</span> <span class="var">result</span> <span class="var">variables</span> <span class="var">body</span> <span class="var">free</span>)
  (<span class="syntax">let*</span> ((<span class="var">definitions</span> (<span class="func">Flattened-Program-definitions</span> <span class="var">result</span>))
         (<span class="var">newindex</span> (<span class="func">length</span> <span class="var">definitions</span>)) )
    (<span class="func">set-Flattened-Program-definitions!</span>
     <span class="var">result</span> (<span class="func">cons</span> (<span class="func">make-Function-Definition</span>
                   <span class="var">variables</span> <span class="var">body</span> <span class="var">free</span> <span class="var">newindex</span> )
                  <span class="var">definitions</span> ) )
    <span class="var">newindex</span> ) )</pre>

<p>И снова, на рисунке <a href="#cc/collecting/pic:result">10.4</a> показан результат применения
преобразования к иной части примера.</p>

<div class="image" id="cc/collecting/pic:result">
<img src="images/png29.png" alt="Объектифицированный фрагмент, демонстрирующий структуру объектов FlattenedProgram" style="width: 4.48in">
<span class="caption">Рис. 10.4. <code>(<span class="special">begin</span> (<span class="special">set!</span> <span class="var">index</span> <span class="num">1</span>) ((<span class="special">lambda</span> ...) ... ))</code></span>
</div>

<p id="cc/collecting/par:main">Наконец, вся программа превращается в вызов одной
огромной функции. То есть <span class="math"><span class="ord var">π</span></span>
становится <code>((<span class="special">lambda</span> () <span class="math"><span class="ord var">π</span></span>))</code>.</p>

<!--\indexC{closurize-main"!}-->
<pre>(<span class="special">define</span> (<span class="func">closurize-main!</span> <span class="var">o</span>)
  (<span class="syntax">let</span> ((<span class="var">index</span> (<span class="func">length</span> (<span class="func">Flattened-Program-definitions</span> <span class="var">o</span>))))
    (<span class="func">set-Flattened-Program-definitions!</span>
     <span class="var">o</span> (<span class="func">cons</span> (<span class="func">make-Function-Definition</span>
              <span class="hash">'()</span> (<span class="func">Flattened-Program-form</span> <span class="var">o</span>) <span class="hash">'()</span> <span class="var">index</span> )
             (<span class="func">Flattened-Program-definitions</span> <span class="var">o</span>) ) )
    (<span class="func">set-Flattened-Program-form!</span>
     <span class="var">o</span> (<span class="func">make-Regular-Application</span>
        (<span class="func">make-Closure-Creation</span> <span class="var">index</span> <span class="hash">'()</span> (<span class="func">make-No-Free</span>))
        (<span class="func">make-No-Argument</span>) ) )
    <span class="var">o</span> ) )</pre>


<h2 id="cc/sect:tmp"><span class="wrap"><span class="seq">10.6.</span><span class="title">Собираем временные переменные</span></span></h2>

<p>У автора всегда есть решительное преимущество перед читателем в том, что он
знает, что хочет получить, а вы пока ещё не знаете, что получится в результате.
В надежде на оригинальность, выражения Scheme было решено переводить
в выражения Си. Это выглядит немного эксцентричным, так как язык Си вообще-то
построен вокруг инструкций (statements), а не выражений (expressions), но такое
представление позволяет сохранить структуру Scheme в получаемой на выходе
программе. Правда, в этом случае возникает проблема с переводом узлов типа
<code><span class="class">Fix-Let</span></code>, так как в языке Си нельзя
создавать локальные переменные внутри выражений<a class="footref" href="zz_footnotes.html#foot10.2"><sup>2</sup></a>, только с помощью
отдельных инструкций. Поэтому мы вынуждены будем пробежаться по всем
<code><span class="class">Fix-Let</span></code> и провести учёт всех локальных переменных, вводимых ими, чтобы
впоследствии корректно их объявить.</p>

<p>Естественно, для этого выполняется ещё один проход по коду. Задачей данного
прохода будет сбор всех локальных переменных форм
<code><span class="class">Fix-Let</span></code> в одном месте,
а также их переименование для предотвращения коллизий. Функции, имеющие
временные локальные переменные, мы будем представлять подклассом
<code><span class="class">Function-Definition</span></code>,
называемым <code><span class="class">With-Temp-Function-Definition</span></code>.</p>


<!--\indexC{With-Temp-Function-Definition}-->
<pre>(<span class="syntax">define-class</span> <span class="class">With-Temp-Function-Definition</span> <span class="class">Function-Definition</span>
  ( <span class="var">temporaries</span> ) )</pre>

<p>Функция <code><span class="func">gather-temporaries!</span></code> реализует преобразование. Она полагается на
обобщённую функцию <code><span class="func">collect-temporaries!</span></code>, работающую в паре с обходчиком.
Вторым аргументом данной функции является объект, куда она будет складывать
обнаруженные переменные, а третий хранит список соответствий старых имён новым,
необходимый для выполнения переименований.</p>

<!--\indexC{gather-temporaries"!}-->
<!--\indexC{collect-temporaries"!}-->
<pre>(<span class="special">define</span> (<span class="func">gather-temporaries!</span> <span class="var">o</span>)
  (<span class="func">set-Flattened-Program-definitions!</span>
   <span class="var">o</span> (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">def</span>)
            (<span class="syntax">let</span> ((<span class="var">flatfun</span> (<span class="func">make-With-Temp-Function-Definition</span>
                            (<span class="func">Function-Definition-variables</span> <span class="var">def</span>)
                            (<span class="func">Function-Definition-body</span> <span class="var">def</span>)
                            (<span class="func">Function-Definition-free</span> <span class="var">def</span>)
                            (<span class="func">Function-Definition-index</span> <span class="var">def</span>)
                            <span class="hash">'()</span> )))
              (<span class="func">collect-temporaries!</span> <span class="var">flatfun</span> <span class="var">flatfun</span> <span class="hash">'()</span>) ) )
          (<span class="func">Flattened-Program-definitions</span> <span class="var">o</span>) ) )
  <span class="var">o</span> )

(<span class="syntax">define-generic</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Program</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="func">update-walk!</span> <span class="var">collect-temporaries!</span> <span class="var">o</span> <span class="var">flatfun</span> <span class="var">r</span>) )</pre>

<p>Для завершения преобразования остаётся определить три новых метода. Локальные
переменные при необходимости могут переименовываться, то же самое касается и
переменных в коробках:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Local-Reference</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="syntax">let*</span> ((<span class="var">variable</span> (<span class="func">Local-Reference-variable</span> <span class="var">o</span>))
         (<span class="var">v</span> (<span class="func">assq</span> <span class="var">variable</span> <span class="var">r</span>)) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">v</span>) (<span class="func">make-Local-Reference</span> (<span class="func">cdr</span> <span class="var">v</span>))
                  <span class="var">o</span> ) ) )

(<span class="syntax">define-method</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Box-Creation</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="syntax">let*</span> ((<span class="var">variable</span> (<span class="func">Box-Creation-variable</span> <span class="var">o</span>))
         (<span class="var">v</span> (<span class="func">assq</span> <span class="var">variable</span> <span class="var">r</span>)) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">v</span>) (<span class="func">make-Box-Creation</span> (<span class="func">cdr</span> <span class="var">v</span>))
                  <span class="var">o</span> ) ) )</pre>

<p>Самый сложный метод, конечно же, будет для <code><span class="class">Fix-Let</span></code>. Сначала он рекурсивно
вызывается для всех её аргументов, после чего переименовывает локальные
переменные с помощью функции <code><span class="func">new-renamed-variable</span></code>. Затем эти новые
переменные добавляются в определение обрабатываемой формы, а
<code><span class="func">collect-temporaries!</span></code> ещё раз рекурсивно вызывается уже для её тела,
помещённого в обновлённое окружение.</p>

<!--\indexC{adjoin-temporary-variables"!}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Fix-Let</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="func">set-Fix-Let-arguments!</span>
   <span class="var">o</span> (<span class="func">collect-temporaries!</span> (<span class="func">Fix-Let-arguments</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">r</span>) )
  (<span class="syntax">let*</span> ((<span class="var">newvars</span> (<span class="func">map</span> <span class="var">new-renamed-variable</span> (<span class="func">Fix-Let-variables</span> <span class="var">o</span>)))
         (<span class="var">newr</span> (<span class="func">append</span> (<span class="func">map</span> <span class="var">cons</span> (<span class="func">Fix-Let-variables</span> <span class="var">o</span>) <span class="var">newvars</span>) <span class="var">r</span>)) )
    (<span class="func">adjoin-temporary-variables!</span> <span class="var">flatfun</span> <span class="var">newvars</span>)
    (<span class="func">set-Fix-Let-variables!</span> <span class="var">o</span> <span class="var">newvars</span>)
    (<span class="func">set-Fix-Let-body!</span>
     <span class="var">o</span> (<span class="func">collect-temporaries!</span> (<span class="func">Fix-Let-body</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">newr</span>) )
    <span class="var">o</span> ) )

(<span class="special">define</span> (<span class="func">adjoin-temporary-variables!</span> <span class="var">flatfun</span> <span class="var">newvars</span>)
  (<span class="syntax">let</span> <span class="func">adjoin</span> ((<span class="var">temps</span> (<span class="func">With-Temp-Function-Definition-temporaries</span>
                       <span class="var">flatfun</span> ))
               (<span class="var">vars</span> <span class="var">newvars</span>) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">vars</span>)
        (<span class="special">if</span> (<span class="func">memq</span> (<span class="func">car</span> <span class="var">vars</span>) <span class="var">temps</span>)
            (<span class="func">adjoin</span> <span class="var">temps</span> (<span class="func">cdr</span> <span class="var">vars</span>))
            (<span class="func">adjoin</span> (<span class="func">cons</span> (<span class="func">car</span> <span class="var">vars</span>) <span class="var">temps</span>) (<span class="func">cdr</span> <span class="var">vars</span>)) )
        (<span class="func">set-With-Temp-Function-Definition-temporaries!</span>
         <span class="var">flatfun</span> <span class="var">temps</span> ) ) ) )</pre>

<p>Переименованные переменные выделяются в собственный подкласс. Ещё нам
потребуется счётчик для обеспечения уникальности их имён.</p>

<!--\indexC{Renamed-Local-Variable}-->
<!--\indexC{renaming-variable-counter}-->
<!--\indexC{new-renamed-variable}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Renamed-Local-Variable</span> <span class="class">Variable</span> (<span class="var">index</span>))

(<span class="special">define</span> <span class="var">renaming-variable-counter</span> <span class="num">0</span>)

(<span class="syntax">define-generic</span> (<span class="func">new-renamed-variable</span> (<span class="var">variable</span>)))

(<span class="syntax">define-method</span> (<span class="func">new-renamed-variable</span> (<span class="var">variable</span> <span class="class">Local-Variable</span>))
  (<span class="special">set!</span> <span class="var">renaming-variable-counter</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">renaming-variable-counter</span>))
  (<span class="func">make-Renamed-Local-Variable</span>
   (<span class="func">Variable-name</span> <span class="var">variable</span>) <span class="var">renaming-variable-counter</span> ) )</pre>


<h2 id="cc/sect:pause"><span class="wrap"><span class="seq">10.7.</span><span class="title">Передышка</span></span></h2>

<p>Следующая программа на Scheme является финальным результатом метаморфоз,
произошедших с показанным в самом начале главы примером. Итого:</p>

<ol>
  <li>Изменяемые переменные разложены по коробками.</li>
  <li>Вложенные функции не используются.</li>
  <li>Все цитаты и определения функций вынесены наверх.</li>
  <li>Временные переменные создаются явно.</li>
</ol>

<pre>(<span class="special">define</span> <span class="var">quote_5</span> '<span class="var">foo</span>)                    <span class="comment">; собранные цитаты</span>
(<span class="syntax">define-class</span> <span class="class">Closure_0</span> <span class="class">Object</span> ())       <span class="comment">; абстракция <code>(<span class="special">lambda</span> (<span class="var">f</span>) ...)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_0</span>) <span class="var">f</span>)
  (<span class="special">begin</span>
    (<span class="special">set!</span> <span class="var">index</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">index</span>))
    (<span class="func">invoke</span> <span class="var">f</span> <span class="var">index</span>) ) )                 <span class="comment">; вызов функции</span>
(<span class="syntax">define-class</span> <span class="class">Closure_1</span> <span class="class">Object</span> (<span class="var">i</span>))      <span class="comment">; абстракция <code>(<span class="special">lambda</span> (<span class="var">x</span>) ...)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_1</span>) . <span class="var">x</span>)
  (<span class="func">cons</span> (<span class="func">Closure_1-i</span> <span class="var">self</span>)               <span class="comment">; свободная переменная <code><span class="var">i</span></code></span>
        <span class="var">x</span> ) )
(<span class="syntax">define-class</span> <span class="class">Closure_2</span> <span class="class">Object</span> ())       <span class="comment">; абстракция <code>(<span class="special">lambda</span> (<span class="var">i</span>) ...)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_2</span>) <span class="var">i</span>)
  (<span class="func">make-Closure_1</span> <span class="var">i</span>) )                   <span class="comment">; создание замыкания</span>
(<span class="syntax">define-class</span> <span class="class">Closure_3</span> <span class="class">Object</span> ())       <span class="comment">; абстракция <code>(<span class="special">lambda</span> () <span class="math"><span class="ord var">π</span></span>)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_3</span>))
  ((<span class="special">lambda</span> (<span class="var">cnter_1</span> <span class="var">tmp_2</span>)               <span class="comment">; переименование в действии</span>
     (<span class="special">set!</span> <span class="var">index</span> <span class="num">1</span>)
     (<span class="special">set!</span> <span class="var">cnter_1</span> (<span class="func">make-Closure_0</span>))     <span class="comment">; инициализация</span>
     (<span class="special">set!</span> <span class="var">tmp_2</span> (<span class="func">cons</span> <span class="var">quote_5</span> <span class="hash">'()</span>))     <span class="comment">; <span class="quad-stub" style="width: 1em"></span>временных переменных</span>
     (<span class="special">set!</span> <span class="var">tmp_2</span> (<span class="func">make-box</span> <span class="var">tmp_2</span>))       <span class="comment">; укладываем в коробку</span>
     (<span class="func">box-write!</span> <span class="var">tmp_2</span>                   <span class="comment">; <span class="quad-stub" style="width: 1em"></span>изменяемую переменную</span>
                 (<span class="func">invoke</span> <span class="var">cnter_1</span> (<span class="func">make-Closure_2</span>)) )
     (<span class="special">if</span> <span class="var">cnter_1</span>
         (<span class="func">invoke</span> <span class="var">cnter_1</span> (<span class="func">box-read</span> <span class="var">tmp_2</span>))
         <span class="var">index</span> ) ) ) )
(<span class="func">invoke</span> (<span class="func">make-Closure_3</span>))                <span class="comment">; точка входа</span></pre>


<h2 id="cc/sect:gen"><span class="wrap"><span class="seq">10.8.</span><span class="title">Генерируем Си</span></span></h2>

<p>Наконец, мы готовы выполнить мистический обряд кодогенерации. Осталось лишь
дать несколько предварительных пояснений. Ваш покорный слуга не мнит себя
мировым экспертом по языку Си и, в сущности, обязан своими знаниями тщательному
изучению книг вроде <span class="cite">[<a href="z1_bibliography.html#iso90">ISO90</a>,
<a href="z1_bibliography.html#hs91">HS91</a>,
<a href="z1_bibliography.html#cek+89">CEK<sup>+</sup>89</a>]</span>.
Предполагается, что вы имеете
некоторое представление об этом языке, но не обременены предрассудками
о единственно верном способе его использования.</p>

<p>Абстрактное синтаксическое дерево полностью готово и только и ждёт, чтобы его
скомпилировали, а вернее сказать, <em>распечатали</em> на языке Си. Благодаря
высокоуровневому представлению программ, генерация кода не представляет особых
сложностей. Функция <code><span class="func">compile-&gt;C</span></code> принимает S-выражение, выполняет над ним
рассмотренные ранее преобразования и в конце концов выводит в порт <code><span class="var">out</span></code>
опрятный исходный код на Си.</p>

<!--\indexC{compile->C}-->
<!--\indexC{generate-C-program}-->
<pre>(<span class="special">define</span> (<span class="func">compile-&gt;C</span> <span class="var">e</span> <span class="var">out</span>)
  (<span class="special">set!</span> <span class="var">g.current</span> <span class="hash">'()</span>)
  (<span class="syntax">let</span> ((<span class="var">prg</span> (<span class="func">extract-things!</span> (<span class="func">lift!</span> (<span class="func">Sexp-&gt;object</span> <span class="var">e</span>)))))
    (<span class="func">gather-temporaries!</span> (<span class="func">closurize-main!</span> <span class="var">prg</span>))
    (<span class="func">generate-C-program</span> <span class="var">out</span> <span class="var">e</span> <span class="var">prg</span>) ) )

(<span class="special">define</span> (<span class="func">generate-C-program</span> <span class="var">out</span> <span class="var">e</span> <span class="var">prg</span>)
  (<span class="func">generate-header</span>             <span class="var">out</span> <span class="var">e</span>)
  (<span class="func">generate-global-environment</span> <span class="var">out</span> <span class="var">g.current</span>)
  (<span class="func">generate-quotations</span>         <span class="var">out</span> (<span class="func">Flattened-Program-quotations</span> <span class="var">prg</span>))
  (<span class="func">generate-functions</span>          <span class="var">out</span> (<span class="func">Flattened-Program-definitions</span> <span class="var">prg</span>))
  (<span class="func">generate-main</span>               <span class="var">out</span> (<span class="func">Flattened-Program-form</span> <span class="var">prg</span>))
  (<span class="func">generate-trailer</span>            <span class="var">out</span>)
  <span class="var">prg</span> )</pre>

<p>Как и любая программа на Си, а в более широком смысле, как и любое животное,
получаемая программа состоит из головы, тела и хвоста. В голове находятся
желания, умения и мысли, поэтому там размещается комментарий с исходным
выражением на Scheme (выводимым нестандартной функцией <code><span class="func">pp</span></code>), а также
директива препроцессора, подключающая к программе заголовочный файл
<code>scheme.h</code>, где будут находиться все необходимые ей определения. Для вывода
строк программы здесь и далее используется ещё одна нестандартная функция
<code><span class="func">format</span></code>.</p>

<!--\indexC{generate-header}-->
<!--\indexC{generate-trailer}-->
<pre>(<span class="special">define</span> (<span class="func">generate-header</span> <span class="var">out</span> <span class="var">e</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"/* Compiler to C $Revision: 4.1$<span class="pp">~%</span>"</span>)
  (<span class="func">pp</span> <span class="var">e</span> <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>*/<span class="pp">~%</span><span class="pp">~%</span>#include <span class="esc">\"</span>scheme.h<span class="esc">\"</span><span class="pp">~%</span>"</span>) )

(<span class="special">define</span> (<span class="func">generate-trailer</span> <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* End of generated code */<span class="pp">~%</span>"</span>) )</pre>

<p>В хвосте, как видите, нет ничего интересного; всё самое важное находится в теле
программы. Результат компиляции нашего подопытного примера приведён в разделе <a href="#cc/gen/init/src:result">10.8.8</a>. Возможно, вам захочется взглянуть на
него, прежде чем переходить к изучению анатомии генератора.</p>


<h3 id="cc/gen/ssect:global"><span class="wrap"><span class="seq">10.8.1.</span><span class="title">Глобальное окружение</span></span></h3>

<p>Глобальные переменные, используемые программой, можно разделить на две группы:
предопределённые переменные, вроде <code><span class="func">car</span></code> или
<code><span class="func">+</span></code>, и изменяемые глобальные
переменные. Считается, что предопределённые переменные неизменяемы, а их
значения физически располагаются в специальной библиотеке, которая будет
подключена при компоновке. В отличие от них, окружение глобальных изменяемых
переменных должно быть сформировано именно у нас в программе. Для этого мы
используем информацию, которую собрали в
<code><span class="var">g.current</span></code> во время предобработки.</p>

<p>Используемый подход к генерации строится на предположении, что программа
компилируется целиком, а не отдельными модулями. (Раздельная компиляция, как
вы помните, вызывает множество специфичных затруднений.
<span class="see">[см. раздел <a href="ch07_compilation.html#compilation/sect:separate">7.10</a>]</span>
Мы не будем их рассматривать повторно, дабы не раздувать эту главу в пару раз.)</p>

<p>Для облегчения понимания и повышения читабельности кода, генератор щедро
использует макросы Си. Например, глобальные переменные объявляются макросом
<code class="c"><span class="pre">SCM_DefineGlobalVariable</span></code>.
Вторым аргументом этот макрос принимает строку
с изначальным именем<a class="footref" href="zz_footnotes.html#foot10.3"><sup>3</sup></a> переменной на Scheme. Это может
оказаться полезным при отладке.</p>

<!--\indexC{generate-global-environment}-->
<!--\indexC{generate-global-variable}-->
<pre>(<span class="special">define</span> (<span class="func">generate-global-environment</span> <span class="var">out</span> <span class="var">gv*</span>)
  (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">gv*</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* Global environment: */<span class="pp">~%</span>"</span>)
    (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">gv</span>) (<span class="func">generate-global-variable</span> <span class="var">out</span> <span class="var">gv</span>))
              <span class="var">gv*</span> ) ) )

(<span class="special">define</span> (<span class="func">generate-global-variable</span> <span class="var">out</span> <span class="var">gv</span>)
  (<span class="syntax">let</span> ((<span class="func">name</span> (<span class="func">Global-Variable-name</span> <span class="var">gv</span>)))
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DefineGlobalVariable(<span class="pp">~A</span>,<span class="esc">\"</span><span class="pp">~A</span><span class="esc">\"</span>);<span class="pp">~%</span>"</span>
            (<span class="func">IdScheme-&gt;IdC</span> <span class="var">name</span>) <span class="var">name</span> ) ) )</pre>

<!--\indexR{идентификаторы в Си}-->
<p>Вот мы и встретились с первым затруднением: не все идентификаторы Scheme
являются допустимыми в Си. Функция <code><span class="func">IdScheme-&gt;IdC</span></code> занимается преобразованием
идентификаторов Scheme в корректные идентификаторы Си. Она должна избавиться от
всех мешающих символов, оставив при этом имя более-менее понятным, чтобы можно
было догадаться о его исходном написании. Естественно, вариантов такого
преобразования огромное множество, но мы просто заменим все недопустимые символы
допустимыми, после чего убедимся в уникальности полученного имени. Код, который
это делает, не то, чтобы особо интересен, но в самом начале книги у нас был
уговор: ничего не утаивать. Переменная <code><span class="var">Scheme-&gt;C-names-mapping</span></code> хранит
словарик имён, изначально содержащий несколько сложных случаев.</p>

<!--\indexC{IdScheme->IdC}-->
<pre>(<span class="special">define</span> <span class="var">Scheme-&gt;C-names-mapping</span>
  '( (<span class="var">*</span>        . <span class="string">"TIMES"</span>)
     (<span class="var">&lt;</span>        . <span class="string">"LESSP"</span>)
     (<span class="var">pair?</span>    . <span class="string">"CONSP"</span>)
     (<span class="var">set-cdr!</span> . <span class="string">"RPLACD"</span>)
     <span class="comment">; и другие</span>
     ) )
(<span class="special">define</span> (<span class="func">IdScheme-&gt;IdC</span> <span class="var">name</span>)
  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">assq</span> <span class="var">name</span> <span class="var">Scheme-&gt;C-names-mapping</span>)))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">v</span>) (<span class="func">cdr</span> <span class="var">v</span>)
        (<span class="syntax">let</span> ((<span class="var">str</span> (<span class="func">symbol-&gt;string</span> <span class="var">name</span>)))
          (<span class="syntax">let</span> <span class="func">retry</span> ((<span class="var">Cname</span> (<span class="func">compute-Cname</span> <span class="var">str</span>)))
            (<span class="special">if</span> (<span class="func">Cname-clash?</span> <span class="var">Cname</span> <span class="var">Scheme-&gt;C-names-mapping</span>)
                (<span class="func">retry</span> (<span class="func">compute-another-Cname</span> <span class="var">str</span>))
                (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">Scheme-&gt;C-names-mapping</span>
                             (<span class="func">cons</span> (<span class="func">cons</span> <span class="var">name</span> <span class="var">Cname</span>)
                                   <span class="var">Scheme-&gt;C-names-mapping</span> ) )
                       <span class="var">Cname</span> ) ) ) ) ) ) )</pre>

<p>Обнаруженные конфликты имён разрешаются просто: добавлением уникального номера.</p>

<!--\indexC{Cname-clash?}-->
<!--\indexC{compute-Cname}-->
<pre>(<span class="special">define</span> (<span class="func">Cname-clash?</span> <span class="var">Cname</span> <span class="var">mapping</span>)
  (<span class="syntax">let</span> <span class="func">check</span> ((<span class="var">mapping</span> <span class="var">mapping</span>))
    (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">mapping</span>)
         (<span class="syntax">or</span> (<span class="func">string=?</span> <span class="var">Cname</span> (<span class="func">cdar</span> <span class="var">mapping</span>))
             (<span class="func">check</span> (<span class="func">cdr</span> <span class="var">mapping</span>)) ) ) ) )

(<span class="special">define</span> <span class="var">compute-another-Cname</span>
  (<span class="syntax">let</span> ((<span class="var">counter</span> <span class="num">1</span>))
    (<span class="special">lambda</span> (<span class="var">str</span>)
      (<span class="special">set!</span> <span class="var">counter</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">counter</span>))
      (<span class="func">compute-Cname</span> (<span class="func">format</span> <span class="hash">#f</span> <span class="string">"<span class="pp">~A</span>_<span class="pp">~A</span>"</span> <span class="var">str</span> <span class="var">counter</span>)) ) ) )

(<span class="special">define</span> (<span class="func">compute-Cname</span> <span class="var">str</span>)
  (<span class="special">define</span> (<span class="func">mapcan</span> <span class="var">f</span> <span class="var">l</span>)
    (<span class="special">if</span> (<span class="func">not</span> (<span class="func">pair?</span> <span class="var">l</span>)) <span class="hash">'()</span>
        (<span class="func">append</span> (<span class="func">f</span> (<span class="func">car</span> <span class="var">l</span>)) (<span class="func">mapcan</span> <span class="var">f</span> (<span class="func">cdr</span> <span class="var">l</span>))) ) )
  (<span class="special">define</span> (<span class="func">convert-char</span> <span class="var">char</span>)
    (<span class="syntax">case</span> <span class="var">char</span>
      ((<span class="hash">#\_</span>)             '(<span class="hash">#\_</span> <span class="hash">#\_</span>))
      ((<span class="hash">#\?</span>)             '(<span class="hash">#\p</span>))
      ((<span class="hash">#\!</span>)             '(<span class="hash">#\i</span>))
      ((<span class="hash">#\&lt;</span>)             '(<span class="hash">#\l</span>))
      ((<span class="hash">#\></span>)             '(<span class="hash">#\g</span>))
      ((<span class="hash">#\=</span>)             '(<span class="hash">#\e</span>))
      ((<span class="hash">#\-</span> <span class="hash">#\/</span> <span class="hash">#\*</span> <span class="hash">#\:</span>) <span class="hash">'()</span>)
      (<span class="syntax">else</span>              (<span class="func">list</span> <span class="var">char</span>)) ) )
  (<span class="syntax">let</span> ((<span class="var">cname</span> (<span class="func">mapcan</span> <span class="var">convert-char</span> (<span class="func">string-&gt;list</span> <span class="var">str</span>))))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">cname</span>)
        (<span class="func">list-&gt;string</span> <span class="var">cname</span>)
        <span class="string">"weird"</span> ) ) )</pre>

<p>Единичные подчёркивания гарантированно не встречаются в генерируемых именах,
поэтому их можно спокойно использовать для именования разнообразных внутренних
переменных, не опасаясь коллизий с переменными исходной программы. Рассмотренное
преобразование, конечно, не справится с чем-то вроде <code><span class="var">1+</span></code>,
но кого волнуют имена, запрещённые стандартом Scheme?</p>


<h3 id="cc/gen/ssect:quote"><span class="wrap"><span class="seq">10.8.2.</span><span class="title">Цитаты</span></span></h3>

<!--\indexR{цитаты!склеивание}-->
<!--\indexR{склеивание цитат}-->
<p>Цитаты должны переводиться в структуры данных Си, чтобы ими можно было
пользоваться в программе. Мы поступим рационально, переводя их сразу в готовые
определения структур данных, а не в код, который их создаст во время исполнения.
Также мы оптимизируем занимаемый цитатами объём памяти, выделив в них и
определив отдельно все общие подвыражения.</p>

<p>Функция <code><span class="func">generate-quotations</span></code> назначена ответственной за выполнение данных
обещаний. Для простоты мы не будем реализовывать поддержку векторов, длинной
арифметики и всех нецелых чисел.</p>

<!--\indexC{generate-quotations}-->
<pre>(<span class="special">define</span> (<span class="func">generate-quotations</span> <span class="var">out</span> <span class="var">qv*</span>)
  (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">qv*</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* Quotations: */<span class="pp">~%</span>"</span>)
    (<span class="func">scan-quotations</span> <span class="var">out</span> <span class="var">qv*</span> (<span class="func">length</span> <span class="var">qv*</span>) <span class="hash">'()</span>) ) )</pre>

<p>Настоящую работу выполняет <code><span class="func">scan-quotations</span></code>: просматривает собранные
цитаты, представляемые объектами класса <code><span class="class">Quotation-Variable</span></code>, и генерирует
соответствующий код. Она также старается создавать как можно меньше
промежуточных цитат, разделяя максимум информации между ними. Предикат
<code><span class="func">already-seen-value?</span></code> подсказывает ей, когда такое возможно.</p>

<!--\indexC{scan-quotations}-->
<!--\indexC{already-seen-value"?}-->
<pre>(<span class="special">define</span> (<span class="func">scan-quotations</span> <span class="var">out</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>)
  (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">qv*</span>)
    (<span class="syntax">let*</span> ((<span class="var">qv</span>       (<span class="func">car</span> <span class="var">qv*</span>))
           (<span class="var">value</span>    (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>))
           (<span class="var">other-qv</span> (<span class="func">already-seen-value?</span> <span class="var">value</span> <span class="var">results</span>)) )
      (<span class="syntax">cond</span>
        (<span class="var">other-qv</span>
          (<span class="func">generate-quotation-alias</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">other-qv</span>)
          (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>) <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>)) )
        ((<span class="func">C-value?</span> <span class="var">value</span>)
          (<span class="func">generate-C-value</span> <span class="var">out</span> <span class="var">qv</span>)
          (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>) <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>)) )
        ((<span class="func">symbol?</span> <span class="var">value</span>) (<span class="func">scan-symbol</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>) )
        ((<span class="func">pair?</span> <span class="var">value</span>)   (<span class="func">scan-pair</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>) )
        (<span class="syntax">else</span> (<span class="func">generate-error</span> <span class="string">"Unsupported constant"</span> <span class="var">qv</span>)) ) ) ) )

(<span class="special">define</span> (<span class="func">already-seen-value?</span> <span class="var">value</span> <span class="var">qv*</span>)
  (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">qv*</span>)
       (<span class="special">if</span> (<span class="func">equal?</span> <span class="var">value</span> (<span class="func">Quotation-Variable-value</span> (<span class="func">car</span> <span class="var">qv*</span>)))
           (<span class="func">car</span> <span class="var">qv*</span>)
           (<span class="func">already-seen-value?</span> <span class="var">value</span> (<span class="func">cdr</span> <span class="var">qv*</span>)) ) ) )</pre>

<p>Имена всех цитат в генерируемом коде будут начинаться на <code>thing</code>. Если
в программе нашлась пара эквивалентных цитат, то достаточно одну из них везде
заменить другой. Функция <code><span class="func">generate-quotation-alias</span></code> перекладывает эту работу
на препроцессор Си. Чтобы облегчить чтение сгенерированного кода, рядом
помещается комментарий со значением цитаты.</p>

<!--\indexC{generate-quotation-alias}-->
<pre>(<span class="special">define</span> (<span class="func">generate-quotation-alias</span> <span class="var">out</span> <span class="var">qv1</span> <span class="var">qv2</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> thing<span class="pp">~A</span> /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv1</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv2</span>)
          (<span class="func">Quotation-Variable-value</span> <span class="var">qv2</span>) ) )</pre>

<!--\indexR{значения!атомарные}-->
<p>Предикат <code><span class="func">C-value?</span></code> проверяет, можно ли данную цитату прямо перевести на Си.
Если да, то она передаётся функции <code><span class="func">generate-C-value</span></code>, чтобы она выполнила
этот перевод. Непосредственными значениями являются пустой список, булевы
значения, (короткие) целые числа и строки. Все эти значения Scheme можно сразу
представить соответствующими значениями Си. Предположим на время, что у нас уже
есть необходимые макросы, раскрывающиеся в правильные описания строк, чисел,
истины, лжи и пустого списка. Все они начинаются на <code>SCM_</code>. Без сомнения,
гуру Си также заметят, что наши числа являются знаковыми 31-битными
в дополнительном коде.</p>

<!--\indexC{C-value?}-->
<!--\indexC{generate-C-value}-->
<pre>(<span class="special">define</span> <span class="var">*maximal-fixnum*</span> <span class="num">+1073741823</span>)
(<span class="special">define</span> <span class="var">*minimal-fixnum*</span> <span class="num">-1073741824</span>)

(<span class="special">define</span> (<span class="func">C-value?</span> <span class="var">value</span>)
  (<span class="syntax">or</span> (<span class="func">null?</span> <span class="var">value</span>)
      (<span class="func">boolean?</span> <span class="var">value</span>)
      (<span class="syntax">and</span> (<span class="func">integer?</span> <span class="var">value</span>)
           (<span class="func">&lt;=</span> <span class="var">*minimal-fixnum*</span> <span class="var">value</span> <span class="var">*maximal-fixnum*</span>) )
      (<span class="func">string?</span> <span class="var">value</span>) ) )

(<span class="special">define</span> (<span class="func">generate-C-value</span> <span class="var">out</span> <span class="var">qv</span>)
  (<span class="syntax">let</span> ((<span class="var">value</span> (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>))
        (<span class="var">index</span> (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)) )
    (<span class="syntax">cond</span>
      ((<span class="func">null?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_nil /* () */<span class="pp">~%</span>"</span>
                <span class="var">index</span> ) )
      ((<span class="func">boolean?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> <span class="pp">~A</span> /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
                <span class="var">index</span> (<span class="special">if</span> <span class="var">value</span> <span class="string">"SCM_true"</span> <span class="string">"SCM_false"</span>) <span class="var">value</span> ) )
      ((<span class="func">integer?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_Int2Fixnum(<span class="pp">~A</span>)<span class="pp">~%</span>"</span>
                <span class="var">index</span> <span class="var">value</span> ) )
      ((<span class="func">string?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DefineString(thing<span class="pp">~A</span>_object, <span class="esc">\"</span><span class="pp">~A</span><span class="esc">\"</span>);<span class="pp">~%</span>"</span>
                <span class="var">index</span> <span class="var">value</span> )
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_Wrap(&amp;thing<span class="pp">~A</span>_object)<span class="pp">~%</span>"</span>
                <span class="var">index</span> <span class="var">index</span> ) ) ) ) )</pre>

<!--\indexR{значения!составные}-->
<p>Если цитируются составные значения (точечные пары или символы), то вначале они
разбиваются на части, чтобы по возможности повторно использовать предыдущие
определения. Символы состоят из знаков, образующих строку с их именем. Строки
создаются перед символами.</p>

<!--\indexC{scan-symbol}-->
<!--\indexC{generate-symbol}-->
<pre>(<span class="special">define</span> (<span class="func">scan-symbol</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>)
  (<span class="syntax">let*</span> ((<span class="var">qv</span> (<span class="func">car</span> <span class="var">qv*</span>))
         (<span class="var">str</span> (<span class="func">symbol->string</span> <span class="var">value</span>))
         (<span class="var">strqv</span> (<span class="func">already-seen-value?</span> <span class="var">str</span> <span class="var">results</span>)) )
    (<span class="syntax">cond</span> (<span class="var">strqv</span>
            (<span class="func">generate-symbol</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">strqv</span>)
            (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>) <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>)) )
          (<span class="syntax">else</span>
            (<span class="syntax">let</span> ((<span class="var">newqv</span> (<span class="func">make-Quotation-Variable</span> <span class="var">i</span> <span class="var">str</span>)))
              (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cons</span> <span class="var">newqv</span> <span class="var">qv*</span>)
                               (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>) <span class="var">results</span> ) ) ) ) ) )

(<span class="special">define</span> (<span class="func">generate-symbol</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">strqv</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DefineSymbol(thing<span class="pp">~A</span>_object, thing<span class="pp">~A</span>); /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">strqv</span>)
          (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>) )
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_Wrap(&amp;thing<span class="pp">~A</span>_object)<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>) ) )</pre>

<p>Точечные пары состоят из двух частей — <code><span class="var">car</span></code> и <code><span class="var">cdr</span></code>, —
обрабатываемых последовательно. При этом учитывается, что их значения могут
оказаться эквивалентными как ранее определённым цитатам, так и друг другу. Их
вывод реализован в стиле передачи продолжений.</p>

<!--\indexC{scan-pair}-->
<!--\indexC{generate-pair}-->
<pre>(<span class="special">define</span> (<span class="func">scan-pair</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>)
  (<span class="syntax">let*</span> ((<span class="var">qv</span>  (<span class="func">car</span> <span class="var">qv*</span>))
         (<span class="var">d</span>   (<span class="func">cdr</span> <span class="var">value</span>))
         (<span class="var">dqv</span> (<span class="func">already-seen-value?</span> <span class="var">d</span> <span class="var">results</span>)) )
    (<span class="special">if</span> <span class="var">dqv</span>
        (<span class="syntax">let*</span> ((<span class="var">a</span>   (<span class="func">car</span> <span class="var">value</span>))
               (<span class="var">aqv</span> (<span class="func">already-seen-value?</span> <span class="var">a</span> <span class="var">results</span>)) )
          (<span class="special">if</span> <span class="var">aqv</span>
              (<span class="special">begin</span>
                (<span class="func">generate-pair</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">aqv</span> <span class="var">dqv</span>)
                (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>)
                                 <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>) ) )
              (<span class="syntax">let</span> ((<span class="var">newaqv</span> (<span class="func">make-Quotation-Variable</span> <span class="var">i</span> <span class="var">a</span>)))
                (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cons</span> <span class="var">newaqv</span> <span class="var">qv*</span>)
                                 (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>) <span class="var">results</span> ) ) ) )
        (<span class="syntax">let</span> ((<span class="var">newdqv</span> (<span class="func">make-Quotation-Variable</span> <span class="var">i</span> <span class="var">d</span>)))
          (<span class="func">scan-quotations</span>
           <span class="var">out</span> (<span class="func">cons</span> <span class="var">newdqv</span> <span class="var">qv*</span>) (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>) <span class="var">results</span> ) ) ) ) )

(<span class="special">define</span> (<span class="func">generate-pair</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">aqv</span> <span class="var">dqv</span>)
  (<span class="func">format</span> <span class="var">out</span>
          <span class="string">"SCM_DefinePair(thing<span class="pp">~A</span>_object, thing<span class="pp">~A</span>, thing<span class="pp">~A</span>); /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">aqv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">dqv</span>)
          (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>) )
  (<span class="func">format</span> <span class="var">out</span>
          <span class="string">"#define thing<span class="pp">~A</span> SCM_Wrap(&amp;thing<span class="pp">~A</span>_object)<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>) ) )</pre>

<p>Теперь давайте рассмотрим пример, а затем поговорим обо всех этих загадочных
макросах.</p>


<h3 id="cc/gen/ssect:decl"><span class="wrap"><span class="seq">10.8.3.</span><span class="title">Объявление данных</span></span></h3>

<p>Возьмём простую программу, состоящую из единственной цитаты: <code>(<span class="special">quote</span> ((<span class="hash">#F</span>
<span class="hash">#T</span>) (<span class="var">FOO</span> . <span class="string">"FOO"</span>) <span class="num">33</span> <span class="var">FOO</span> . <span class="string">"FOO"</span>))</code>. Её компиляция выдаёт следующий результат,
слегка приправленный комментариями. Наслаждайтесь!</p>

<div class="snippet">
<pre class="c"><span class="comment">/* Compiler to C $Revision: 4.1$
'((#F #T) (FOO . "FOO") 33 FOO . "FOO") */</span>

<span class="pre">#include</span> <span class="string">"scheme.h"</span>

<span class="comment">/* Quotations: */</span>
<span class="macro">SCM_DefineString</span>(<span class="var">thing4_object</span>, <span class="string">"FOO"</span>);
<span class="pre">#define</span> <span class="macro">thing4</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing4_object</span>)
<span class="macro">SCM_DefineSymbol</span>(<span class="var">thing5_object</span>, <span class="var">thing4</span>);        <span class="comment">/* FOO */</span>
<span class="pre">#define</span> <span class="macro">thing5</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing5_object</span>)
<span class="macro">SCM_DefinePair</span>(<span class="var">thing3_object</span>, <span class="macro">thing5</span>, <span class="macro">thing4</span>);  <span class="comment">/* (FOO . "FOO") */</span>
<span class="pre">#define</span> <span class="macro">thing3</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing3_object</span>)
<span class="pre">#define</span> <span class="macro">thing6</span> <span class="macro">SCM_Int2Fixnum</span>(33)
<span class="macro">SCM_DefinePair</span>(<span class="var">thing2_object</span>, <span class="macro">thing6</span>, <span class="macro">thing3</span>);  <span class="comment">/* (33 FOO . "FOO") */</span>
<span class="pre">#define</span> <span class="macro">thing2</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing2_object</span>)
<span class="macro">SCM_DefinePair</span>(<span class="var">thing1_object</span>, <span class="macro">thing3</span>, <span class="macro">thing2</span>);
                                  <span class="comment">/* ((FOO . "FOO") 33 FOO . "FOO") */</span>
<span class="pre">#define</span> <span class="macro">thing1</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing1_object</span>)
<span class="pre">#define</span> <span class="macro">thing9</span> <span class="macro">SCM_nil</span>                           <span class="comment">/* ()  */</span>
<span class="pre">#define</span> <span class="macro">thing10</span> <span class="macro">SCM_true</span>                         <span class="comment">/* #T  */</span>
<span class="macro">SCM_DefinePair</span>(<span class="var">thing8_object</span>, <span class="macro">thing10</span>, <span class="macro">thing9</span>);  <span class="comment">/* (#T) */</span>
<span class="pre">#define</span> <span class="macro">thing8</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing8_object</span>)
<span class="pre">#define</span> <span class="macro">thing11</span> <span class="macro">SCM_false</span>                        <span class="comment">/* #F */</span>
<span class="macro">SCM_DefinePair</span>(<span class="var">thing7_object</span>, <span class="macro">thing11</span>, <span class="macro">thing8</span>);  <span class="comment">/* (#F #T) */</span>
<span class="pre">#define</span> <span class="macro">thing7</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing7_object</span>)
<span class="macro">SCM_DefinePair</span>(<span class="var">thing0_object</span>, <span class="macro">thing7</span>, <span class="macro">thing1</span>);
                          <span class="comment">/* ((#F #T) (FOO . "FOO") 33 FOO . "FOO") */</span>
<span class="pre">#define</span> <span class="macro">thing0</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing0_object</span>)

<span class="comment">/* ... */</span></pre></div>

<p>Первым делом создаётся строка <code class="c"><span class="string">"FOO"</span></code>. Для этого используется макрос
<code class="c"><span class="macro">SCM_DefineString</span></code>. Первым аргументом он принимает имя нового объекта на Си.
Вторым — собственно строку. Похожим образом с помощью макроса
<code class="c"><span class="macro">SCM_DefineSymbol</span></code> создаётся символ. Первым аргументом идёт имя на Cи, за
ним — строка с именем на Scheme. Точечные пары создаются аналогично с помощью
макроса <code class="c"><span class="macro">SCM_DefinePair</span></code>: первым аргументом — имя на Си, вторым и третьим
— содержимое <code><span class="var">car</span></code> и <code><span class="var">cdr</span></code> соответственно.</p>

<p>Предопределённые объекты вроде булевых значений и пустого списка, конечно же,
не создаются каждый раз заново. Вместо этого используются напрямую их имена:
<code class="c"><span class="macro">SCM_true</span></code>, <code class="c"><span class="macro">SCM_false</span></code> и <code class="c"><span class="macro">SCM_nil</span></code>.</p>

<p>Позже <span class="see">[см. раздел <a href="#cc/sect:data">10.9</a>]</span> мы подробнее разберём представление в памяти
значений Scheme. Процесс компиляции слабо связан с используемой конкретной
реализацией структур данных. На данный момент достаточно знать лишь её
интерфейс: объекты инициализируются директивами вида <code class="c"><span class="macro">SCM_Define...</span></code>, а
ссылку на инициализированный объект можно получить с помощью <code class="c"><span class="macro">SCM_Wrap</span></code>.
Целые числа преобразуются в объекты Scheme макросом <code class="c"><span class="macro">SCM_Int2Fixnum</span></code>.
К любому объекту можно обратиться, использовав его имя, начинающееся на
<code class="c"><span class="var">thing</span></code>. Например, <code class="c"><span class="var">thing4</span></code> означает строку <code class="c"><span class="string">"FOO"</span></code>, а <code class="c"><span class="var">thing6</span></code> —
это число 33. Точнее, <code class="c"><span class="var">thing4</span></code> — это указатель на объект
<code class="c"><span class="var">thing4_object</span></code>, который уже хранит настоящую строку.</p>

<p>Строка <code class="c"><span class="string">"FOO"</span></code> общая для всех объектов: в выражении <code>(<span class="var">FOO</span> . <span class="string">"FOO"</span>)</code>
объекты <code class="c"><span class="var">thing4</span></code> и <code class="c"><span class="var">thing3</span></code> ссылаются на один и тот же
<code class="c"><span class="var">thing4_object</span></code>.</p>


<h3 id="cc/gen/ssect:exprs"><span class="wrap"><span class="seq">10.8.4.</span><span class="title">Компиляция выражений</span></span></h3>

<p>Главной задачей компилятора, конечно же, является перевод выражений Scheme
в выражения Си. Как было сказано ранее, мы намеренно преобразуем выражения
в аналогичные выражения, а не наборы инструкций с тем же смыслом. Поступив так,
мы определённо получим на выходе более понятный код, в котором будет лучше видна
структура исходной программы. Однако, несмотря на очевидную мудрость подобного
решения, оно поднимает пару непростых вопросов, так как идёт вразрез
с философией языка Си. В Си отдельные инструкции предпочтительнее выражений.
Не то, чтобы это было особой проблемой для компилятора — ему-то без разницы;
это будет проблемой для человека, который сядет отлаживать подобную программу.
Беда в том, что интерактивные отладчики вроде <code>gdb</code> обычно понимают пошаговый
режим исполнения как исполнение программы по инструкциям — а инструкции
в нашем случае будут отнюдь не маленькие. Если бы мы решили компилировать Scheme
в инструкции Си вместо выражений, то в итоге у нас получилось бы нечто похожее
на рассмотренный ранее компилятор в байт-код.
<span class="see">[см. <a href="ch07_compilation.html">7 главу</a>]</span></p>

<p>Компиляция выражений выполняется обобщённой функцией
<code><span class="func">-&gt;C</span></code>. Она принимает
два аргумента: исходное выражение и порт, куда следует записать результат. Так
как результат компиляции сразу же переносится в файл, то код необходимо
генерировать строго последовательно, без возвратов и исправлений задним числом,
за один проход.
<span class="see">[см. раздел <a href="ch07_compilation.html#compilation/lang-and-target/par:backtracking">7.2</a>]</span></p>

<!--\indexC*{c}{->C}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Program</span>) <span class="var">out</span>))</pre>

<p>В отличие от предыдущих трансформаций, в этот раз мы не будем использовать
обобщённый обходчик (так как у нас нет действия по умолчанию), а просто
перечислим методы обработки каждого типа узлов синтаксического дерева. Эти
методы довольно просты по своей структуре, так как им надо лишь правильно
выводить соответствующие инструкции Си.</p>

<p>Язык Си имеет весьма строгий синтаксис с чётко прописанными приоритетами,
ассоциативностью операций и т. д. Эти правила мало кто из программистов помнит
наизусть целиком, поэтому при малейших сомнениях все пользуются скобками. Мы же
возведём эту практику в абсолют и будем ставить их всегда. Что бы там
ни говорили сишники о плохом вкусе, но исходным языком сейчас является Лисп,
так что в программе должны быть скобочки. Много скобочек. Поэтому мы определим
специальный макрос, чтобы удобно их ставить:</p>

<!--\indexC{between-parentheses}-->
<pre>(<span class="special">define-syntax</span> <span class="var">between-parentheses</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">between-parentheses</span> <span class="var">out</span> . <span class="var">body</span>)
     (<span class="syntax">let</span> ((<span class="var">out</span> <span class="var">out</span>))
       (<span class="func">format</span> <span class="var">out</span> <span class="string">"("</span>)
       (<span class="special">begin</span> . <span class="var">body</span>)
       (<span class="func">format</span> <span class="var">out</span> <span class="string">")"</span>) ) ) ) )</pre>


<h4 id="cc/gen/exprs/sssect:refs"><span class="wrap"><span class="title">Обращения к переменным</span></span></h4>

<p>В программе могут использоваться переменные разного вида, но в общем случае
одна переменная Scheme соответствует одной переменной Си. Метод обработки
обращений к переменным сразу же перепоручает всю работу обобщённой функции
<code><span class="func">reference-&gt;C</span></code>, а она, в свою очередь, по умолчанию просит всё сделать
следующую функцию — <code><span class="func">variable-&gt;C</span></code>. Такая слабая связанность методов
облегчит их дальнейшую специализацию.</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Reference</span></code>}-->
<!--\indexC{reference->C}-->
<!--\indexC{variable->C}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Reference</span>) <span class="var">out</span>)
  (<span class="func">reference-&gt;C</span> (<span class="func">Reference-variable</span> <span class="var">e</span>) <span class="var">out</span>) )

(<span class="syntax">define-generic</span> (<span class="func">reference-&gt;C</span> (<span class="var">v</span> <span class="class">Variable</span>) <span class="var">out</span>)
  (<span class="func">variable-&gt;C</span> <span class="var">v</span> <span class="var">out</span>) )

(<span class="syntax">define-generic</span> (<span class="func">variable-&gt;C</span> (<span class="var">variable</span>) <span class="var">out</span>))</pre>

<p>Обычно переменная получает новое имя на Си, похожее на её исходное, за
исключением случаев, когда она была переименована или же ссылается на цитату.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">variable-&gt;C</span> (<span class="var">variable</span> <span class="class">Variable</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> (<span class="func">IdScheme-&gt;IdC</span> (<span class="func">Variable-name</span> <span class="var">variable</span>))) )

(<span class="syntax">define-method</span> (<span class="func">variable-&gt;C</span> (<span class="var">variable</span> <span class="class">Renamed-Local-Variable</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~A</span>_<span class="pp">~A</span>"</span>
          (<span class="func">IdScheme-&gt;IdC</span> (<span class="func">Variable-name</span> <span class="var">variable</span>))
          (<span class="func">Renamed-Local-Variable-index</span> <span class="var">variable</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">variable-&gt;C</span> (<span class="var">variable</span> <span class="class">Quotation-Variable</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"thing<span class="pp">~A</span>"</span> (<span class="func">Quotation-Variable-name</span> <span class="var">variable</span>)) )</pre>

<p>Отдельно обрабатываются обращения к глобальным переменным, не являющимся
предопределёнными. Фактически, это свободные переменные всей программы. Как вы
помните, в данной реализации подобные переменные создаются автоматически, при их
первом упоминании. К сожалению, компилятор никак не анализирует значения этих
переменных, поэтому проверки на инициализированность должны проводиться во время
исполнения программы. За этим проследит макрос
<code class="c"><span class="macro">SCM_CheckedGlobal</span></code>.
<span class="see">[см. упр. <a href="#cc/ex:global-check">10.2</a>]</span></p>

<pre>(<span class="syntax">define-method</span> (<span class="func">reference-&gt;C</span> (<span class="var">v</span> <span class="class">Global-Variable</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_CheckedGlobal"</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">variable-&gt;C</span> <span class="var">v</span> <span class="var">out</span>) ) )</pre>

<p>Кроме того, ещё остаются обычные свободные переменные. Для них тоже припасён
специальный макрос.</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Free-Reference</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Free-Reference</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_Free"</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">variable-&gt;C</span> (<span class="func">Free-Reference-variable</span> <span class="var">e</span>) <span class="var">out</span>) ) )</pre>


<h4 id="cc/gen/exprs/sssect:assignments"><span class="wrap"><span class="title">Присваивания</span></span></h4>

<p>С присваиваниями всё ещё легче, так как они бывают лишь двух видов: присваивание
глобальным переменным и модификация содержимого коробок. Случай глобальных
переменных прямо переводится в присваивание соответствующей глобальной
переменной языка Си.</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Global-Assignment</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Global-Assignment</span>) <span class="var">out</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">variable-&gt;C</span> (<span class="func">Global-Assignment-variable</span> <span class="var">e</span>) <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">" = "</span>)
    (<span class="func">-&gt;C</span> (<span class="func">Global-Assignment-form</span> <span class="var">e</span>) <span class="var">out</span>) ) )</pre>


<h4 id="cc/gen/exprs/sssect:boxes"><span class="wrap"><span class="title">Коробки</span></span></h4>

<p>Что касается коробок, то над ними возможны всего три операции. Макрос
<code class="c"><span class="macro">SCM_Content</span></code> позволяет смотреть или изменять содержимое коробок, а
библиотечная функция <code class="c"><span class="func">SCM_allocate_box</span></code> берёт на себя их создание.</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Box-Read</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">Box-Write</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">Box-Creation</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Box-Read</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_Content"</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">-&gt;C</span> (<span class="func">Box-Read-reference</span> <span class="var">e</span>) <span class="var">out</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Box-Write</span>) <span class="var">out</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_Content"</span>)
    (<span class="syntax">between-parentheses</span> <span class="var">out</span>
      (<span class="func">-&gt;C</span> (<span class="func">Box-Write-reference</span> <span class="var">e</span>) <span class="var">out</span>) )
    (<span class="func">format</span> <span class="var">out</span> <span class="string">" = "</span>)
    (<span class="func">-&gt;C</span> (<span class="func">Box-Write-form</span> <span class="var">e</span>) <span class="var">out</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Box-Creation</span>) <span class="var">out</span>)
  (<span class="func">variable-&gt;C</span> (<span class="func">Box-Creation-variable</span> <span class="var">e</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">" = SCM_allocate_box"</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">variable-&gt;C</span> (<span class="func">Box-Creation-variable</span> ) <span class="var">out</span>) ) )</pre>


<h4 id="cc/gen/exprs/sssect:alternatives"><span class="wrap"><span class="title">Ветвления</span></span></h4>

<p>К счастью, в Си есть тернарный оператор, позволяющий записывать ветвления
выражениями вида <code>(<span class="math"><span class="ord var">π<sub><span class="ord num">0</span></sub></span></span> ? <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span> : <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span>)</code>. Так как в Scheme любое
значение, не тождественное <code><span class="hash">#f</span></code>, считается истиной, мы должны это явно
проверять. И, конечно, не забываем о скобках!</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Alternative</span></code>}-->
<!--\indexC{boolean->C}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Alternative</span>) <span class="var">out</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">boolean-&gt;C</span> (<span class="func">Alternative-condition</span> <span class="var">e</span>) <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>? "</span>)
    (<span class="func">-&gt;C</span> (<span class="func">Alternative-consequent</span> <span class="var">e</span>) <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>: "</span>)
    (<span class="func">-&gt;C</span> (<span class="func">Alternative-alternant</span> <span class="var">e</span>) <span class="var">out</span>) ) )

(<span class="syntax">define-generic</span> (<span class="func">boolean-&gt;C</span> (<span class="var">e</span>) <span class="var">out</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">-&gt;C</span> <span class="var">e</span> <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">" != SCM_false"</span>) ) )</pre>

<!--\indexR{вывод типов}-->
<!--\indexR{инлайнинг}-->
<!--\indexR{встраивание}-->
<!--\indexR{представление!логических значений}-->
<!--\indexR{логические значения!в Си}-->
<p>Внимательный читатель уже заметил, что проверка условия не всегда выполняется
с максимальной эффективностью. В программах очень часто встречаются выражения
вида <code>(<span class="special">if</span> (<span class="func">pair?</span> <span class="var">x</span>) ...)</code>. Вызов предиката <code><span class="func">pair?</span></code> здесь честно возвращает
логические значения Scheme, но в данном случае он мог бы сразу выдать значение,
удобное для Си. Мелочь, конечно, но копейка рубль бережёт. Одним вариантом
оптимизации является специализация функции <code><span class="func">boolean-&gt;C</span></code> для вызовов
предопределённых предикатов. Также можно отождествить логические значения Scheme
и Си, условившись считать ложью значение <code class="c"><span class="macro">NULL</span></code>. Наконец, частичный вывод
типов выражений позволяет избавиться от этой и прочих излишних проверок и
преобразований, см. <span class="cite">[<a href="z1_bibliography.html#shi91">Shi91</a>,
<a href="z1_bibliography.html#ser93">Ser93</a>,
<a href="z1_bibliography.html#wc94">WC94</a>]</span>.</p>


<h4 id="cc/gen/exprs/sssect:sequences"><span class="wrap"><span class="title">Последовательные вычисления</span></span></h4>

<p>Для последовательного вычисления подвыражений в Си тоже есть специальная
конструкция: <code>(<span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span>, ..., <span class="math"><span class="ord var">π<sub><span class="ord var">n</span></sub></span></span>)</code>.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Sequence</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Sequence</span>) <span class="var">out</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">-&gt;C</span> (<span class="func">Sequence-first</span> <span class="var">e</span>) <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">",<span class="pp">~%</span>"</span>)
    (<span class="func">-&gt;C</span> (<span class="func">Sequence-last</span> <span class="var">e</span>) <span class="var">out</span>) ) )</pre>


<h3 id="cc/gen/ssect:apply"><span class="wrap"><span class="seq">10.8.5.</span><span class="title">Компиляция аппликаций</span></span></h3>

<p>Мы разделили аппликации функций на несколько категорий: нормальные вызовы
функций, приводимые формы (аппликации, где на месте функции находится
абстракция) и обращения к предопределённым примитивам. Этим трём категориям
аппликаций соответствуют узлы синтаксического дерева <code><span class="class">Regular-Application</span></code>,
<code><span class="class">Fix-Let</span></code> и <code><span class="class">Predefined-Application</span></code>.</p>

<p>Нормальные вызовы функций вида <code>(<span class="math"><span class="ord var">f</span></span> <span class="math"><span class="ord var">x<sub><span class="ord num">1</span></sub></span></span> ... <span class="math"><span class="ord var">x<sub><span class="ord var">n</span></sub></span></span>)</code> преобразуются
в выражения Си <code class="c"><span class="func">SCM_invoke</span>(<span class="math"><span class="ord var">f</span></span>, <span class="math"><span class="ord var">n</span></span>, <span class="math"><span class="ord var">x<sub><span class="ord num">1</span></sub></span></span>, ..., <span class="math"><span class="ord var">x<sub><span class="ord var">n</span></sub></span></span>)</code>, где <span class="math"><span class="ord var">n</span></span> — это
количество аргументов, переданных функции, а <code class="c"><span class="func">SCM_invoke</span></code> — специальная
вспомогательная функция. Мы определим несколько макросов, чтобы сделать вызовы
функций с малым числом аргументов более читабельными:</p>

<!--\indexC*{SCM_invoke0}{SCM\_invoke\protect<i>n</i>}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_invoke0</span>(<span class="var">f</span>)          <span class="func">SCM_invoke</span>(<span class="var">f</span>, <span class="num">0</span>)
<span class="pre">#define</span> <span class="macro">SCM_invoke1</span>(<span class="var">f</span>, <span class="var">x</span>)       <span class="func">SCM_invoke</span>(<span class="var">f</span>, <span class="num">1</span>, <span class="var">x</span>)
<span class="pre">#define</span> <span class="macro">SCM_invoke2</span>(<span class="var">f</span>, <span class="var">x</span>, <span class="var">y</span>)    <span class="func">SCM_invoke</span>(<span class="var">f</span>, <span class="num">2</span>, <span class="var">x</span>, <span class="var">y</span>)
<span class="pre">#define</span> <span class="macro">SCM_invoke3</span>(<span class="var">f</span>, <span class="var">x</span>, <span class="var">y</span>, <span class="var">z</span>) <span class="func">SCM_invoke</span>(<span class="var">f</span>, <span class="num">3</span>, <span class="var">x</span>, <span class="var">y</span>, <span class="var">z</span>)</pre>

<p>Вызовы большей арности компилируются напрямую в <code class="c"><span class="func">SCM_invoke</span></code>:</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Regular-Application</span></code>}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Regular-Application</span>) <span class="var">out</span>)
  (<span class="syntax">let</span> ((<span class="var">n</span> (<span class="func">number-of</span> (<span class="func">Regular-Application-arguments</span> <span class="var">e</span>))))
    (<span class="syntax">cond</span> ((<span class="func">&lt;</span> <span class="var">n</span> <span class="num">4</span>)
           (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_invoke<span class="pp">~A</span>"</span> <span class="var">n</span>)
           (<span class="syntax">between-parentheses</span> <span class="var">out</span>
             (<span class="func">-&gt;C</span> (<span class="func">Regular-Application-function</span> <span class="var">e</span>) <span class="var">out</span>)
             (<span class="func">-&gt;C</span> (<span class="func">Regular-Application-arguments</span> <span class="var">e</span>) <span class="var">out</span>) ) )
          (<span class="syntax">else</span>
           (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_invoke"</span>)
           (<span class="syntax">between-parentheses</span> <span class="var">out</span>
             (<span class="func">-&gt;C</span> (<span class="func">Regular-Application-function</span> <span class="var">e</span>) <span class="var">out</span>)
             (<span class="func">format</span> <span class="var">out</span> <span class="string">", <span class="pp">~A</span>"</span> <span class="var">n</span>)
             (<span class="func">-&gt;C</span> (<span class="func">Regular-Application-arguments</span> <span class="var">e</span>) <span class="var">out</span>) ) ) ) ) )</pre>

<!--\indexR{стековые фреймы!объединение}-->
<!--\indexR{фреймы стека!объединение}-->
<p>Приводимые формы просто переводятся в последовательность выражений Си,
соответствующих их телу. Наконец-то усилия по предварительному анализу кода
и идентификации временных переменных начинают приносить плоды. Благодаря им
становится возможным выполнить так называемое <em class="term">объединение фреймов</em> (frame
coalescing); это известная оптимизация <span class="cite">[<a href="z1_bibliography.html#as94">AS94</a>, <a href="z1_bibliography.html#pj87">PJ87</a>]</span>, касающаяся временных
переменных: вместо множества маленьких выделений-освобождений памяти сразу
взять один большой кусок для целого набора переменных. А если под все временные
переменные уже выделена память, то связывание их со значениями сводится лишь
к присваиваниям. В терминах Лиспа данное преобразование приводит к объединению
локальных <code><span class="syntax">let</span></code>-форм, переносу их на уровень выше и возможному переименованию
соответствующих переменных.<a class="footref" href="zz_footnotes.html#foot10.4"><sup>4</sup></a></p>

<table class="nocaption code"><tbody><tr>
<td><pre>(<span class="special">begin</span>
  <span class="math"><span class="ord var">e<sub><span class="ord num">1</span></sub></span></span>
  (<span class="syntax">let</span> ((<span class="var">x</span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span>))
    <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span> )
  <span class="math"><span class="ord var">e<sub><span class="ord num">2</span></sub></span></span>
  (<span class="syntax">let</span> ((<span class="var">x</span> <span class="math"><span class="ord var">π<sub><span class="ord num">3</span></sub></span></span>))
    <span class="math"><span class="ord var">π<sub><span class="ord num">4</span></sub></span></span> ) )</pre></td>
<td style="vertical-align: middle"><span class="math"><span class="ord"></span><span class="rel">⇝</span><span class="ord"></span></span></td>
<td><pre>(<span class="syntax">let</span> (<span class="var">x1</span> <span class="var">x2</span>)
  <span class="math"><span class="ord var">e<sub><span class="ord num">1</span></sub></span></span>
  (<span class="special">set!</span> <span class="var">x1</span> <span class="math"><span class="ord var">π<sub><span class="ord num">1</span></sub></span></span>)
  <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span><span class="open">[</span><span class="normal ord"><code><span class="var">x</span></code></span><span class="rel">→</span><span class="normal ord"><code><span class="var">x1</span></code></span><span class="close">]</span></span>
  <span class="math"><span class="ord var">e<sub><span class="ord num">2</span></sub></span></span>
  (<span class="special">set!</span> <span class="var">x2</span> <span class="math"><span class="ord var">π<sub><span class="ord num">3</span></sub></span></span>)
  <span class="math"><span class="ord var">π<sub><span class="ord num">4</span></sub></span><span class="open">[</span><span class="normal ord"><code><span class="var">x</span></code></span><span class="rel">→</span><span class="normal ord"><code><span class="var">x2</span></code></span><span class="close">]</span></span> )</pre></td>
</tr></tbody></table>

<!--\indexR{продолжения (continuations)}-->
<!--\indexR{коробки}-->
<p>В общем случае это преобразование ошибочно: например, если благодаря
продолжениям <span class="math"><span class="ord var">e<sub><span class="ord num">1</span></sub></span></span> вернёт значение во второй раз, а <span class="math"><span class="ord var">π<sub><span class="ord num">2</span></sub></span></span> захватывает
значение <code><span class="var">x</span></code>, то новая переменная <code><span class="var">x</span></code>, переименованная в <code><span class="var">x1</span></code>, сохранит
привязку <code><span class="var">x</span></code> из параллельной ветви стека.
<span class="see">[см. раздел <a href="ch06_fast_interpretation.html#fast/fast/begin/application/par:call/cc">6.1.3</a>]</span> Тем не менее, в данном случае
всё хорошо, так как клоны <code><span class="var">x1</span></code> всё же будут отличаться: значение <code><span class="var">x1</span></code>
будет завёрнуто в коробку, а вместо <code><span class="special">set!</span></code> будет <code><span class="func">Box-Write</span></code>; так что хоть
коробка и останется той же, но привязка для её содержимого будет создана заново.</p>

<p>Остаётся только правильно инициализировать каждую локальную переменную. Так как
ранее был проведён их анализ и переименование, то конфликтов областей видимости
не будет. Простая обобщённая функция <code><span class="func">bindings-&gt;C</span></code> без проблем справится
с инициализацией.</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Fix-Let</span></code>}-->
<!--\indexC{bindings->C}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Fix-Let</span>) <span class="var">out</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">bindings-&gt;C</span> (<span class="func">Fix-Let-variables</span> <span class="var">e</span>) (<span class="func">Fix-Let-arguments</span> <span class="var">e</span>) <span class="var">out</span>)
    (<span class="func">-&gt;C</span> (<span class="func">Fix-Let-body</span> <span class="var">e</span>) <span class="var">out</span>) ) )

(<span class="syntax">define-generic</span> (<span class="func">bindings-&gt;C</span> <span class="var">variables</span> (<span class="var">arguments</span>) <span class="var">out</span>))

(<span class="syntax">define-method</span> (<span class="func">bindings-&gt;C</span> <span class="var">variables</span> (<span class="var">e</span> <span class="class">Arguments</span>) <span class="var">out</span>)
  (<span class="func">variable-&gt;C</span> (<span class="func">car</span> <span class="var">variables</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">" = "</span>)
  (<span class="func">-&gt;C</span> (<span class="func">Arguments-first</span> <span class="var">e</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">",<span class="pp">~%</span>"</span>)
  (<span class="func">bindings-&gt;C</span> (<span class="func">cdr</span> <span class="var">variables</span>) (<span class="func">Arguments-others</span> <span class="var">e</span>) <span class="var">out</span>) )

(<span class="syntax">define-method</span> (<span class="func">bindings-&gt;C</span> <span class="var">variables</span> (<span class="var">e</span> <span class="class">No-Argument</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">""</span>) )</pre>

<!--\indexR{встраивание}-->
<!--\indexR{инлайнинг}-->
<p>Наконец, остаётся случай аппликации, когда функцией является значение
предопределённой переменной, — такие вызовы <em>встраиваются</em> напрямую
в код. Примитивам нет нужды пользоваться <code class="c"><span class="func">SCM_invoke</span></code>. Они будут написаны
на Си и включены в состав библиотеки времени исполнения, которая подключается
к любой скомпилированной программе. Примитивы знают о внутренних структурах
данных, так что могут обойтись без относительно дорогого (и бесполезного
в данном случае) вызова <code class="c"><span class="func">SCM_invoke</span></code>.</p>

<!--\indexR{функции!примитивы!генератор вызовов}-->
<!--\indexR{примитивы!генератор вызовов}-->
<p>Так как точная форма прямого вызова примитива зависит от его реализации, мы
поступим следующим образом: расширим класс дескрипторов, описывающих
функции-примитивы, дополнительным полем <code><span class="var">generator</span></code>, служащим для хранения
специальных функций-генераторов. Их задачей будет принять интересующую нас
аппликацию и выдать в порт соответствующий код на Си. Каким образом они его
получат — это личное дело генераторов, но чтобы облегчить им немного жизнь,
мы определим обобщённую функцию <code><span class="func">arguments-&gt;C</span></code>,
рекурсивно применяющую <code><span class="func">-&gt;C</span></code> к аргументам вызова.</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Predefined-Application</span></code>}-->
<!--\indexC{arguments->C}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">arguments-&gt;C</span> (<span class="func">e</span>) <span class="var">out</span>))

(<span class="syntax">define-method</span> (<span class="func">arguments-&gt;C</span> (<span class="var">e</span> <span class="class">No-Argument</span>) <span class="var">out</span>) <span class="hash">#t</span>)

(<span class="syntax">define-method</span> (<span class="func">arguments-&gt;C</span> (<span class="var">e</span> <span class="class">Arguments</span>) <span class="var">out</span>)
  (<span class="func">-&gt;C</span> (<span class="func">Arguments-first</span> <span class="var">e</span>) <span class="var">out</span>)
  (<span class="func">-&gt;C</span> (<span class="func">Arguments-others</span> <span class="var">e</span>) <span class="var">out</span>) )

(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Predefined-Application</span>) <span class="var">out</span>)
  ((<span class="func">Functional-Description-generator</span>
    (<span class="func">Predefined-Variable-description</span>
     (<span class="func">Predefined-Application-variable</span> <span class="var">e</span>) ) ) <span class="var">e</span> <span class="var">out</span> ) )</pre>


<h3 id="cc/gen/ssect:predef-env"><span class="wrap"><span class="seq">10.8.6.</span><span class="title">Предопределённое окружение</span></span></h3>

<p>Если мы собрались пользоваться предопределёнными функциями, то о них вначале
необходимо рассказать компилятору. Для этого определяется специальный макрос
<code><span class="syntax">defprimitive</span></code>:</p>

<!--\indexC{Functional-Description}-->
<!--\indexC{defprimitive}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Functional-Description</span> <span class="class">Object</span>
  ( <span class="var">comparator</span> <span class="var">arity</span> <span class="var">generator</span> ) )

(<span class="special">define-syntax</span> <span class="var">defprimitive</span>
  (<span class="syntax">syntax-rules</span> ()
    ((<span class="syntax">defprimitive</span> <span class="var">name</span> <span class="var">Cname</span> <span class="var">arity</span>)
     (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">make-Predefined-Variable</span> '<span class="var">name</span>
               (<span class="func">make-Functional-Description</span>
                <span class="var">=</span> <span class="var">arity</span>
                (<span class="func">make-predefined-application-generator</span> '<span class="var">Cname</span>) ) )))
       (<span class="special">set!</span> <span class="var">g.init</span> (<span class="func">cons</span> <span class="var">v</span> <span class="var">g.init</span>))
       '<span class="var">name</span> ) ) ) )</pre>

<p>Итак, компилятору известно имя примитива на Scheme и Си, а также его арность.
На выходе ожидается вызов функции Си: то есть имя функции, за которым в скобках
следуют аргументы, разделённые запятыми. Функция
<code><span class="func">make-predefined-application-generator</span></code> создаёт генераторы подобных вызовов.</p>

<!--\indexC{make-predefined-application-generator}-->
<pre>(<span class="special">define</span> (<span class="func">make-predefined-application-generator</span> <span class="var">Cname</span>)
  (<span class="special">lambda</span> (<span class="var">e</span> <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~A</span>"</span> <span class="var">Cname</span>)
    (<span class="syntax">between-parentheses</span> <span class="var">out</span>
      (<span class="func">arguments-&gt;C</span> (<span class="func">Predefined-Application-arguments</span> <span class="var">e</span>) <span class="var">out</span>) ) ) )</pre>

<p>Приведём несколько примеров для всем знакомых функций:</p>

<pre>(<span class="syntax">defprimitive</span> <span class="var">cons</span> <span class="string">"SCM_cons"</span> <span class="num">2</span>)
(<span class="syntax">defprimitive</span> <span class="var">car</span> <span class="string">"SCM_car"</span> <span class="num">1</span>)
(<span class="syntax">defprimitive</span> <span class="var">+</span> <span class="string">"SCM_Plus"</span> <span class="num">2</span>)
(<span class="syntax">defprimitive</span> <span class="var">=</span> <span class="string">"SCM_EqnP"</span> <span class="num">2</span>)</pre>

<!--\indexR{соглашения именования!макросов и примитивов}-->
<p>Отсюда видно, что вызов <code><span class="func">cons</span></code> будет компилироваться в вызов функции
<code class="c"><span class="func">SCM_cons</span></code>, а примитив <code><span class="func">+</span></code> — в макрос <code class="c"><span class="macro">SCM_Plus</span></code>.
<span class="see">[см. раздел <a href="#cc/data/values/par:macros">10.9.1</a>]</span>
Макрос можно отличить от функции по прописной первой букве имени.
Некоторые примитивы из соображений компактности
кода эффективнее реализовывать именно как макросы.</p>


<h3 id="cc/gen/ssect:func"><span class="wrap"><span class="seq">10.8.7.</span><span class="title">Компиляция функций</span></span></h3>

<!--\indexR{арность}-->
<!--\indexR{представление!арности}-->
<p>Выполненные ранее трансформации преобразовали все абстракции в явно создаваемые
замыкания, которым соответствуют объекты класса <code><span class="class">Closure-Creation</span></code>. В Си за
создание замыканий будет отвечать библиотечная функция <code class="c"><span class="func">SCM_close</span></code>. Первым
аргументом она принимает адрес Си-функции (завёрнутый в макрос
<code class="c"><span class="macro">SCM_CfunctionAddress</span></code>), соответствующий телу абстракции; за адресом следует
арность создаваемого замыкания, а в конце списка расположены количество
замыкаемых значений и, собственно, сами значения. Данные значения извлекаются
из поля <code><span class="var">free</span></code> обрабатываемой абстракции. Количество аргументов функций
с фиксированной арностью записывается просто соответствующим числом.
Но если это функция с переменной арностью, то ей может быть передано любое
количество аргументов, не меньшее некоторого
<span class="math"><span class="ord var">i</span></span>; этот случай будет
представляться числом <span class="math"><span class="ord">−</span><span class="ord var">i</span><span class="binop">−</span><span class="ord num">1</span></span>.
К примеру, арность функции <code><span class="func">list</span></code> равна
<span class="math"><span class="ord">−</span><span class="ord num">1</span></span>.</p>

<!--\indexCS*{c}{->C}{<code><span class="func">Closure-Creation</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">No-Free</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">Free-Environment</span></code>}-->
<!--\indexC{generate-arity}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Closure-Creation</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_close"</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_CfunctionAddress(function_<span class="pp">~A</span>), <span class="pp">~A</span>, <span class="pp">~A</span>"</span>
            (<span class="func">Closure-Creation-index</span> <span class="var">e</span>)
            (<span class="func">generate-arity</span> (<span class="func">Closure-Creation-variables</span> <span class="var">e</span>))
            (<span class="func">number-of</span> (<span class="func">Closure-Creation-free</span> <span class="var">e</span>)) )
    (<span class="func">-&gt;C</span> (<span class="func">Closure-Creation-free</span> <span class="var">e</span>) <span class="var">out</span>) ) )

(<span class="special">define</span> (<span class="func">generate-arity</span> <span class="var">variables</span>)
  (<span class="syntax">let</span> <span class="func">count</span> ((<span class="var">variables</span> <span class="var">variables</span>) (<span class="var">arity</span> <span class="num">0</span>))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">variables</span>)
        (<span class="special">if</span> (<span class="func">Local-Variable-dotted?</span> (<span class="func">car</span> <span class="var">variables</span>))
            (<span class="func">-</span> (<span class="func">+</span> <span class="var">arity</span> <span class="num">1</span>))
            (<span class="func">count</span> (<span class="func">cdr</span> <span class="var">variables</span>) (<span class="func">+</span> <span class="num">1</span> <span class="var">arity</span>)) )
        <span class="var">arity</span> ) ) )

(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">No-Free</span>) <span class="var">out</span>)
  <span class="hash">#t</span> )

(<span class="syntax">define-method</span> (<span class="func">-&gt;C</span> (<span class="var">e</span> <span class="class">Free-Environment</span>) <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">", "</span>)
  (<span class="func">-&gt;C</span> (<span class="func">Free-Environment-first</span> <span class="var">e</span>) <span class="var">out</span>)
  (<span class="func">-&gt;C</span> (<span class="func">Free-Environment-others</span> <span class="var">e</span>) <span class="var">out</span>) )</pre>

<p>Все абстракции компилируемой программы собираются в соответствующем
поле объекта <code><span class="class">Flattened-Program</span></code> в виде списка объектов класса
<code><span class="class">With-Temp-Function-Definition</span></code>. Каждому из них сопоставляется
эквивалентная функция на Си.</p>


<!--\indexC{generate-functions}-->
<pre>(<span class="special">define</span> (<span class="func">generate-functions</span> <span class="var">out</span> <span class="var">definitions</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* Functions: */<span class="pp">~%</span>"</span>)
  (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">def</span>)
              (<span class="func">generate-closure-structure</span> <span class="var">out</span> <span class="var">def</span>)
              (<span class="func">generate-possibly-dotted-definition</span> <span class="var">out</span> <span class="var">def</span>) )
            (<span class="func">reverse</span> <span class="var">definitions</span>) ) )</pre>

<!--\indexC*{function}{function\_}-->
<!--\indexR{таблица символов}-->
<p>Для повышения удобочитаемости генерируемого кода снова используются макросы,
чтобы скрыть детали реализации. Для каждого замыкания генерируется функция,
содержащая его тело, а также структура данных, которая будет хранить
замкнутые переменные. Имена создаваемых сущностей строятся по простому
принципу: корень <code class="c"><span class="func">function_</span></code> + номерной суффикс, взятый из поля
<code><span class="var">index</span></code> объекта <code><span class="class">Function-Definition</span></code><a class="footref" href="zz_footnotes.html#foot10.5"><sup>5</sup></a>.</p>

<p>Внутренняя структура замыканий формируется макросом
<code class="c"><span class="macro">SCM_DefineClosure</span></code>.
Первым аргументом он получает номер соответствующей функции, а вторым — имена
захватываемых замыканием переменных, разделённые точками с запятой.</p>

<!--\indexC{generate-closure-structure}-->
<pre>(<span class="special">define</span> (<span class="func">generate-closure-structure</span> <span class="var">out</span> <span class="var">definition</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DefineClosure(function_<span class="pp">~A</span>, "</span>
          (<span class="func">Function-Definition-index</span> <span class="var">definition</span>) )
  (<span class="func">generate-local-temporaries</span> (<span class="func">Function-Definition-free</span> <span class="var">definition</span>)
                              <span class="var">out</span> )
  (<span class="func">format</span> <span class="var">out</span> <span class="string">");<span class="pp">~%</span>"</span>) )</pre>

<p>Функция <code><span class="func">generate-possibly-dotted-definition</span></code> генерирует определение тела
замыкания в виде функции Си, учитывая его арность. Прототип этой функции
формирует макрос <code class="c"><span class="macro">SCM_DeclareFunction</span></code>, принимающий её имя как аргумент.
Локальные переменные функции определяются с помощью макросов
<code class="c"><span class="macro">SCM_DeclareLocalVariable</span></code> и <code class="c"><span class="macro">SCM_DeclareLocalDottedVariable</span></code>. Они
принимают имя создаваемой переменной, а также её порядковый номер в списке
переменных функции. Правда, этот номер нужен только для сборки списка,
связываемого с точечной переменной. С телом функции вообще нет проблем: просто
применяем к нему <code><span class="func">-&gt;C</span></code> и не забываем вернуть вычисленное значение с помощью
оператора <code class="c"><span class="keyword">return</span></code>.</p>

<!--\indexC{generate-possibly-dotted-definition}-->
<pre>(<span class="special">define</span> (<span class="func">generate-possibly-dotted-definition</span> <span class="var">out</span> <span class="var">definition</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>SCM_DeclareFunction(function_<span class="pp">~A</span>)<span class="pp">~%</span>{<span class="pp">~%</span>"</span>
          (<span class="func">Function-Definition-index</span> <span class="var">definition</span>) )
  (<span class="syntax">let</span> ((<span class="var">vars</span> (<span class="func">Function-Definition-variables</span> <span class="var">definition</span>))
        (<span class="var">index</span> <span class="var">-1</span>) )
    (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">v</span>)
                (<span class="special">set!</span> <span class="var">index</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">index</span>))
                (<span class="syntax">cond</span> ((<span class="func">Local-Variable-dotted?</span> <span class="var">v</span>)
                       (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DeclareLocalDottedVariable("</span>) )
                      ((<span class="func">Variable?</span> <span class="var">v</span>)
                       (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DeclareLocalVariable("</span>) ) )
                (<span class="func">variable-&gt;C</span> <span class="var">v</span> <span class="var">out</span>)
                (<span class="func">format</span> <span class="var">out</span> <span class="string">", <span class="pp">~A</span>);<span class="pp">~%</span>"</span> <span class="var">index</span>) )
              <span class="var">vars</span> )
    (<span class="syntax">let</span> ((<span class="var">temps</span> (<span class="func">With-Temp-Function-Definition-temporaries</span>
                  <span class="var">definition</span> )))
      (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">temps</span>)
        (<span class="func">generate-local-temporaries</span> <span class="var">temps</span> <span class="var">out</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>"</span>) ) )
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"return "</span>)
    (<span class="func">-&gt;C</span> (<span class="func">Function-Definition-body</span> <span class="var">definition</span>) <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">";<span class="pp">~%</span>}<span class="pp">~%</span><span class="pp">~%</span>"</span>) ) )</pre>

<p>Список локальных переменных формируется функцией
<code><span class="func">generate-local-temporaries</span></code>:</p>

<!--\indexC{generate-local-temporaries}-->
<pre>(<span class="special">define</span> (<span class="func">generate-local-temporaries</span> <span class="var">temps</span> <span class="var">out</span>)
  (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">temps</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM "</span>)
    (<span class="func">variable-&gt;C</span> (<span class="func">car</span> <span class="var">temps</span>) <span class="var">out</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"; "</span>)
    (<span class="func">generate-local-temporaries</span> (<span class="func">cdr</span> <span class="var">temps</span>) <span class="var">out</span>) ) )</pre>


<h3 id="cc/gen/ssect:init"><span class="wrap"><span class="seq">10.8.8.</span><span class="title">Последний штрих</span></span></h3>

<!--\indexC{main}-->
<p>Сейчас наш компилятор способен переварить любую программу на Scheme, но для
получения полноценной программы на Си ей не хватает функции
<code class="c"><span class="func">main</span></code>. Именно
этой функции соответствует то замыкание, в которое была обернута вся программа,
когда мы избавлялись от вложенных <code><span class="special">lambda</span></code>-форм.
<span class="see">[см. раздел <a href="#cc/collecting/par:main">10.5</a>]</span>
Единственным спорным вопросом здесь является включение в главную функцию вызова
<code class="c"><span class="func">SCM_print</span></code>, выводящего на экран результат
работы программы. В общем случае это не нужно — есть множество полезных и при этом
молчаливых программ (например, <code>gcc</code>). Но для нас более удобным будет
сразу же видеть достижения наших небольших программок.</p>

<!--\indexC{generate-main}-->
<pre>(<span class="special">define</span> (<span class="func">generate-main</span> <span class="var">out</span> <span class="var">form</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* Expression: */<span class="pp">~%</span>"</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"int main(void)<span class="pp">~%</span>{<span class="pp">~%</span>"</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"    SCM_print"</span>)
  (<span class="syntax">between-parentheses</span> <span class="var">out</span>
    (<span class="func">-&gt;C</span> <span class="var">form</span> <span class="var">out</span>) )
  (<span class="func">format</span> <span class="var">out</span> <span class="string">";<span class="pp">~%</span>    return 0;<span class="pp">~%</span>}<span class="pp">~%</span>"</span>) )</pre>

<!--\indexR{компиляция!в Си}-->
<p>Конечно, о представлении данных ещё не было сказано ничего конкретного, равно
как и о реализации библиотеки времени исполнения, но у нас уже есть полностью
рабочий компилятор вместе с огромным желанием испытать его в деле. Натравим его
на подопытный пример, приведённый в начале главы.
<span class="see">[см. раздел <a href="#cc/sect:objectification">10.1</a>]</span>
И-и-и… вот что получается на выходе (отступы расставлены вручную для читабельности):</p>

<div class="snippet numbered" id="cc/gen/init/src:result">
  <span class="title">o/chap10ex.c</span>
<table class="numbered-source"><tr>
<td class="lines"><pre>



<span class="lineno">5</span>




<span class="lineno">10</span>




<span class="lineno">15</span>




<span class="lineno">20</span>




<span class="lineno">25</span>




<span class="lineno">30</span>




<span class="lineno">35</span>




<span class="lineno">40</span>




<span class="lineno">45</span>




<span class="lineno">50</span>




<span class="lineno">55</span>




<span class="lineno">60</span>




<span class="lineno">65</span>




<span class="lineno">70</span>




<span class="lineno">75</span>




<span class="lineno">80</span></pre></td>
<td><pre class="c"><span class="comment">/* Compiler to C $Revision: 4.1$
(BEGIN
  (SET! INDEX 1)
  ((LAMBDA
     (CNTER . TMP)
     (SET! TMP (CNTER (LAMBDA (I) (LAMBDA X (CONS I X)))))
     (IF CNTER (CNTER TMP) INDEX))
    (LAMBDA (F) (SET! INDEX (+ 1 INDEX)) (F INDEX))
    'FOO))
*/</span>

<span class="pre">#include</span> <span class="string">"scheme.h"</span>

<span class="comment">/* Global environment: */</span>
<span class="macro">SCM_DefineGlobalVariable</span>(<span class="var">INDEX</span>, <span class="string">"INDEX"</span>);

<span class="comment">/* Quotations: */</span>
<span class="pre">#define</span> <span class="macro">thing3</span> <span class="macro">SCM_nil</span>                      <span class="comment">/* () */</span>
<span class="macro">SCM_DefineString</span>(<span class="var">thing4_object</span>, <span class="string">"FOO"</span>);
<span class="pre">#define</span> <span class="macro">thing4</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing4_object</span>)
<span class="macro">SCM_DefineSymbol</span>(<span class="var">thing2_object</span>, <span class="var">thing4</span>);    <span class="comment">/* FOO */</span>
<span class="pre">#define</span> <span class="macro">thing2</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing2_object</span>)
<span class="pre">#define</span> <span class="macro">thing1</span> <span class="macro">SCM_Int2Fixnum</span>(<span class="num">1</span>)
<span class="pre">#define</span> <span class="macro">thing0</span> <span class="macro">thing1</span>                       <span class="comment">/* 1 */</span>

<span class="comment">/* Functions: */</span>
<span class="macro">SCM_DefineClosure</span>(<span class="type">function_0</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_0</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">F</span>, <span class="num">0</span>);
    <span class="keyword">return</span> ((<span class="var">INDEX</span> = <span class="macro">SCM_Plus</span>(<span class="macro">thing1</span>,
                              <span class="macro">SCM_CheckedGlobal</span>(<span class="var">INDEX</span>))),
            <span class="macro">SCM_invoke1</span>(<span class="var">F</span>,
                        <span class="macro">SCM_CheckedGlobal</span>(<span class="var">INDEX</span>)));
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_1</span>, <span class="type">SCM</span> <span class="var">I</span>; );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_1</span>)
{
    <span class="macro">SCM_DeclareLocalDottedVariable</span>(<span class="var">X</span>, <span class="num">0</span>);
    <span class="keyword">return</span> <span class="func">SCM_cons</span>(<span class="macro">SCM_Free</span>(<span class="var">I</span>),
                    <span class="var">X</span>);
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_2</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_2</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">I</span>, <span class="num">0</span>);
    <span class="keyword">return</span> <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_1</span>), <span class="num">-1</span>, <span class="num">1</span>, <span class="var">I</span>);
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_3</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_3</span>)
{
    <span class="type">SCM</span> <span class="var">TMP_2</span>; <span class="type">SCM</span> <span class="var">CNTER_1</span>;
    <span class="keyword">return</span> ((<span class="var">INDEX</span> = <span class="macro">thing0</span>),
            (<span class="var">CNTER_1</span> = <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_0</span>), <span class="num">1</span>, <span class="num">0</span>),
             <span class="var">TMP_2</span> = <span class="func">SCM_cons</span>(<span class="macro">thing2</span>,
                              <span class="macro">thing3</span>),
             (<span class="var">TMP_2</span> = <span class="func">SCM_allocate_box</span>(<span class="var">TMP_2</span>),
              ((<span class="macro">SCM_Content</span>(<span class="var">TMP_2</span>) =
               <span class="macro">SCM_invoke1</span>(<span class="var">CNTER_1</span>, <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>
                                              (<span class="func">function_2</span>), <span class="num">1</span>, <span class="num">0</span>))),
               ((<span class="var">CNTER_1</span> != <span class="macro">SCM_false</span>)
                ? <span class="macro">SCM_invoke1</span>(<span class="var">CNTER_1</span>,
                              <span class="macro">SCM_Content</span>(<span class="var">TMP_2</span>))
                : <span class="macro">SCM_CheckedGlobal</span>(<span class="var">INDEX</span>))))));
}

<span class="comment">/* Expression: */</span>
<span class="type">int</span> <span class="func">main</span>(<span class="type">void</span>)
{
    <span class="func">SCM_print</span>(<span class="macro">SCM_invoke0</span>(<span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_3</span>),
                                    <span class="num">0</span>, <span class="num">0</span>)));
    <span class="keyword">return</span> <span class="num">0</span>;
}

<span class="comment">/* End of generated code */</span></pre></td></tr></table></div>

<p>Также стоит взглянуть на функции <code class="c"><span class="func">function_1</span></code> и <code class="c"><span class="func">function_2</span></code> в раскрытом
виде, без макросов (кроме <code class="c"><span class="macro">va_arg</span></code>). Остальные выражения раскрываются
аналогично.</p>

<pre class="c"><span class="keyword">struct</span> <span class="type">function_1</span> {
    <span class="type">SCM</span>     (*<span class="var">behavior</span>)(<span class="type">void</span>);
    <span class="type">long</span>    <span class="var">arity</span>;
    <span class="type">SCM</span>     <span class="var">I</span>;
};

<span class="type">SCM</span> <span class="func">function_1</span>(<span class="keyword">struct</span> <span class="type">function_1</span> *<span class="var">self_</span>,
               <span class="type">unsigned</span> <span class="type">long</span> <span class="var">size_</span>,
               <span class="type">va_list</span> <span class="var">arguments_</span>)
{
    <span class="type">SCM</span> <span class="var">X</span> = <span class="func">SCM_list</span>(<span class="var">size_</span> - <span class="num">0</span>, <span class="var">arguments_</span>);
    <span class="keyword">return</span> <span class="func">SCM_cons</span>(((<span class="var">self_</span>)-><span class="var">I</span>), <span class="var">X</span>);
}

<span class="keyword">struct</span> <span class="type">function_2</span> {
    <span class="type">SCM</span>     (*<span class="var">behavior</span>)(<span class="type">void</span>);
    <span class="type">long</span>    <span class="var">arity</span>;
};

<span class="type">SCM</span> <span class="func">function_2</span>(<span class="keyword">struct</span> <span class="type">function_2</span> *<span class="var">self_</span>,
               <span class="type">unsigned</span> <span class="type">long</span> <span class="var">size_</span>,
               <span class="type">va_list</span> <span class="var">arguments_</span>)
{
    <span class="type">SCM</span> <span class="var">I</span> = <span class="macro">va_arg</span>(<span class="var">arguments_</span>, <span class="type">SCM</span>);
    <span class="keyword">return</span> <span class="func">SCM_close</span>(((<span class="type">SCM</span>(*)(<span class="type">void</span>)) <span class="func">function_1</span>), <span class="num">-1</span>, <span class="num">1</span>, <span class="var">I</span>);
}</pre>

<p>Если откомпилировать получившуюся программу любым компилятором, поддерживающим
стандарт C90 (например, <code>gcc</code>), подключив к ней необходимые библиотеки,
о которых мы упоминали, то получится (весьма небольшой) исполнимый файл,
который (весьма быстро<a class="footref" href="zz_footnotes.html#foot10.6"><sup>6</sup></a>) выдаёт ожидаемый результат.<a class="footref" href="zz_footnotes.html#foot10.7"><sup>7</sup></a></p>

<pre class="shell"><span class="prompt">%</span> <span class="cmd">gcc</span> <span class="opt">-ansi</span> <span class="opt">-pedantic</span> <span class="arg">chap10ex.c</span> <span class="arg">scheme.o</span> <span class="arg">schemelib.o</span>
<span class="prompt">%</span> <span class="cmd">time</span> <span class="arg">a.out</span>
(2 3)
0.010u 0.000s 0:00.00 0.0% 3+5k 0+0io 0pf+0w
<span class="prompt">%</span> <span class="cmd">size</span> <span class="arg">a.out</span>
text    data    bss     dec     hex
28762   4096    32      32800   8020</pre>


<h2 id="cc/sect:data"><span class="wrap"><span class="seq">10.9.</span><span class="title">Представление данных</span></span></h2>

<!--\indexC*{scheme.h}{"scheme.h"}-->
<!--\indexC{malloc}-->
<!--\indexR{сборка мусора}-->
<p>В этом разделе мы займёмся разбором макросов, описываемых в файле
<code>"scheme.h"</code>. Нет нужды повторять, что целью данного <em>упражнения</em>
является ознакомление, объяснение и демонстрация разнообразных приёмов, а
не создание самого быстрого и эффективного в мире компилятора. Поэтому мы
не будем обременять себя проблемами управления памятью; все выделения памяти
выполняются простыми вызовами <code class="c"><span class="func">malloc</span></code>, так что при желании будет весьма
просто подключить к программам сторонний консервативный сборщик мусора,
например, известный Boehm GC <span class="cite">[<a href="z1_bibliography.html#bw88">BW88</a>]</span>.</p>

<!--\indexR{динамическая типизация}-->
<!--\indexR{выравнивание}-->
<p>В Лиспе и Scheme принята динамическая типизация, то есть тип любого значения
всегда можно узнать во время исполнения программы. Соответственно, эту
информацию необходимо где-то хранить. Одной из основных головных болей
разработчиков реализаций динамически типизированных языков является как раз
эффективное связывание значений с их типами. Мало того, значения ещё могут быть
различного размера, так как некоторые из них представляют собой произвольные
наборы других значений. С этой проблемой можно справиться, применив косвенную
адресацию — указатели всегда имеют постоянный размер. Объекты будут
динамически создаваться в памяти, обращаться к ним будем посредством указателей,
а их типы можно размещать, например, в начале выделенных фрагментов памяти.
Неудобство (по сравнению со статически типизированными языками, где вопросы
с типами уже решены до исполнения программы) здесь в том, что простые значения
вроде чисел не могут быть эффективно использованы напрямую, только через
указатели. Ситуацию можно исправить несколькими способами. Один из них основан
на том, что в современных компьютерах данные в памяти выравниваются по границе
четырёх или восьми байт, что оставляет два-три младших бита адресов
неиспользуемыми. Этими битами можно закодировать информацию о виде значения, на
которое ссылается указатель. А если значение является числом, то почему бы
не записать его вместо адреса? Мы так и поступим с целыми числами, сделав работу
с ними более эффективной, но отдав за это один значащий бит, что несколько
уменьшит диапазон непосредственно представимых значений. Конечно, есть и другие
варианты, неплохую их подборку можно найти в <span class="cite">[<a href="z1_bibliography.html#gud93">Gud93</a>]</span>.</p>

<!--\indexR{представление!объектов Scheme на Си}-->
<p>Возвращаемся к насущному; взгляните на рисунок <a href="#cc/data/pic:tagptr">10.5</a>.
Значения Scheme представляются такими значениями Си, что если их младший бит
равен единице, то остальные биты считаются представлением некоторого целого
числа. Например, на 32-битных машинах получаются 31-битные числа. Если же
младший бит нулевой, то это адрес первого поля соответствующего значения Scheme.
Тип этого значения расположен <em>перед</em><a class="footref" href="zz_footnotes.html#foot10.8"><sup>8</sup></a> его полями, как у <span class="cite">[<a href="z1_bibliography.html#dps94a">DPS94a</a>]</span>. Сами значения представляются
обычными структурами данных Си. Их тип — как вы уже, наверное, догадались
— называется <code class="c"><span class="type">SCM</span></code>.</p>

<!--\indexC{SCM}-->
<pre class="c"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="type">SCM_object</span> *<span class="type">SCM</span>;</pre>

<div class="image" id="cc/data/pic:tagptr">
<img src="images/png30.png" alt="Представление чисел и значений SCM в битовой форме" style="width: 4.07in">
<span class="caption">Рис. 10.5. Представление значений Scheme в Си.</span>
</div>

<!--\indexC*{SCM_FixnumP}{SCM\_FixnumP}-->
<!--\indexC*{SCM_Fixnum2Int}{SCM\_Fixnum2Int}-->
<!--\indexC*{SCM_Int2Fixnum}{SCM\_Int2Fixnum}-->
<p>Макрос <code class="c"><span class="macro">SCM_FixnumP</span></code> позволяет отличить целые числа от указателей.
Приведением типов занимаются макросы <code class="c"><span class="macro">SCM_Fixnum2Int</span></code> и
<code class="c"><span class="macro">SCM_Int2Fixnum</span></code>. Например, числу 37 в Scheme соответствует число 75 в Си.</p>

<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_FixnumP</span>(<span class="var">x</span>)    ((<span class="type">unsigned</span> <span class="type">long</span>)(<span class="var">x</span>) &amp; <span class="num">1UL</span>)
<span class="pre">#define</span> <span class="macro">SCM_Fixnum2Int</span>(<span class="var">x</span>) ((<span class="type">long</span>)(<span class="var">x</span>) &gt;&gt; <span class="num">1</span>)
<span class="pre">#define</span> <span class="macro">SCM_Int2Fixnum</span>(<span class="var">i</span>) ((<span class="type">SCM</span>)(((<span class="var">i</span>) &lt;&lt; <span class="num">1</span>) | <span class="num">1UL</span>))</pre>

<p>Если значение <code class="c"><span class="type">SCM</span></code> не является числом, то это указатель на объект типа
<code class="c"><span class="type">SCM_object</span></code>. Данное объединение все типы данных, поддерживаемые языком.
Некоторых типов там нет, в частности: чисел с плавающей запятой, векторов,
портов. Но самое важное в Scheme — точечные пары<a class="footref" href="zz_footnotes.html#foot10.9"><sup>9</sup></a>, замыкания и продолжения — мы
обязательно реализуем.</p>

<!--\indexC*{SCM_object}{SCM\_object}-->
<pre class="c"><span class="keyword">union</span> <span class="type">SCM_object</span> {
    <span class="keyword">struct</span> <span class="type">SCM_pair</span> {
        <span class="type">SCM</span> <span class="var">cdr</span>;
        <span class="type">SCM</span> <span class="var">car</span>;
    } <span class="var">pair</span>;

    <span class="keyword">struct</span> <span class="type">SCM_string</span> {
        <span class="type">char</span> <span class="var">Cstring</span>[<span class="num">8</span>];
    } <span class="var">string</span>;

    <span class="keyword">struct</span> <span class="type">SCM_symbol</span> {
        <span class="type">SCM</span> <span class="var">pname</span>;
    } <span class="var">symbol</span>;

    <span class="keyword">struct</span> <span class="type">SCM_box</span> {
        <span class="type">SCM</span> <span class="var">content</span>;
    } <span class="var">box</span>;

    <span class="keyword">struct</span> <span class="type">SCM_subr</span> {
        <span class="type">SCM</span> (*<span class="var">behavior</span>)(<span class="type">void</span>);
        <span class="type">long</span> <span class="var">arity</span>;
    } <span class="var">subr</span>;

    <span class="keyword">struct</span> <span class="type">SCM_closure</span> {
        <span class="type">SCM</span> (*<span class="var">behavior</span>)(<span class="type">void</span>);
        <span class="type">long</span> <span class="var">arity</span>;
        <span class="type">SCM</span> <span class="var">environment</span>[<span class="num">1</span>];
    } <span class="var">closure</span>;

    <span class="keyword">struct</span> <span class="type">SCM_escape</span> {
        <span class="keyword">struct</span> <span class="type">SCM_jmp_buf</span> *<span class="var">stack_address</span>;
    } <span class="var">escape</span>;
};</pre>

<p>Полноценные значения Scheme, представляемые <code class="c"><span class="type">SCM_object</span></code>, должны содержать
внутри себя собственный тип. Мы будем его хранить весьма специфичным образом.
Собственно метка типа представляется перечислением <code class="c"><span class="type">SCM_tag</span></code>. Числовые
константы выбраны так, чтобы гарантировать некоторое количество незначащих
битов, например, для нужд сборщика мусора. В памяти метка должна располагаться
не абы как, а быть строго выровненной по размеру <code class="c"><span class="type">SCM</span></code> — именно для этого
в объединение <code class="c"><span class="type">SCM_header</span></code> добавлена заглушка <code class="c"><span class="var">ignored</span></code>. Наконец, объекты
вместе с информацией об их типе будут представляться объединениями
<code class="c"><span class="type">SCM_unwrapped_object</span></code>.</p>

<!--\indexC*{SCM_tag}{SCM\_tag}-->
<!--\indexC*{SCM_header}{SCM\_header}-->
<!--\indexC*{SCM_unwrapped_object}{SCM\_unwrapped\_object}-->
<pre class="c"><span class="keyword">enum</span> <span class="type">SCM_tag</span> {
    <span class="var">SCM_NULL_TAG</span>      = <span class="num">0xAAA0</span>,
    <span class="var">SCM_PAIR_TAG</span>      = <span class="num">0xAAA1</span>,
    <span class="var">SCM_BOOLEAN_TAG</span>   = <span class="num">0xAAA2</span>,
    <span class="var">SCM_UNDEFINED_TAG</span> = <span class="num">0xAAA3</span>,
    <span class="var">SCM_SYMBOL_TAG</span>    = <span class="num">0xAAA4</span>,
    <span class="var">SCM_STRING_TAG</span>    = <span class="num">0xAAA5</span>,
    <span class="var">SCM_SUBR_TAG</span>      = <span class="num">0xAAA6</span>,
    <span class="var">SCM_CLOSURE_TAG</span>   = <span class="num">0xAAA7</span>,
    <span class="var">SCM_ESCAPE_TAG</span>    = <span class="num">0xAAA8</span>,
};

<span class="keyword">union</span> <span class="type">SCM_header</span> {
    <span class="keyword">enum</span> <span class="type">SCM_tag</span> <span class="var">tag</span>;
    <span class="type">SCM</span> <span class="var">ignored</span>;
};

<span class="keyword">union</span> <span class="type">SCM_unwrapped_object</span> {
    <span class="keyword">struct</span> <span class="type">SCM_unwrapped_immediate_object</span> {
        <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;
    };

    <span class="keyword">struct</span> <span class="type">SCM_unwrapped_pair</span> {
        <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;
        <span class="type">SCM</span> <span class="var">cdr</span>;
        <span class="type">SCM</span> <span class="var">car</span>;
    } <span class="var">pair</span>;

    <span class="keyword">struct</span> <span class="type">SCM_unwrapped_string</span> {
        <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;
        <span class="type">char</span> <span class="var">Cstring</span>[<span class="num">8</span>];
    } <span class="var">string</span>;

    <span class="keyword">struct</span> <span class="type">SCM_unwrapped_symbol</span> {
        <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;
        <span class="type">SCM</span> <span class="var">pname</span>;
    } <span class="var">symbol</span>;

    <span class="keyword">struct</span> <span class="type">SCM_unwrapped_subr</span> {
        <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;
        <span class="type">SCM</span> (*<span class="var">behavior</span>)(<span class="type">void</span>);
        <span class="type">long</span> <span class="var">arity</span>;
    } <span class="var">subr</span>;

    <span class="keyword">struct</span> <span class="type">SCM_unwrapped_closure</span> {
        <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;
        <span class="type">SCM</span> (*<span class="var">behavior</span>)(<span class="type">void</span>);
        <span class="type">long</span> <span class="var">arity</span>;
        <span class="type">SCM</span> <span class="var">environment</span>[<span class="num">1</span>];
    } <span class="var">closure</span>;

    <span class="keyword">struct</span> <span class="type">SCM_unwrapped_escape</span> {
        <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;
        <span class="keyword">struct</span> <span class="type">SCM_jmp_buf</span> *<span class="var">stack_address</span>;
    } <span class="var">escape</span>;
};</pre>

<p>Следующие макросы помогают с приведением и определением типов объектов. Они
будут полезными по большей части лишь библиотечным функциями, потому как только
им необходимо различать <code class="c"><span class="type">SCM</span></code> и <code class="c"><span class="type">SCMref</span></code>.</p>

<!--\indexC{SCMref}-->
<!--\indexC*{SCM_Wrap}{SCM\_Wrap}-->
<!--\indexC*{SCM_Unwrap}{SCM\_Unwrap}-->
<!--\indexC*{SCM_2tag}{SCM\_2tag}-->
<pre class="c"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="type">SCM_unwrapped_object</span> *<span class="type">SCMref</span>;

<span class="pre">#define</span> <span class="macro">SCM_Wrap</span>(<span class="var">x</span>)   ((<span class="type">SCM</span>)    (((<span class="keyword">union</span> <span class="type">SCM_header</span>*) <span class="var">x</span>) + <span class="num">1</span>))
<span class="pre">#define</span> <span class="macro">SCM_Unwrap</span>(<span class="var">x</span>) ((<span class="type">SCMref</span>) (((<span class="keyword">union</span> <span class="type">SCM_header</span>*) <span class="var">x</span>) - <span class="num">1</span>))
<span class="pre">#define</span> <span class="macro">SCM_2tag</span>(<span class="var">x</span>)   ((<span class="macro">SCM_Unwrap</span>((<span class="type">SCM</span>) <span class="var">x</span>))-><span class="var">object</span>.<span class="var">header</span>.<span class="var">tag</span>)</pre>

<p>Наконец, адреса функций, написанных на Си, будут храниться (но
не использоваться) как указатели на функции без аргументов, возвращающие
<code class="c"><span class="type">SCM</span></code>. Макрос <code class="c"><span class="macro">SCM_CfunctionAddress</span></code> приводит их к этому типу.</p>

<!--\indexC*{SCM_CfunctionAddress}{SCM\_CfunctionAddress}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_CfunctionAddress</span>(<span class="var">Cfunction</span>) ((<span class="type">SCM</span> (*)(<span class="type">void</span>)) <span class="var">Cfunction</span>)</pre>


<h3 id="cc/data/ssect:values"><span class="wrap"><span class="seq">10.9.1.</span><span class="title">Объявления значений</span></span></h3>

<p>Кроме всего прочего, <code>scheme.h</code> определяет специальные макросы для
статического создания значений Scheme. Их имена начинаются на <code class="c"><span class="macro">SCM_Define</span></code>.
Чтобы получить точечную пару, достаточно объявить новую переменную типа
<code class="c"><span class="type">SCM_unwrapped_pair</span></code>. Символы и прочие значения объявляются аналогично.
Всякий раз сначала создаётся объект, а затем берётся его адрес и превращается
в корректное значение Scheme с помощью <code class="c"><span class="macro">SCM_Wrap</span></code>.</p>

<!--\indexC*{SCM_DefinePair}{SCM\_DefinePair}-->
<!--\indexC*{SCM_DefineSymbol}{SCM\_DefineSymbol}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_DefinePair</span>(<span class="var">pair</span>, <span class="var">car</span>, <span class="var">cdr</span>)  \
  <span class="keyword">static</span> <span class="keyword">struct</span> <span class="type">SCM_unwrapped_pair</span> <span class="var">pair</span> = {{<span class="var">SCM_PAIR_TAG</span>}, <span class="var">cdr</span>, <span class="var">car</span>}
<span class="pre">#define</span> <span class="macro">SCM_DefineSymbol</span>(<span class="var">symbol</span>, <span class="var">name</span>)  \
  <span class="keyword">static</span> <span class="keyword">struct</span> <span class="type">SCM_unwrapped_symbol</span> <span class="var">symbol</span> = {{<span class="var">SCM_SYMBOL_TAG</span>}, <span class="var">name</span>}</pre>

<!--\indexR{представление!строк}-->
<p>Со строками всё немного сложнее, так как в Си нельзя статически инициализировать
структуры переменного размера. Также следует быть очень осторожными со строками
Си: не перепутать их содержимое с адресом и не забыть о нулевом байте в конце.
Мы решим данные затруднения, объявляя для каждой статической строки личную
структуру. Собственно содержимое строк будет представляться родными строками Си.</p>

<!--\indexC*{SCM_DefineString}{SCM\_DefineString}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_DefineString</span>(<span class="var">Cname</span>, <span class="var">string</span>) \
  <span class="keyword">struct</span> <span class="var">Cname</span><span class="pre">##</span><span class="type">_struct</span> {               \
      <span class="keyword">union</span> <span class="type">SCM_header</span> <span class="var">header</span>;          \
      <span class="type">char</span> <span class="var">Cstring</span>[<span class="num">1</span> + <span class="keyword">sizeof</span>(<span class="var">string</span>)]; \
  };                                    \
  <span class="keyword">static</span> <span class="keyword">struct</span> <span class="var">Cname</span><span class="pre">##</span><span class="type">_struct</span> <span class="var">Cname</span> =  \
      {{<span class="var">SCM_STRING_TAG</span>}, <span class="var">string</span>}</pre>

<p>Также нам будут необходимы несколько предопределённых значений. Для программ
важны только их имена и типы, поэтому они объявляются как непосредственные
значения. Мы воспользуемся <code class="c"><span class="macro">SCM_Wrap</span></code> для приведения их к типу <code class="c"><span class="type">SCM</span></code>.</p>

<!--\indexC*{SCM_DefineImmediateObject}{SCM\_DefineImmediateObject}-->
<!--\indexC*{SCM_true}{SCM\_true}-->
<!--\indexC*{SCM_false}{SCM\_false}-->
<!--\indexC*{SCM_nil}{SCM\_nil}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_DefineImmediateObject</span>(<span class="var">name</span>, <span class="var">tag</span>) \
  <span class="keyword">struct</span> <span class="type">SCM_unwrapped_immediate_object</span> <span class="var">name</span> = {{<span class="var">tag</span>}}

<span class="macro">SCM_DefineImmediateObject</span>(<span class="var">SCM_true_object</span>,  <span class="var">SCM_BOOLEAN_TAG</span>)
<span class="macro">SCM_DefineImmediateObject</span>(<span class="var">SCM_false_object</span>, <span class="var">SCM_BOOLEAN_TAG</span>)
<span class="macro">SCM_DefineImmediateObject</span>(<span class="var">SCM_nil_object</span>,   <span class="var">SCM_PAIR_TAG</span>)

<span class="pre">#define</span> <span class="macro">SCM_true</span>  <span class="macro">SCM_Wrap</span>(&amp;<span class="var">SCM_true_object</span>)
<span class="pre">#define</span> <span class="macro">SCM_false</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">SCM_false_object</span>)
<span class="pre">#define</span> <span class="macro">SCM_nil</span>   <span class="macro">SCM_Wrap</span>(&amp;<span class="var">SCM_nil_object</span>)</pre>

<p>Логические значения Scheme не тождественны логическим значениям Си, поэтому
соответствующее преобразование не будет лишним. Определим для этого макрос
<code class="c"><span class="macro">SCM_2bool</span></code>:</p>

<!--\indexC*{SCM_2bool}{SCM\_2bool}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_2bool</span>(<span class="var">i</span>) ((<span class="var">i</span>) ? <span class="macro">SCM_true</span> : <span class="macro">SCM_false</span>)</pre>

<!--\indexR{проверки типов}-->
<!--\indexR{соглашения именования!предикатов в Си}-->
<p>Также мы определим несколько вспомогательных макросов для проверки типов и
простейших операций со значениями. Предикаты имеют суффикс <code class="c"><span class="macro">P</span></code>, который
означает, что они возвращают логические значения Си.</p>

<!--\indexC*{SCM_Car}{SCM\_Car}-->
<!--\indexC*{SCM_Cdr}{SCM\_Cdr}-->
<!--\indexC*{SCM_NullP}{SCM\_NullP}-->
<!--\indexC*{SCM_PairP}{SCM\_PairP}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_Car</span>(<span class="var">x</span>)     (<span class="macro">SCM_Unwrap</span>(<span class="var">x</span>)-><span class="var">pair</span>.<span class="var">car</span>)
<span class="pre">#define</span> <span class="macro">SCM_Cdr</span>(<span class="var">x</span>)     (<span class="macro">SCM_Unwrap</span>(<span class="var">x</span>)-><span class="var">pair</span>.<span class="var">cdr</span>)
<span class="pre">#define</span> <span class="macro">SCM_NullP</span>(<span class="var">x</span>)   ((<span class="var">x</span>) == <span class="macro">SCM_nil</span>)
<span class="pre">#define</span> <span class="macro">SCM_EqP</span>(<span class="var">x</span>, <span class="var">y</span>)  ((<span class="var">x</span>) == (<span class="var">y</span>))

<span class="pre">#define</span> <span class="macro">SCM_PairP</span>(<span class="var">x</span>)   \
  ((!<span class="macro">SCM_FixnumP</span>(<span class="var">x</span>)) &amp;&amp; (<span class="macro">SCM_2tag</span>(<span class="var">x</span>) == <span class="var">SCM_PAIR_TAG</span>))

<span class="pre">#define</span> <span class="macro">SCM_SymbolP</span>(<span class="var">x</span>) \
  ((!<span class="macro">SCM_FixnumP</span>(<span class="var">x</span>)) &amp;&amp; (<span class="macro">SCM_2tag</span>(<span class="var">x</span>) == <span class="var">SCM_SYMBOL_TAG</span>))

<span class="pre">#define</span> <span class="macro">SCM_StringP</span>(<span class="var">x</span>) \
  ((!<span class="macro">SCM_FixnumP</span>(<span class="var">x</span>)) &amp;&amp; (<span class="macro">SCM_2tag</span>(<span class="var">x</span>) == <span class="var">SCM_STRING_TAG</span>))</pre>

<p id="cc/data/values/par:macros">Естественно, макросы вроде
<code class="c"><span class="macro">SCM_Car</span></code> и
<code class="c"><span class="macro">SCM_Cdr</span></code> будут использоваться
исключительно в тех случаях, когда компилятор <em>знает</em>, что значение имеет
подходящий тип. Следующие макросы для арифметических действий, например, этого
заранее знать не могут, поэтому в них проверки типов выполняются явно. Конечно,
таким образом мы лишаемся возможной оптимизации в случае, если типы всё же
будут известны<a class="footref" href="zz_footnotes.html#foot10.10"><sup>10</sup></a>,
но этот вопрос уже обсуждался: с точки зрения
педагогики важнее показать всю массу вариантов, нежели рассмотреть в деталях
пару-тройку лучших. Если бы мы хотели добиться максимальной эффективности,
компилятор был бы устроен совсем не так и выдавал бы совершенно иной код.</p>

<!--\indexC*{SCM_Plus}{SCM\_Plus}-->
<!--\indexC*{SCM_GtP}{SCM\_GtP}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_Plus</span>(<span class="var">x</span>, <span class="var">y</span>)                                     \
  ((<span class="macro">SCM_FixnumP</span>(<span class="var">x</span>) &amp;&amp; <span class="macro">SCM_FixnumP</span>(<span class="var">y</span>))                      \
   ? <span class="macro">SCM_Int2Fixnum</span>(<span class="macro">SCM_Fixnum2Int</span>(<span class="var">x</span>) + <span class="macro">SCM_Fixnum2Int</span>(<span class="var">y</span>)) \
   : <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_PLUS</span>))

<span class="pre">#define</span> <span class="macro">SCM_GtP</span>(<span class="var">x</span>, <span class="var">y</span>)                                      \
  ((<span class="macro">SCM_FixnumP</span>(<span class="var">x</span>) &amp;&amp; <span class="macro">SCM_FixnumP</span>(<span class="var">y</span>))                      \
   ? <span class="macro">SCM_2bool</span>(<span class="macro">SCM_Fixnum2Int</span>(<span class="var">x</span>) > <span class="macro">SCM_Fixnum2Int</span>(<span class="var">y</span>))      \
   : <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_GTP</span>))</pre>


<h3 id="cc/data/ssect:global"><span class="wrap"><span class="seq">10.9.2.</span><span class="title">Глобальные переменные</span></span></h3>

<!--\indexR{неинициализированные переменные}-->
<!--\indexR{переменные!неинициализированные}-->
<p>Для получения значения глобальной переменной используется макрос
<code class="c"><span class="macro">SCM_CheckedGlobal</span></code>, который
проверяет, была ли она инициализирована или нет. Следовательно, необходимо выделить какое-то
определённое значение Си для обозначения неинициализированных переменных Scheme
— назовём его <code class="c"><span class="macro">SCM_undefined</span></code>. Изменяемые
глобальные переменные при создании просто инициализируются (в Си) этим
значением, показывающим, что (в Scheme) они ещё не были инициализированы.</p>

<!--\indexC*{SCM_undefined}{SCM\_undefined}-->
<!--\indexC*{SCM_CheckedGlobal}{SCM\_CheckedGlobal}-->
<!--\indexC*{SCM_DefineInitializedGlobalVariable}{SCM\_DefineInitializedGlobalVariable}-->
<!--\indexC*{SCM_DefineGlobalVariable}{SCM\_DefineGlobalVariable}-->
<pre class="c"><span class="macro">SCM_DefineImmediateObject</span>(<span class="var">SCM_undefined_object</span>, <span class="var">SCM_UNDEFINED_TAG</span>);
<span class="pre">#define</span> <span class="macro">SCM_undefined</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">SCM_undefined_object</span>)

<span class="pre">#define</span> <span class="macro">SCM_CheckedGlobal</span>(<span class="var">Cname</span>) \
  ((<span class="var">Cname</span> != <span class="macro">SCM_undefined</span>) ? <span class="var">Cname</span>
                            : <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_UNINITIALIZED</span>))

<span class="pre">#define</span> <span class="macro">SCM_DefineInitializedGlobalVariable</span>(<span class="var">Cname</span>, <span class="var">string</span>, <span class="var">value</span>) \
  <span class="type">SCM</span> <span class="var">Cname</span> = <span class="macro">SCM_Wrap</span>(<span class="var">value</span>)

<span class="pre">#define</span> <span class="macro">SCM_DefineGlobalVariable</span>(<span class="var">Cname</span>, <span class="var">string</span>)      \
  <span class="macro">SCM_DefineInitializedGlobalVariable</span>(<span class="var">Cname</span>, <span class="var">string</span>, \
                                             &amp;<span class="var">SCM_undefined_object</span>)</pre>

<p>Ещё одной важным делом является связывание предопределённых значений
с предопределёнными переменными. Например, если мы хотим пользоваться
в программах <code><span class="var">NIL</span></code> для обозначения пустого списка
<code><span class="hash">()</span></code>, то следует
определить в Си глобальную переменную <code class="c"><span class="var">NIL</span></code>
со значением <code class="c"><span class="var">SCM_nil_object</span></code>.
Это определение (вместе с множеством других) находится
в файле <code>schemelib.c</code>:</p>

<pre class="c"><span class="macro">SCM_DefineInitializedGlobalVariable</span>(<span class="var">NIL</span>, <span class="string">"NIL"</span>, &amp;<span class="var">SCM_nil_object</span>);
<span class="macro">SCM_DefineInitializedGlobalVariable</span>(<span class="var">F</span>,   <span class="string">"F"</span>,   &amp;<span class="var">SCM_false_object</span>);
<span class="macro">SCM_DefineInitializedGlobalVariable</span>(<span class="var">T</span>,   <span class="string">"T"</span>,   &amp;<span class="var">SCM_true_object</span>);</pre>

<p>Многое можно выразить с помощью этих трёх значений, но нам бы хотелось иметь
в распоряжении также и знакомые функции: <code><span class="func">CONS</span></code>, <code><span class="func">CAR</span></code> и т. д. Они
определяются макросом <code class="c"><span class="macro">SCM_DefinePredefinedFunctionVariable</span></code>. Вот его
определение вместе с несколькими примерами:</p>

<!--\indexC*{SCM_DefinePredefinedFunctionVariable}{SCM\_DefinePredefinedFunctionVariable}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">subr</span>, <span class="var">string</span>,           \
                                             <span class="var">arity</span>, <span class="var">Cfunction</span>)       \
  <span class="keyword">static</span> <span class="keyword">struct</span> <span class="type">SCM_unwrapped_subr</span> <span class="var">subr</span><span class="pre">##</span><span class="var">_object</span> =                   \
      {{<span class="var">SCM_SUBR_TAG</span>}, <span class="var">Cfunction</span>, <span class="var">arity</span>};                            \
  <span class="macro">SCM_DefineInitializedGlobalVariable</span>(<span class="var">subr</span>, <span class="var">string</span>, &amp;(<span class="var">subr</span><span class="pre">##</span><span class="var">_object</span>))

<span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">CAR</span>,  <span class="string">"CAR"</span>,  <span class="num">1</span>, <span class="func">SCM_car</span>);
<span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">CONS</span>, <span class="string">"CONS"</span>, <span class="num">2</span>, <span class="func">SCM_cons</span>);
<span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">EQN</span>,  <span class="string">"="</span>,    <span class="num">2</span>, <span class="func">SCM_eqnp</span>);
<span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">EQ</span>,   <span class="string">"EQ?"</span>,  <span class="num">2</span>, <span class="func">SCM_eqp</span>);</pre>

<p>Значения изменяемых глобальных переменных размещаются в коробках. Просмотр или
изменение подобных значений выполняются с помощью макроса
<code class="c"><span class="macro">SCM_Content</span></code>,
определяемого следующим образом:</p>

<!--\indexC*{SCM_Content}{SCM\_Content}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_Content</span>(<span class="var">e</span>) ((<span class="var">e</span>)-><span class="var">box</span>.<span class="var">content</span>)</pre>


<h3 id="cc/data/ssect:func"><span class="wrap"><span class="seq">10.9.3.</span><span class="title">Определения функций</span></span></h3>

<p>Осталось лишь рассмотреть представление в памяти функций. Важно тщательно
проработать этот аспект, так как от него существенно зависят возможности
взаимодействия Scheme и Си.</p>

<p>Примитивы с фиксированной арностью представляются функциями Си той же арности.
Следовательно, функцию <code><span class="func">cons</span></code> можно будет вызвать простым и легко
запоминающимся способом: <code class="c"><span class="func">SCM_cons</span>(<i>a</i>, <i>d</i>)</code>.</p>

<!--\indexR{представление!замыканий}-->
<p>Остальные функции, являющиеся полноценными объектами Scheme, требуют бóльших
усилий. Им может быть передано любое количество аргументов. Они могут быть
результатами вычислений. При вызовах через <code><span class="func">apply</span></code> аргументы им передаются
по-особому. Реализовать всё это, да ещё и эффективно — отнюдь не тривиальная
задача. И снова, желая показать всё множество вариаций, мы позволим себе
применить для обычных функций слегка необычный, но весьма последовательный
во всех смыслах подход (понимая, однако, что его быстродействие оставляет желать
лучшего).
<span class="see">[см. упр. <a href="#cc/ex:boost-calls">10.1</a>]</span></p>

<p>Замыкания будут представляться специальными структурами. Первые два поля
содержат указатель на соответствующую функцию и её арность. Остальные хранят
значения замкнутых свободных переменных. Макрос <code class="c"><span class="macro">SCM_DefineClosure</span></code>
определяет соответствующие типы структур Си для всех используемых замыканий.</p>

<!--\indexC*{SCM_DefineClosure}{SCM\_DefineClosure}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_DefineClosure</span>(<span class="var">struct_name</span>, <span class="var">fields</span>) \
  <span class="keyword">struct</span> <span class="var">struct_name</span> {                         \
      <span class="type">SCM</span> (*<span class="var">behavior</span>)(<span class="type">void</span>);                   \
      <span class="type">long</span> <span class="var">arity</span>;                              \
      <span class="var">fields</span>                                   \
  }</pre>

<!--\indexR{переменная арность!в Си}-->
<p>Первым аргументом замыканий, вызываемых <code class="c"><span class="func">SCM_invoke</span></code>, являются они сами;
так реализуется возможность доступа к замкнутому окружению. Если функция
вызывается с неправильным количеством аргументов — это ошибка, о которой
необходимо сообщить. Проверка арности перекладывается на <code class="c"><span class="func">SCM_invoke</span></code>, так
что функции могут быть уверены в количестве аргументов. Единственным непонятным
моментом остаются функции с переменной арностью: здесь, видимо, придётся явно
передавать им количество аргументов, так как в Си нет возможности его узнать.
Поэтому будем считать, что все функции вторым аргументом принимают количество
фактических аргументов вызова, а сами аргументы всегда передаются с помощью
специального механизма Си, определённого в заголовочном файле <code>&lt;stdarg.h&gt;</code>
(ранее <code>&lt;varargs.h&gt;</code>). Как мы и говорили, это не самое элегантное из
возможных решений; подход, используемый для примитивов, гораздо эффективнее.</p>


<!--\indexC*{self}{self\_}-->
<!--\indexC*{size}{size\_}-->
<!--\indexC*{arguments}{arguments\_}-->
<p>Аргументы объявляемых функций Си (<code class="c"><span class="var">self_</span></code>, <code class="c"><span class="var">size_</span></code> и <code class="c"><span class="var">arguments_</span></code>)
названы так, чтобы их нельзя было спутать с переменными Scheme (вспомните
о подчёркиваниях). Единственным интересным моментом остаётся инициализация
точечной переменной, собирающая в список все оставшиеся аргументы. Список так
список, зачем же ещё существует функция <code class="c"><span class="func">SCM_list</span></code>.</p>

<!--\indexC*{SCM_DeclareFunction}{SCM\_DeclareFunction}-->
<!--\indexC*{SCM_DeclareLocalVariable}{SCM\_DeclareLocalVariable}-->
<!--\indexC*{SCM_DeclareLocalDottedVariable}{SCM\_DeclareLocalDottedVariable}-->
<!--\indexC*{SCM_Free}{SCM\_Free}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_DeclareFunction</span>(<span class="var">Cname</span>) \
  <span class="type">SCM</span> <span class="var">Cname</span>(<span class="keyword">struct</span> <span class="var">Cname</span> *<span class="var">self_</span>,   \
            <span class="type">unsigned</span> <span class="type">long</span> <span class="var">size_</span>, <span class="type">va_list</span> <span class="var">arguments_</span>)

<span class="pre">#define</span> <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">Cname</span>, <span class="var">index</span>) \
  <span class="type">SCM</span> <span class="var">Cname</span> = <span class="macro">va_arg</span>(<span class="var">arguments_</span>, <span class="type">SCM</span>)

<span class="pre">#define</span> <span class="macro">SCM_DeclareLocalDottedVariable</span>(<span class="var">Cname</span>, <span class="var">index</span>) \
  <span class="type">SCM</span> <span class="var">Cname</span> = <span class="func">SCM_list</span>(<span class="var">size_</span> - <span class="var">index</span>, <span class="var">arguments_</span>)

<span class="pre">#define</span> <span class="macro">SCM_Free</span>(<span class="var">Cname</span>) ((<span class="var">self_</span>)-><span class="var">Cname</span>)</pre>

<p>И всё же в данном подходе есть что-то хорошее: вы только посмотрите, как
просто, понятно и красиво выражаются обращения к свободным переменным!</p>


<h2 id="cc/sect:runtime"><span class="wrap"><span class="seq">10.10.</span><span class="title">Библиотека времени исполнения</span></span></h2>

<!--\indexC*{SCM_print}{SCM\_print}-->
<!--\indexR{библиотека!времени исполнения}-->
<!--\indexR{функции!библиотечные}-->
<p>Библиотека времени исполнения (runtime library) — это набор функций,
написанных на Си. Эти функции реализуют возможности, необходимые для полноценной
работы программ, поэтому данная библиотека должна быть подключена ко всякой хоть
сколь-нибудь нетривиальной программе. Конечно, здесь мы лишь набросаем её общие
черты и не будем реализовывать большую часть утилитарных функций вроде
<code><span class="func">string-ref</span></code> или <code><span class="func">close-output-port</span></code>. Будут рассмотрены только самые
важные, типичные библиотечные функции (в частности, здесь нет функции
<code class="c"><span class="func">SCM_print</span></code>, которая используется в генерируемой нами <code class="c"><span class="func">main</span></code>).</p>


<h3 id="cc/runtime/ssect:alloc"><span class="wrap"><span class="seq">10.10.1.</span><span class="title">Выделение памяти</span></span></h3>

<p>В Си за управление памятью отвечает лично программист, так что сборщика мусора
у нас не будет, потому как его написание с нуля заняло бы слишком много времени.
За информацией об этом можете обратиться, например, к <span class="cite">[<a href="z1_bibliography.html#spi90">Spi90</a>,
<a href="z1_bibliography.html#wil92">Wil92</a>]</span><a class="footref" href="zz_footnotes.html#foot10.tr-1"><sup>*</sup></a>. Интеграцию с Бёмовским сборщиком мусора <span class="cite">[<a href="z1_bibliography.html#bw88">BW88</a>]</span> оставляем
вам в качестве упражнения.</p>

<p>Наиболее очевидная функция, требующая выделения памяти, — это <code><span class="func">cons</span></code>. Она
должна создать новую точечную пару, заполнить её поля (включая поле типа) и
вернуть адрес созданной пары в виде объекта типа <code class="c"><span class="type">SCM</span></code>.</p>

<!--\indexC*{SCM_cons}{SCM\_cons}-->
<!--\indexC{cons}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_cons</span>(<span class="type">SCM</span> <span class="var">a</span>, <span class="type">SCM</span> <span class="var">d</span>)
{
    <span class="type">SCMref</span> <span class="var">cell</span> = <span class="func">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">SCM_unwrapped_pair</span>));
    <span class="keyword">if</span> (!<span class="var">cell</span>)
    {
        <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_CANT_ALLOC</span>);
    }

    <span class="var">cell</span>-><span class="var">pair</span>.<span class="var">header</span>.<span class="var">tag</span> = <span class="var">SCM_PAIR_TAG</span>;
    <span class="var">cell</span>-><span class="var">pair</span>.<span class="var">car</span> = <span class="var">a</span>;
    <span class="var">cell</span>-><span class="var">pair</span>.<span class="var">cdr</span> = <span class="var">d</span>;
    <span class="keyword">return</span> <span class="macro">SCM_Wrap</span>(<span class="var">cell</span>);
}</pre>

<p>Замыкания создаются функцией <code class="c"><span class="func">SCM_close</span></code>. Их арность может быть любой, что
обосновывает использование функций переменной арности языка Си. Итак, нам надо
создать объект с типом <code class="c"><span class="var">SCM_CLOSURE_TAG</span></code> и заполнить его поля полученными
значениями. Порядок перечисления значений должен в точности совпадать
с порядком полей.</p>

<!--\indexC*{SCM_close}{SCM\_close}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_close</span>(<span class="type">SCM</span> (*<span class="var">Cfunction</span>)(<span class="type">void</span>), <span class="type">long</span> <span class="var">arity</span>,
              <span class="type">unsigned</span> <span class="type">long</span> <span class="var">size</span>, ...)
{
    <span class="type">unsigned</span> <span class="type">long</span> <span class="var">i</span>;
    <span class="type">va_list</span> <span class="var">args</span>;
    <span class="type">SCMref</span> <span class="var">result</span> = <span class="func">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">SCM_unwrapped_closure</span>)
                           + (<span class="var">size</span> - <span class="num">1</span>) * <span class="keyword">sizeof</span>(<span class="type">SCM</span>));
    <span class="keyword">if</span> (!<span class="var">result</span>)
    {
        <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_CANT_ALLOC</span>);
    }

    <span class="var">result</span>-><span class="var">closure</span>.<span class="var">header</span>.<span class="var">tag</span> = <span class="var">SCM_CLOSURE_TAG</span>;
    <span class="var">result</span>-><span class="var">closure</span>.<span class="var">behavior</span>   = <span class="var">Cfunction</span>;
    <span class="var">result</span>-><span class="var">closure</span>.<span class="var">arity</span>      = <span class="var">arity</span>;
    <span class="macro">va_start</span>(<span class="var">args</span>, <span class="var">size</span>);
    <span class="keyword">for</span> (<span class="var">i</span> = <span class="num">0</span>; <span class="var">i</span> &lt; <span class="var">size</span>; <span class="var">i</span>++) {
        <span class="var">result</span>-><span class="var">closure</span>.<span class="var">environment</span>[<span class="var">i</span>] = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
    }
    <span class="macro">va_end</span>(<span class="var">args</span>);

    <span class="keyword">return</span> <span class="macro">SCM_Wrap</span>(<span class="var">result</span>);
}</pre>


<h3 id="cc/runtime/ssect:pairs"><span class="wrap"><span class="seq">10.10.2.</span><span class="title">Функции над парами</span></span></h3>

<!--\indexR{проверки типов}-->
<!--\indexR{динамическая типизация}-->
<p>Функции <code><span class="func">car</span></code> и
<code><span class="func">set-car!</span></code> очень просты, но не следует их путать
с одноимёнными макросами. Данные функции типобезопасны в том смысле, что они
проверяют типы аргументов перед тем, как лезть непонятно куда в память. В общем
случае у каждой безопасной функции есть небезопасный аналог, который можно
использовать только тогда, когда компилятор полностью уверен в типе аргументов.
Несмотря на то, что Лисп динамически типизирован, программы на нём обычно
таковы, что как минимум две трети проверок типов, по мнению
<span class="cite">[<a href="z1_bibliography.html#hen92a">Hen92a</a>,
<a href="z1_bibliography.html#wc94">WC94</a>,
<a href="z1_bibliography.html#ser94">Ser94</a>]</span>,
можно смело убирать. Дело в том, что программисты
помнят о типах, выполняют часть проверок у себя в голове и не передают функциям
что попало. Хорошие компиляторы осведомлены о существовании «белкового
препроцессора» и оптимизируют код с учётом этого обстоятельства.</p>

<!--\indexC*{SCM_car}{SCM\_car}-->
<!--\indexC*{SCM_set_cdr}{SCM\_set\_cdr}-->
<!--\indexC{car}-->
<!--\indexC{set-cdr"!}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_car</span>(<span class="type">SCM</span> <span class="var">x</span>)
{
    <span class="keyword">if</span> (<span class="macro">SCM_PairP</span>(<span class="var">x</span>)) {
        <span class="keyword">return</span> <span class="macro">SCM_Car</span>(<span class="var">x</span>);
    }
    <span class="keyword">else</span> <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_CAR</span>);
}

<span class="type">SCM</span> <span class="func">SCM_set_cdr</span>(<span class="type">SCM</span> <span class="var">x</span>, <span class="type">SCM</span> <span class="var">d</span>)
{
    <span class="keyword">if</span> (<span class="macro">SCM_PairP</span>(<span class="var">x</span>)) {
        <span class="macro">SCM_Unwrap</span>(<span class="var">x</span>)-><span class="var">pair</span>.<span class="var">cdr</span> = <span class="var">d</span>;
        <span class="keyword">return</span> <span class="var">x</span>;
    }
    <span class="keyword">else</span> <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_SET_CDR</span>);
}</pre>

<p>Неплохо будет также рассмотреть функцию <code><span class="func">list</span></code>.
Она может принимать произвольное число аргументов, поэтому первым её аргументом идёт это самое
число. (Понятно, что в Си не стоит записывать итерацию с помощью рекурсии, но
соблазн был слишком велик.)</p>

<!--\indexC*{SCM_list}{SCM\_list}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_list</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="var">count</span>, <span class="type">va_list</span> <span class="var">arguments</span>)
{
    <span class="keyword">if</span> (<span class="var">count</span> == <span class="num">0</span>) {
        <span class="keyword">return</span> <span class="macro">SCM_nil</span>;
    }
    <span class="keyword">else</span> {
        <span class="type">SCM</span> <span class="var">car</span> = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);
        <span class="keyword">return</span> <span class="func">SCM_cons</span>(<span class="var">car</span>, <span class="func">SCM_list</span>(<span class="var">count</span> - <span class="num">1</span>, <span class="var">arguments</span>));
    }
}</pre>

<p>Возникающие в процессе работы ошибки никак не перехватываются и
не обрабатываются. Если возникают какие-либо проблемы, то просто вызывается
макрос <code class="c"><span class="macro">SCM_error</span></code>.
Он сообщает наверх о том, что и где произошло, выводя
код ошибки, имя провинившегося файла и номер строки в нём.</p>

<!--\indexC*{SCM_error}{SCM\_error}-->
<!--\indexC*{SCM_signal_error}{SCM\_signal\_error}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_error</span>(<span class="var">code</span>) <span class="func">SCM_signal_error</span>(<span class="var">code</span>, <span class="macro">__LINE__</span>, <span class="macro">__FILE__</span>)

<span class="type">SCM</span> <span class="func">SCM_signal_error</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="var">code</span>,
                     <span class="type">unsigned</span> <span class="type">long</span> <span class="var">line</span>,
                     <span class="type">const</span> <span class="type">char</span> *<span class="var">file</span>)
{
    <span class="func">fflush</span>(<span class="var">stdout</span>);
    <span class="func">fprintf</span>(<span class="var">stderr</span>, <span class="string">"Error <span class="pp">%ul</span>, line <span class="pp">%ul</span>, file <span class="pp">%s</span>.<span class="esc">\n</span>"</span>, <span class="var">code</span>, <span class="var">line</span>, <span class="var">file</span>);
    <span class="func">exit</span>(<span class="var">code</span>);
}</pre>


<h3 id="cc/runtime/ssect:invoke"><span class="wrap"><span class="seq">10.10.3.</span><span class="title">Вызовы функций</span></span></h3>

<!--\indexC{invoke}-->
<!--\indexC{apply}-->
<p>Самыми важными (и хитроумными) из функций, вызывающих другие функции, являются
<code class="c"><span class="func">SCM_invoke</span></code> и <code><span class="func">apply</span></code>. Присутствие здесь примитива <code><span class="func">apply</span></code> не особо
удивительно — он же должен знать протокол вызова функций, чтобы ему
следовать.</p>


<!--\indexR{функции!протокол вызова}-->
<!--\indexR{протокол вызова функций}-->
<p>За исключением вызовов, интегрированных непосредственно в код (то есть
реализованных через прямые обращения к макросам или функциям на Си), все
остальные вызовы выполняются внутренней функцией
<code class="c"><span class="func">SCM_invoke</span></code>. Первым
аргументом она принимает вызываемую функцию, за которой следуют количество и
значения аргументов для неё. Как и в предыдущих интерпретаторах,
<code class="c"><span class="func">SCM_invoke</span></code> отвечает за все возможные вызовы.
Она анализирует тип первого
аргумента, чтобы выбрать правильный метод обработки (или выругаться об ошибке
типизации). Затем она извлекает вызываемый объект, выясняет поддерживаемую им
арность и сравнивает её с фактической. Наконец, она выполняет собственно вызов,
передавая функции аргументы соответствующим образом. В нашем случае есть три
различных протокола вызова. Это далеко не исчерпывающий список возможных
вариантов; например, вместо указания количества аргументов можно просто
дописывать в конец какое-то специальное значение (именно так поступает Bigloo,
используя для этой цели <code class="c"><span class="macro">NULL</span></code>).</p>

<ul>
  <li>Примитивы с фиксированной арностью (вроде
    <code class="c"><span class="func">SCM_cons</span></code>)
    вызываются просто и без всяких ухищрений. Эти вызовы можно
    отнести к виду <span class="math"><span class="ord var">f</span><span class="open">(</span><span class="ord var">x</span><span class="punct">,</span><span class="ord var">y</span><span class="punct">,</span><span class="ord var">z</span><span class="close">)</span></span>.</li>

  <li>Примитивы с переменной арностью (вроде
    <code class="c"><span class="func">SCM_list</span></code>) должны
    знать количество полученных аргументов. Оно передаётся
    дополнительным аргументом, поэтому вызов имеет вид
    <span class="math"><span class="ord var">f</span><span class="open">(</span><span class="ord var">n</span><span class="punct">,</span><span class="ord var">x<sub><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord var">x<sub><span class="ord num">2</span></sub></span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">x<sub><span class="ord var">n</span></sub></span><span class="close">)</span></span>.</li>

  <li>Замыканиям необходимо получить не только все аргументы вызова,
    но также и значения свободных переменных, которые фактически
    хранятся внутри самих замыканий. Поэтому для них надо выполнять
    вызовы вида <span class="math"><span class="ord var">f</span><span class="open">(</span><span class="ord var">f</span><span class="punct">,</span><span class="ord var">n</span><span class="punct">,</span><span class="ord var">x<sub><span class="ord num">1</span></sub></span><span class="punct">,</span><span class="ord var">x<sub><span class="ord num">2</span></sub></span><span class="punct">,</span><span class="ord">…</span><span class="punct">,</span><span class="ord var">x<sub><span class="ord var">n</span></sub></span><span class="close">)</span></span>.</li>
</ul>

<p>Естественно, мы могли бы улучшить эти протоколы, привести их к единому виду,
возможно, даже избавиться от некоторых. Но это потом, сейчас у нас есть вполне
конкретные требования к <code class="c"><span class="func">SCM_invoke</span></code>.
Несмотря на внушительные размеры, она довольно регулярна по своей структуре. (Обработка
продолжений будет рассмотрена в следующем разделе.)</p>

<!--\indexC{invoke}-->
<!--\indexC*{SCM_invoke}{SCM\_invoke}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_invoke</span>(<span class="type">SCM</span> <span class="var">function</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="var">number</span>, ...)
{
    <span class="comment">/* Вряд ли у нас получится вызвать число */</span>
    <span class="keyword">if</span> (<span class="macro">SCM_FixnumP</span>(<span class="var">function</span>)) {
        <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_CANNOT_APPLY</span>);
    }

    <span class="keyword">switch</span> (<span class="macro">SCM_2tag</span>(<span class="var">function</span>)) {
      <span class="keyword">case</span> <span class="var">SCM_SUBR_TAG</span>: {
        <span class="type">SCM</span> (*<span class="var">behavior</span>)(<span class="type">void</span>) = (<span class="macro">SCM_Unwrap</span>(<span class="var">function</span>)-><span class="var">subr</span>).<span class="var">behavior</span>;
        <span class="type">long</span> <span class="var">arity</span> = (<span class="macro">SCM_Unwrap</span>(<span class="var">function</span>)-><span class="var">subr</span>).<span class="var">arity</span>;

        <span class="comment">/* Фиксированная арность */</span>
        <span class="keyword">if</span> (<span class="var">arity</span> >= <span class="num">0</span>) {
            <span class="keyword">if</span> (<span class="var">arity</span> != <span class="var">number</span>) {
                <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_WRONG_ARITY</span>);
            }
            <span class="keyword">if</span> (<span class="var">arity</span> == <span class="num">0</span>) {
                <span class="keyword">return</span> <span class="var">behavior</span>();
            }
            <span class="keyword">else</span> {
                <span class="type">SCM</span> <span class="var">result</span>;
                <span class="type">va_list</span> <span class="var">args</span>;
                <span class="macro">va_start</span>(<span class="var">args</span>, <span class="var">number</span>);
                <span class="keyword">switch</span> (<span class="var">number</span>) {
                  <span class="keyword">case</span> <span class="num">1</span>: {
                    <span class="type">SCM</span> <span class="var">a0</span> = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
                    <span class="var">result</span> = ((<span class="type">SCM</span> (*)(<span class="type">SCM</span>)) <span class="var">behavior</span>)(<span class="var">a0</span>);
                    <span class="keyword">break</span>;
                  }
                  <span class="keyword">case</span> <span class="num">2</span>: {
                    <span class="type">SCM</span> <span class="var">a0</span> = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
                    <span class="type">SCM</span> <span class="var">a1</span> = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
                    <span class="var">result</span> = ((<span class="type">SCM</span> (*)(<span class="type">SCM</span>, <span class="type">SCM</span>)) <span class="var">behavior</span>)(<span class="var">a0</span>, <span class="var">a1</span>);
                    <span class="keyword">break</span>;
                  }
                  <span class="keyword">case</span> <span class="num">3</span>: {
                    <span class="type">SCM</span> <span class="var">a0</span> = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
                    <span class="type">SCM</span> <span class="var">a1</span> = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
                    <span class="type">SCM</span> <span class="var">a2</span> = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
                    <span class="var">result</span> = ((<span class="type">SCM</span> (*)(<span class="type">SCM</span>,<span class="type">SCM</span>,<span class="type">SCM</span>)) <span class="var">behavior</span>)
                             (<span class="var">a0</span>, <span class="var">a1</span>, <span class="var">a2</span>);
                    <span class="keyword">break</span>;
                  }
                  <span class="keyword">default</span>:
                    <span class="comment">/* Не существует примитивов большей арности */</span>
                    <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_INTERNAL</span>);
                }
                <span class="macro">va_end</span>(<span class="var">args</span>);
                <span class="keyword">return</span> <span class="var">result</span>;
            }
        }
        <span class="comment">/* Переменная арность */</span>
        <span class="keyword">else</span> {
            <span class="keyword">if</span> (<span class="var">number</span> &lt; <span class="macro">SCM_MinimalArity</span>(<span class="var">arity</span>)) {
                <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_MISSING_ARGS</span>);
            }
            <span class="keyword">else</span> {
                <span class="type">SCM</span> <span class="var">result</span>;
                <span class="type">va_list</span> <span class="var">args</span>;
                <span class="macro">va_start</span>(<span class="var">args</span>, <span class="var">number</span>);
                <span class="var">result</span> = ((<span class="type">SCM</span> (*)(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">va_list</span>)) <span class="var">behavior</span>)
                         (<span class="var">number</span>, <span class="var">args</span>);
                <span class="macro">va_end</span>(<span class="var">args</span>);
                <span class="keyword">return</span> <span class="var">result</span>;
            }
        }
      }

      <span class="keyword">case</span> <span class="var">SCM_CLOSURE_TAG</span>: {
        <span class="type">SCM</span> <span class="var">result</span>;
        <span class="type">va_list</span> <span class="var">args</span>;
        <span class="type">SCM</span> (*<span class="var">behavior</span>)(<span class="type">void</span>) =
                (<span class="macro">SCM_Unwrap</span>(<span class="var">function</span>)-><span class="var">closure</span>).<span class="var">behavior</span>;
        <span class="type">long</span> <span class="var">arity</span> = (<span class="macro">SCM_Unwrap</span>(<span class="var">function</span>)-><span class="var">closure</span>).<span class="var">arity</span>;

        <span class="keyword">if</span> (<span class="var">arity</span> >= <span class="num">0</span> &amp;&amp; <span class="var">number</span> != <span class="var">arity</span>) {
            <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_WRONG_ARITY</span>);
        }
        <span class="keyword">if</span> (<span class="var">number</span> &lt; SCM_MinimalArity(<span class="var">arity</span>)) {
            <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_MISSING_ARGS</span>);
        }

        <span class="macro">va_start</span>(<span class="var">args</span>, <span class="var">number</span>);
        <span class="var">result</span> = ((<span class="type">SCM</span> (*)(<span class="type">SCM</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">va_list</span>)) <span class="var">behavior</span>)
                 (<span class="var">function</span>, <span class="var">number</span>, <span class="var">args</span>);
        <span class="macro">va_end</span>(<span class="var">args</span>);
        <span class="keyword">return</span> <span class="var">result</span>;
      }

      <span class="comment">/* Невызываемо! */</span>
      <span class="keyword">default</span>:
        <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_CANNOT_APPLY</span>);
    }
}</pre>

<!--\indexR{переменная арность!в Си}-->
<!--\indexC{CALL-ARGUMENTS-LIMIT}-->
<p>Реализация примитива <code><span class="func">apply</span></code> имеет сравнимые размеры. Так как это примитив
переменной арности, то свои аргументы он получает в виде <code class="c"><span class="type">va_list</span></code>,
содержащего применяемую функцию и список аргументов для неё. Но здесь возникает
проблема с тем, что в C90 отсутствует<a class="footref" href="zz_footnotes.html#foot10.tr-2"><sup>**</sup></a> способ передать другой
функции аргументы, оставшиеся в <code class="c"><span class="type">va_list</span></code>. Что ж, придётся с этим смириться
и разбирать все возможные арности вручную. Печально, конечно, но нам придётся
ограничить максимальное количество аргументов <code><span class="func">apply</span></code>. Стандартизацией
<span class="sc">C<span class="c">ommon</span> L<span class="c">isp</span></span> однозначно руководили реалисты, поэтому там определена специальная
константа <code><span class="var">CALL-ARGUMENTS-LIMIT</span></code>, хранящая максимально допустимое количество
аргументов. По стандарту она не может быть меньше 50. Мы ограничимся<a class="footref" href="zz_footnotes.html#foot10.11"><sup>11</sup></a> всего 14, из которых здесь покажем обработку
лишь первых четырёх.</p>

<!--\indexC{apply}-->
<!--\indexC*{SCM_apply}{SCM\_apply}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_apply</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="var">number</span>, <span class="type">va_list</span> <span class="var">arguments</span>)
{
    <span class="type">unsigned</span> <span class="type">long</span> <span class="var">i</span>;
    <span class="type">SCM</span> <span class="var">args</span>[<span class="num">31</span>];
    <span class="type">SCM</span> <span class="var">last_arg</span>;
    <span class="type">SCM</span> <span class="var">fun</span> = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);

    <span class="keyword">for</span> (<span class="var">i</span> = <span class="num">0</span>; <span class="var">i</span> &lt; <span class="var">number</span> - <span class="num">1</span>; <span class="var">i</span>++) {
        <span class="var">args</span>[<span class="var">i</span>] = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);
    }
    <span class="var">last_arg</span> = <span class="var">args</span>[--<span class="var">i</span>];
    <span class="keyword">while</span> (<span class="macro">SCM_PairP</span>(<span class="var">last_arg</span>)) {
        <span class="var">args</span>[<span class="var">i</span>++] = <span class="macro">SCM_Car</span>(<span class="var">last_arg</span>);
        <span class="var">last_arg</span> = <span class="macro">SCM_Cdr</span>(<span class="var">last_arg</span>);
    }
    <span class="keyword">if</span> (!<span class="macro">SCM_NullP</span>(<span class="var">last_arg</span>)) {
        <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_APPLY_ARG</span>);
    }

    <span class="keyword">switch</span> (<span class="var">i</span>) {
      <span class="keyword">case</span> <span class="num">0</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">0</span>);
      <span class="keyword">case</span> <span class="num">1</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">1</span>, <span class="var">args</span>[<span class="num">0</span>]);
      <span class="keyword">case</span> <span class="num">2</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">2</span>, <span class="var">args</span>[<span class="num">0</span>], <span class="var">args</span>[<span class="num">1</span>]);
      <span class="keyword">case</span> <span class="num">3</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">3</span>, <span class="var">args</span>[<span class="num">0</span>], <span class="var">args</span>[<span class="num">1</span>], <span class="var">args</span>[<span class="num">2</span>]);
      <span class="comment">/* ... */</span>
      <span class="keyword">default</span>: <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_APPLY_SIZE</span>);
    }
}</pre>

<p>Всё равно C90 не поддерживает более 32 параметров функций, так что на 50 в нашем
случае можно и не надеяться. Пуристы, наверное, уже давно обратили внимание на
(ненужную?) проверку того, что в конце списка аргументов
<code><span class="func">apply</span></code>
действительно находится <code><span class="hash">()</span></code>.</p>

<div class="bigskip"></div>

<!--\indexR{хвостовые вызовы}-->
<!--\indexR{вызов!хвостовой}-->
<p>Существенной проблемой прямого использования функций Си является то, что Си
не гарантирует оптимизацию хвостовых вызовов. Поэтому некоторые программы, без
проблем выполняющиеся на Scheme, при буквальном переводе на Си будут умирать
от переполнения стека. Некоторые компиляторы Scheme в Си (например, Scheme<span class="math"><span class="rel">→</span></span>C
или Bigloo) применяют множество хитроумных алгоритмов, чтобы избежать подобных
аварий. Они генерируют специальный код для рекурсии, итерации через рекурсию
и так далее, но, к сожалению, абсолютно все варианты предусмотреть невозможно,
и обязательно найдётся программа, которая всё сломает. Альтернативным решением
является отказ от использования стека Си для представления продолжений Scheme.</p>


<h2 id="cc/sect:call/cc"><span class="wrap"><span class="seq">10.11.</span><span class="title"><code><span class="func">call/cc</span></code>: быть или не быть</span></span></h2>

<p>Мы только что закончили рассмотрение принципов компиляции основной части
конструкций Scheme в программы на Си. Несмотря на то, что многие стандартные
функции не реализованы, важнейшие из них всё же присутствуют (хоть, возможно,
и не в самом эффективном виде). Все, кроме функций для работы с продолжениями.
Для начала мы реализуем функцию <code><span class="func">call/ep</span></code>,
предоставляющую продолжения с динамическим временем жизни, как в Лиспе. Она будет
использовать <code class="c"><span class="func">setjmp</span></code>/<code><span class="func">longjmp</span></code>.</p>

<p>Во второй же части данного раздела мы разберёмся с тем, как реализовать
на Си истинно неограниченные продолжения Scheme.</p>


<h3 id="cc/call/cc/ssect:ep"><span class="wrap"><span class="seq">10.11.1.</span><span class="title">Функция <code><span class="func">call/ep</span></code></span></span></h3>

<!--\indexC{call/ep}-->
<!--\indexC{setjmp}-->
<!--\indexC{longjmp}-->
<p>Функция <code><span class="func">call/ep</span></code> во всём идентична
<code><span class="func">call/cc</span></code>, за исключением того, что
продолжения, создаваемые ею, хоть и являются полноценными объектами Scheme, но
не могут быть использованы вне соответствующей формы
<code><span class="func">call/ep</span></code>, которая
ограничивает время их жизни временем исполнения собственного тела.
<span class="see">[см. раздел <a href="ch03_escape_and_return.html#escape/sect:comparing">3.5</a>]</span>
Для её реализации применяется подход,
аналогичный показанному в седьмой главе, где в стек помещалась специальная
метка, служившая точкой прибытия для продолжений. Теперь такой меткой будет
локальная переменная типа <code class="c"><span class="type">jmp_buf</span></code>. Вот необходимые для этого функции:</p>

<!--\indexC*{SCM_allocate_continuation}{SCM\_allocate\_continuation}-->
<!--\indexC*{SCM_jmp_buf}{SCM\_jmp\_buf}-->
<!--\indexC*{SCM_callep}{SCM\_callep}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_allocate_continuation</span>(<span class="keyword">struct</span> <span class="type">SCM_jmp_buf</span> *<span class="var">address</span>)
{
    <span class="type">SCMref</span> <span class="var">continuation</span> = <span class="func">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">SCM_unwrapped_escape</span>));
    <span class="keyword">if</span> (!<span class="var">continuation</span>)
    {
        <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_CANT_ALLOC</span>);
    }

    <span class="var">continuation</span>-><span class="var">escape</span>.<span class="var">header</span>.<span class="var">tag</span>    = <span class="var">SCM_ESCAPE_TAG</span>;
    <span class="var">continuation</span>-><span class="var">escape</span>.<span class="var">stack_address</span> = <span class="var">address</span>;
    <span class="keyword">return</span> <span class="macro">SCM_Wrap</span>(<span class="var">continuation</span>);
}

<span class="keyword">struct</span> <span class="type">SCM_jmp_buf</span> {
    <span class="type">SCM</span> <span class="var">back_pointer</span>;
    <span class="type">SCM</span> <span class="var">jumpvalue</span>;
    <span class="type">jmp_buf</span> <span class="var">xen</span>;
};

<span class="type">SCM</span> <span class="func">SCM_callep</span>(<span class="type">SCM</span> <span class="var">f</span>)
{
    <span class="keyword">struct</span> <span class="type">SCM_jmp_buf</span> <span class="var">scmjb</span>;
    <span class="type">SCM</span> <span class="var">continuation</span> = <span class="func">SCM_allocate_continuation</span>(&amp;<span class="var">scmjb</span>);
    <span class="var">scmjb</span>.<span class="var">back_pointer</span> = <span class="var">continuation</span>;

    <span class="keyword">if</span> (<span class="func">setjmp</span>(<span class="var">scmjb</span>.<span class="var">xen</span>)) {
        <span class="keyword">return</span> <span class="var">scmjb</span>.<span class="var">jumpvalue</span>;
    }
    <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="func">SCM_invoke1</span>(<span class="var">f</span>, <span class="var">continuation</span>);
    }
}</pre>

<!--\indexR{стек!направление роста}-->
<p>Активация продолжений обрабатывается функцией
<code class="c"><span class="func">SCM_invoke</span></code>, которая перед
выполнением перехода ещё проверит арность вызова. Следующий фрагмент кода,
реализующий данную обработку, должен быть добавлен в приведённое ранее
определение <code class="c"><span class="func">SCM_invoke</span></code>.
Перед выполнением перехода достаточно (ввиду
отсутствия форм <code><span class="special">unwind-protect</span></code>)
убедиться в том, что продолжение указывает
на соответствующий ему <code class="c"><span class="type">jmp_buf</span></code>,
а мы находимся <em>выше</em> этого
<code class="c"><span class="type">jmp_buf</span></code> на стеке. К сожалению,
для второй проверки необходимо знать
направление роста стека. Будем считать, что макрос
<code class="c"><span class="macro">SCM_STACK_HIGHER</span></code>
раскрывается в соответствующее отношение порядка. Определение этого макроса,
естественно, возлагается на реализацию; благо, нужную информацию легко получить
небольшой программкой на абсолютно портируемом Си. Обычно (по крайней мере
в UNIX) стек растёт вниз, поэтому можете считать, что
<code class="c"><span class="macro">SCM_STACK_HIGHER</span></code>
раскрывается в <code class="c">&lt;=</code>.</p>

<!--\indexC*{SCM_invoke}{SCM\_invoke}-->
<pre class="c">    <span class="keyword">case</span> <span class="var">SCM_ESCAPE_TAG</span>:
      <span class="keyword">if</span> (<span class="var">number</span> == <span class="num">1</span>) {
          <span class="keyword">struct</span> <span class="type">SCM_jmp_buf</span> *<span class="var">address</span> =
              <span class="macro">SCM_Unwrap</span>(<span class="var">function</span>)-><span class="var">escape</span>.<span class="var">stack_address</span>;
          <span class="keyword">if</span> (<span class="macro">SCM_EqP</span>(<span class="var">address</span>-><span class="var">back_pointer</span>, <span class="var">function</span>) &amp;&amp;
              ((<span class="type">void</span>*) &amp;<span class="var">address</span> <span class="macro">SCM_STACK_HIGHER</span> (<span class="type">void</span>*) <span class="var">address</span>))
          {
              <span class="type">va_list</span> <span class="var">args</span>;
              <span class="macro">va_start</span>(<span class="var">args</span>, <span class="var">number</span>);
              <span class="var">address</span>-><span class="var">jumpvalue</span> = <span class="macro">va_arg</span>(<span class="var">args</span>, <span class="type">SCM</span>);
              <span class="macro">va_end</span>(<span class="var">args</span>);
              <span class="func">longjmp</span>(<span class="var">address</span>-><span class="var">xen</span>, <span class="num">9</span>);
          }
          <span class="keyword">else</span> {
              <span class="comment">/* Слишком поздно! */</span>
              <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_OUT_OF_EXTENT</span>);
          }
      }
      <span class="keyword">else</span> {
          <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_MISSING_ARGS</span>);
      }</pre>

<p>Эффективность <code><span class="func">call/ep</span></code>, о которой говорилось при рассмотрении компилятора
в байт-код, сейчас несколько приуменьшилась, так как переходы с помощью
<code class="c"><span class="func">longjmp</span></code> печально известны своей «стремительностью». Они неплохи для
реализации исключений, но при постоянном использовании существенно замедляют
исполнение программ. Однако, мы лишь хотели показать пример интеграции Лиспа
и Си, поэтому ничего особо страшного в этом нет.</p>


<h3 id="cc/call/cc/ssect:cc"><span class="wrap"><span class="seq">10.11.2.</span><span class="title">Функция <code><span class="func">call/cc</span></code></span></span></h3>

<!--\indexC{call/cc}-->
<p>Ура! Если вы скучаете по настоящим продолжениям, то скоро ваши мечты сбудутся.
До этого <code><span class="func">call/cc</span></code> чаще всего реализовывалась с помощью магии — неявного
вызова уже существующей <code><span class="func">call/cc</span></code> языка реализации. К сожалению, в Си такой
функции нет, так что пришло время <em>написать</em> её самостоятельно. Однако для
этого необходимо знать, как здесь устроен стек. Проблема в том, что в Си нет
переносимого способа взаимодействия с ним. Вернее, нет <em>простого</em> способа
— всегда можно написать кучу платформоспецифичных вариантов и выбирать из них
нужный с помощью <code class="c"><span class="pre">#ifdef</span></code>. Для этой книги такой вариант не подходит, так что
попробуем подойти с другой стороны: приведём программу к стилю передачи
продолжений (CPS). Тогда и продолжения будут как на ладони, и компилятор
останется почти неизменным.</p>


<h4 id="cc/call/cc/cc/ssect:explicit"><span class="wrap"><span class="title">Делаем продолжения явными</span></span></h4>

<!--\indexE{CPS}-->
<!--\indexR{преобразование!в CPS}-->
<!--\indexR{стиль передачи продолжений (CPS)!CPS-преобразование}-->
<p>Предлагаемое преобразование эквивалентно показанному ранее, только выполняется
оно с помощью нового обходчика кода.
<span class="see">[см. раздел <a href="ch05_denotational_semantics.html#denotational/lambdify/ssect:cps">5.9.1</a>]</span>
Работа ведётся над уже объектифицированным исходным кодом.</p>

<p>У CPS-преобразования, выполняемого в лоб, есть недостаток: оно очень щедро
использует <code><span class="syntax">let</span></code>-формы, но при этом не заботится об эффективности и
представляет их так называемыми административными редексами. Поэтому после
выполнения этого преобразования мы ещё раз пройдёмся по коду, возвращая
программу во вменяемый вид. Этим займётся функция <code><span class="func">letify</span></code>. Итак, ядро
компилятора с поддержкой продолжений:</p>

<!--\indexC{compile->C}-->
<pre>(<span class="special">define</span> (<span class="func">compile-&gt;C</span> <span class="var">e</span> <span class="var">out</span>)
  (<span class="special">set!</span> <span class="var">g.current</span> <span class="hash">'()</span>)
  (<span class="syntax">let*</span> ((<span class="var">ee</span> (<span class="func">letify</span> (<span class="func">cpsify</span> (<span class="func">Sexp-&gt;object</span> <span class="var">e</span>)) <span class="hash">'()</span>))
         (<span class="var">prg</span> (<span class="func">extract-things!</span> (<span class="func">lift!</span> <span class="var">ee</span>))) )
    (<span class="func">gather-temporaries!</span> (<span class="func">closurize-main!</span> <span class="var">prg</span>))
    (<span class="func">generate-C-program</span> <span class="var">out</span> <span class="var">e</span> <span class="var">prg</span>) ) )</pre>

<p>Извлечение продолжений выполняет функция <code><span class="func">cpsify</span></code>. Она организует совместную
работу обходчика <code><span class="func">update-walk!</span></code> и функции <code><span class="func">-&gt;CPS</span></code>. Также нам понадобятся
два новых класса: класс продолжений, чтобы отличать обычные функции от
функций-продолжений, и класс псевдопеременных, представляющих временные
переменные неявно используемых (в исходном коде на Scheme) продолжений.</p>

<!--\indexC{Continuation}-->
<!--\indexC{Pseudo-Variable}-->
<!--\indexC{cpsify}-->
<!--\indexC{new-Variable}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Continuation</span>    <span class="class">Function</span> ())
(<span class="syntax">define-class</span> <span class="class">Pseudo-Variable</span> <span class="class">Local-Variable</span> ())

(<span class="special">define</span> (<span class="func">cpsify</span> <span class="var">e</span>)
  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">new-Variable</span>)))
    (<span class="func">-&gt;CPS</span> <span class="var">e</span> (<span class="func">make-Continuation</span> (<span class="func">list</span> <span class="var">v</span>) (<span class="func">make-Local-Reference</span> <span class="var">v</span>))) ) )

(<span class="special">define</span> <span class="var">new-Variable</span>
  (<span class="syntax">let</span> ((<span class="var">counter</span> <span class="num">0</span>))
    (<span class="special">lambda</span> ()
      (<span class="special">set!</span> <span class="var">counter</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">counter</span>))
      (<span class="func">make-Pseudo-Variable</span> <span class="var">counter</span> <span class="hash">#f</span> <span class="hash">#f</span>) ) ) )</pre>

<p>Функция <code><span class="func">-&gt;CPS</span></code> первым аргументом принимает объект, представляющий
вычисления, а вторым — продолжение, которому надо передать результат этих
вычислений. В общем случае ничего кроме этого делать и не надо. Начальным
продолжением, которому <code><span class="func">cpsify</span></code> передаёт
результат выполнения всей программы, является тождество
<span class="math"><span class="ord var">λ</span><span class="ord var">x</span><span class="ord">.</span><span class="ord var">x</span></span>.</p>

<!--\indexC*{CPS}{->CPS}-->
<!--\indexC{convert2Regular-Application}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Program</span>) <span class="var">k</span>)
  (<span class="func">convert2Regular-Application</span> <span class="var">k</span> <span class="var">e</span>) )

(<span class="special">define</span> (<span class="func">convert2Regular-Application</span> <span class="var">k</span> . <span class="var">args</span>)
  (<span class="func">make-Regular-Application</span> <span class="var">k</span> (<span class="func">convert2arguments</span> <span class="var">args</span>)) )</pre>

<p>Теперь остаётся лишь определить методы для всех остальных узлов синтаксического
дерева. Последовательные вычисления? Элементарно: вычисляем одну форму сейчас,
а остальные передаём продолжению:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Sequence</span>) <span class="var">k</span>)
  (<span class="func">-&gt;CPS</span> (<span class="func">Sequence-first</span> <span class="var">e</span>)
         (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">new-Variable</span>)))
           (<span class="func">make-Continuation</span>
            (<span class="func">list</span> <span class="var">v</span>) (<span class="func">-&gt;CPS</span> (<span class="func">Sequence-last</span> <span class="var">e</span>) <span class="var">k</span>) ) ) ) )</pre>

<p>С ветвлением тоже всё просто, надо только помнить, что обе ветви пользуются
одним и тем же исходным продолжением:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Alternative</span>) <span class="var">k</span>)
  (<span class="func">-&gt;CPS</span> (<span class="func">Alternative-condition</span> <span class="var">e</span>)
         (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">new-Variable</span>)))
           (<span class="func">make-Continuation</span>
            (<span class="func">list</span> <span class="var">v</span>) (<span class="func">make-Alternative</span>
                      (<span class="func">make-Local-Reference</span> <span class="var">v</span>)
                      (<span class="func">-&gt;CPS</span> (<span class="func">Alternative-consequent</span> <span class="var">e</span>) <span class="var">k</span>)
                      (<span class="func">-&gt;CPS</span> (<span class="func">Alternative-alternant</span> <span class="var">e</span>) <span class="var">k</span>) ) ) ) ) )</pre>

<p>И даже присваивания очевидны. Сначала вычисляется новое значение, продолжением
этих вычислений является обновление значения переменной и выполнение всего того,
что следует дальше за присваиванием:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Box-Write</span>) <span class="var">k</span>)
  (<span class="func">-&gt;CPS</span> (<span class="func">Box-Write-form</span> <span class="var">e</span>)
         (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">new-Variable</span>)))
           (<span class="func">make-Continuation</span>
            (<span class="func">list</span> <span class="var">v</span>) (<span class="func">convert2Regular-Application</span>
                      <span class="var">k</span> (<span class="func">make-Box-Write</span>
                         (<span class="func">Box-Write-reference</span> <span class="var">e</span>)
                         (<span class="func">make-Local-Reference</span> <span class="var">v</span>) ) ) ) ) ) )

(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Global-Assignment</span>) <span class="var">k</span>)
  (<span class="func">-&gt;CPS</span> (<span class="func">Global-Assignment-form</span> <span class="var">e</span>)
         (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">new-Variable</span>)))
           (<span class="func">make-Continuation</span>
            (<span class="func">list</span> <span class="var">v</span>) (<span class="func">convert2Regular-Application</span>
                      <span class="var">k</span> (<span class="func">make-Global-Assignment</span>
                         (<span class="func">Global-Assignment-variable</span> <span class="var">e</span>)
                         (<span class="func">make-Local-Reference</span> <span class="var">v</span>) ) ) ) ) ) )</pre>

<!--\indexR{редексы!административные}-->
<!--\indexR{административные редексы}-->
<!--\indexR{приводимые!формы}-->
<!--\indexR{форма!приводимая}-->
<p>А вот введение локальных переменных <code><span class="syntax">let</span></code>-формами уже сложнее. Дело в том,
что продолжение <code><span class="func">k</span></code> надо протащить внутрь узлов <code><span class="class">Fix-Let</span></code> как новую
переменную. Самый простой способ этого добиться — превратить все <code><span class="class">Fix-Let</span></code>
обратно в приводимые формы (аппликации непосредственно задаваемых абстракций)
на время выполнения CPS-преобразования. Такие вспомогательные формы называются
<em>административными</em> редексами <span class="cite">[<a href="z1_bibliography.html#sf92">SF92</a>]</span>. Хоть они выглядят не особо
красиво и замедляют наивную интерпретацию, это лишь временное промежуточное
представление. На эффективность результата компиляции эти (и все остальные)
редексы не повлияют — они будут обнаружены и оптимизированы функцией
<code><span class="func">letify</span></code>.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Fix-Let</span>) <span class="var">k</span>)
  (<span class="func">-&gt;CPS</span> (<span class="func">make-Regular-Application</span>
          (<span class="func">make-Function</span> (<span class="func">Fix-Let-variables</span> <span class="var">e</span>) (<span class="func">Fix-Let-body</span> <span class="var">e</span>))
          (<span class="func">Fix-Let-arguments</span> <span class="var">e</span>) )
         <span class="var">k</span> ) )</pre>

<p>Все функции получают по дополнительному аргументу, представляющему продолжение
их вызова.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Function</span>) <span class="var">k</span>)
  (<span class="func">convert2Regular-Application</span> <span class="var">k</span>
   (<span class="syntax">let</span> ((<span class="var">k</span> (<span class="func">new-Variable</span>)))
     (<span class="func">make-Function</span> (<span class="func">cons</span> <span class="var">k</span> (<span class="func">Function-variables</span> <span class="var">e</span>))
                    (<span class="func">-&gt;CPS</span> (<span class="func">Function-body</span> <span class="var">e</span>)
                           (<span class="func">make-Local-Reference</span> <span class="var">k</span>) ) ) ) ) )</pre>

<p>Аппликации функций должны выполняться с учётом этого нововведения. Все аргументы
последовательно вычисляются перед применением к ним функции. Порядок вычисления
обычный: слева направо.</p>

<!--\indexC{arguments->CPS}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Predefined-Application</span>) <span class="var">k</span>)
  (<span class="syntax">let*</span> ((<span class="var">args</span> (<span class="func">Predefined-Application-arguments</span> <span class="var">e</span>))
         (<span class="var">vars</span> (<span class="syntax">let</span> <span class="func">name</span> ((<span class="var">args</span> <span class="var">args</span>))
                 (<span class="special">if</span> (<span class="func">not</span> (<span class="func">Arguments?</span> <span class="var">args</span>)) <span class="hash">'()</span>
                     (<span class="func">cons</span> (<span class="func">new-Variable</span>)
                           (<span class="func">name</span> (<span class="func">Arguments-others</span> <span class="var">args</span>)) ) ) ))
         (<span class="func">application</span>
          (<span class="func">convert2Regular-Application</span> <span class="var">k</span>
           (<span class="func">make-Predefined-Application</span>
            (<span class="func">Predefined-Application-variable</span> <span class="var">e</span>)
            (<span class="func">convert2arguments</span>
             (<span class="func">map</span> <span class="var">make-Local-Reference</span> <span class="var">vars</span>) ) ) ) ) )
    (<span class="func">arguments-&gt;CPS</span> <span class="var">args</span> <span class="var">vars</span> <span class="var">application</span>) ) )

(<span class="syntax">define-method</span> (<span class="func">-&gt;CPS</span> (<span class="var">e</span> <span class="class">Regular-Application</span>) <span class="var">k</span>)
  (<span class="syntax">let*</span> ((<span class="var">fun</span> (<span class="func">Regular-Application-function</span> <span class="var">e</span>))
         (<span class="var">args</span> (<span class="func">Regular-Application-arguments</span> <span class="var">e</span>))
         (<span class="var">varfun</span> (<span class="func">new-Variable</span>))
         (<span class="var">vars</span> (<span class="syntax">let</span> <span class="func">name</span> ((<span class="var">args</span> <span class="var">args</span>))
                 (<span class="special">if</span> (<span class="func">not</span> (<span class="func">Arguments?</span> <span class="var">args</span>)) <span class="hash">'()</span>
                     (<span class="func">cons</span> (<span class="func">new-Variable</span>)
                           (<span class="func">name</span> (<span class="func">Arguments-others</span> <span class="var">args</span>)) ) ) ))
         (<span class="func">application</span>
          (<span class="func">make-Regular-Application</span>
           (<span class="func">make-Local-Reference</span> <span class="var">varfun</span>)
           (<span class="func">make-Arguments</span> <span class="var">k</span> (<span class="func">convert2arguments</span>
                              (<span class="func">map</span> <span class="var">make-Local-Reference</span> <span class="var">vars</span>) )) ) ) )
    (<span class="func">-&gt;CPS</span> <span class="var">fun</span> (<span class="func">make-Continuation</span>
                (<span class="func">list</span> <span class="var">varfun</span>)
                (<span class="func">arguments-&gt;CPS</span> <span class="var">args</span> <span class="var">vars</span> <span class="var">application</span>) )) ) )

(<span class="special">define</span> (<span class="func">arguments-&gt;CPS</span> <span class="var">args</span> <span class="var">vars</span> <span class="var">appl</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">args</span>)
      (<span class="func">-&gt;CPS</span> (<span class="func">Arguments-first</span> <span class="var">args</span>)
             (<span class="func">make-Continuation</span>
              (<span class="func">list</span> (<span class="func">car</span> <span class="var">vars</span>))
              (<span class="func">arguments-&gt;CPS</span> (<span class="func">Arguments-others</span> <span class="var">args</span>)
                              (<span class="func">cdr</span> <span class="var">vars</span>) <span class="var">appl</span> ) ) )
      <span class="var">appl</span> ) )</pre>


<h4 id="cc/call/cc/cc/ssect:letify"><span class="wrap"><span class="title">Оптимизируем редексы</span></span></h4>

<!--\indexR{синтаксическое дерево}-->
<!--\indexC{clone}-->
<p>Функция <code><span class="func">letify</span></code>, упомянутая ранее, отвечает за обратное преобразование
приводимых форм в <code><span class="syntax">let</span></code>-формы. Заодно её можно использовать для исправления
других неудобств CPS-преобразования. Когда функция <code><span class="func">-&gt;CPS</span></code> обрабатывает
ветвление, она передаёт каждой ветви физически одно и то же продолжение. Из-за
этого в итоге получается не дерево, а направленный ациклический граф. Некоторые
из последующих преобразований могут не дружить с такими графами, поэтому
<code><span class="func">letify</span></code>, чтобы гарантированно избежать проблем в будущем, скопирует все дуги
графа в новое дерево (где разделяемые дуги превратятся в пары одинаковых
ветвей). Предположим, у нас для этого есть обобщённая функция <code><span class="func">clone</span></code>,
способная скопировать любой объект <span class="sc">M<span class="c">eroonet</span></span>.
<span class="see">[см. упр. <a href="ch11_essence_of_an_object_system.html#objects/ex:clone">11.2</a>]</span>
Применение её к переменным отчасти напоминает переименование, выполняемое
<code><span class="func">collect-temporaries!</span></code>.</p>

<!--\indexC{letify}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">letify</span> (<span class="var">o</span> <span class="class">Program</span>) <span class="var">env</span>)
  (<span class="func">update-walk!</span> <span class="var">letify</span> (<span class="func">clone</span> <span class="var">o</span>) <span class="var">env</span>) )

(<span class="syntax">define-method</span> (<span class="func">letify</span> (<span class="var">o</span> <span class="class">Function</span>) <span class="var">env</span>)
  (<span class="syntax">let*</span> ((<span class="var">vars</span> (<span class="func">Function-variables</span> <span class="var">o</span>))
         (<span class="var">body</span> (<span class="func">Function-body</span> <span class="var">o</span>))
         (<span class="var">new-vars</span> (<span class="func">map</span> <span class="var">clone</span> <span class="var">vars</span>)) )
    (<span class="func">make-Function</span>
     <span class="var">new-vars</span>
     (<span class="func">letify</span> <span class="var">body</span> (<span class="func">append</span> (<span class="func">map</span> <span class="var">cons</span> <span class="var">vars</span> <span class="var">new-vars</span>) <span class="var">env</span>)) ) ) )

(<span class="syntax">define-method</span> (<span class="func">letify</span> (<span class="var">o</span> <span class="class">Local-Reference</span>) <span class="var">env</span>)
  (<span class="syntax">let*</span> ((<span class="var">v</span> (<span class="func">Local-Reference-variable</span> <span class="var">o</span>))
         (<span class="var">r</span> (<span class="func">assq</span> <span class="var">v</span> <span class="var">env</span>)) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">r</span>)
        (<span class="func">make-Local-Reference</span> (<span class="func">cdr</span> <span class="var">r</span>))
        (<span class="func">letify-error</span> <span class="string">"Disappeared variable"</span> <span class="var">o</span>) ) ) )

(<span class="syntax">define-method</span> (<span class="func">letify</span> (<span class="var">o</span> <span class="class">Regular-Application</span>) <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">Function?</span> (<span class="func">Regular-Application-function</span> <span class="var">o</span>))
      (<span class="func">letify</span> (<span class="func">process-closed-application</span>
               (<span class="func">Regular-Application-function</span> <span class="var">o</span>)
               (<span class="func">Regular-Application-arguments</span> <span class="var">o</span>) )
              <span class="var">env</span> )
      (<span class="func">make-Regular-Application</span>
       (<span class="func">letify</span> (<span class="func">Regular-Application-function</span> <span class="var">o</span>) <span class="var">env</span>)
       (<span class="func">letify</span> (<span class="func">Regular-Application-arguments</span> <span class="var">o</span>) <span class="var">env</span>) ) ) )

(<span class="syntax">define-method</span> (<span class="func">letify</span> (<span class="var">o</span> <span class="class">Fix-Let</span>) <span class="var">env</span>)
  (<span class="syntax">let*</span> ((<span class="var">vars</span> (<span class="func">Fix-Let-variables</span> <span class="var">o</span>))
         (<span class="var">new-vars</span> (<span class="func">map</span> <span class="var">clone</span> <span class="var">vars</span>)) )
    (<span class="func">make-Fix-Let</span>
     <span class="var">new-vars</span>
     (<span class="func">letify</span> (<span class="func">Fix-Let-arguments</span> <span class="var">o</span>) <span class="var">env</span>)
     (<span class="func">letify</span> (<span class="func">Fix-Let-body</span> <span class="var">o</span>)
             (<span class="func">append</span> (<span class="func">map</span> <span class="var">cons</span> <span class="var">vars</span> <span class="var">new-vars</span>) <span class="var">env</span>) ) ) ) )

(<span class="syntax">define-method</span> (<span class="func">letify</span> (<span class="var">o</span> <span class="class">Box-Creation</span>) <span class="var">env</span>)
  (<span class="syntax">let*</span> ((<span class="var">v</span> (<span class="func">Box-Creation-variable</span> <span class="var">o</span>))
         (<span class="var">r</span> (<span class="func">assq</span> <span class="var">v</span> <span class="var">env</span>)) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">r</span>)
        (<span class="func">make-Box-Creation</span> (<span class="func">cdr</span> <span class="var">r</span>))
        (<span class="func">letify-error</span> <span class="string">"Disappeared variable"</span> <span class="var">o</span>) ) ) )

(<span class="syntax">define-method</span> (<span class="func">clone</span> (<span class="var">o</span> <span class="class">Pseudo-Variable</span>)) (<span class="func">new-Variable</span>))</pre>


<h4 id="cc/call/cc/cc/ssect:runtime"><span class="wrap"><span class="title">Дорабатываем библиотеку</span></span></h4>

<p>Возможно, вам не совсем понятно, что мы приобретаем, выполнив данное
преобразование. Идея в том, чтобы сделать продолжения явными, — то есть
сделать реализацию <code><span class="func">call/cc</span></code> тривиальной. Продолжения в таком случае являются
просто замыканиями, никогда не возвращающими значений. Вот определение
<code class="c"><span class="func">SCM_callcc</span></code>. Раз это обычная функция, то первым аргументом она принимает
продолжение своего вызова; да, теперь она бинарна. Функция
<code class="c"><span class="func">SCM_invoke_continuation</span></code> определяется перед ней, так как компилятору Си
не нравится беспорядок.</p>

<!--\indexC*{SCM_invoke_continuation}{SCM\_invoke\_continuation}-->
<!--\indexC*{SCM_callcc}{SCM\_callcc}-->
<!--\indexC{call/cc}-->
<pre class="c"><span class="type">SCM</span> <span class="func">SCM_invoke_continuation</span>(<span class="type">SCM</span> <span class="var">self</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="var">number</span>,
                            <span class="type">va_list</span> <span class="var">arguments</span>)
{
    <span class="type">SCM</span> <span class="var">current_k</span> = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);
    <span class="type">SCM</span> <span class="var">value</span>     = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);
    <span class="keyword">return</span> <span class="macro">SCM_invoke1</span>(<span class="macro">SCM_Unwrap</span>(<span class="var">self</span>)-><span class="var">closure</span>.<span class="var">environment</span>[<span class="num">0</span>], <span class="var">value</span>);
}

<span class="type">SCM</span> <span class="func">SCM_callcc</span>(<span class="type">SCM</span> <span class="var">k</span>, <span class="type">SCM</span> <span class="var">f</span>)
{
    <span class="type">SCM</span> <span class="var">reified_k</span> =
        <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">SCM_invoke_continuation</span>),
                  <span class="num">2</span>, <span class="num">1</span>, <span class="var">k</span>);
    <span class="keyword">return</span> <span class="macro">SCM_invoke2</span>(<span class="var">f</span>, <span class="var">k</span>, <span class="var">reified_k</span>);
}

<span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">CALLCC</span>, <span class="string">"CALL/CC"</span>, <span class="num">2</span>, <span class="func">SCM_callcc</span>);</pre>


<!--\indexR{функции!протокол вызова}-->
<!--\indexR{протокол вызова функций}-->
<!--\indexC*{SCMq}{SCMq\_}-->
<p>Все остальные библиотечные функции остались нетронутыми, а ведь их протокол
вызова претерпел некоторые изменения в связи с появлением продолжений. Если
CPS-преобразование выдаст что-то вроде <code>(<span class="syntax">let</span> ((<span class="var">f</span> <span class="var">car</span>)) (<span class="var">f</span> '(<span class="var">a</span> <span class="var">b</span>)))</code>, то наш
компилятор-дурачок так и не поймёт, что это на самом деле просто вызов примитива
<code>(<span class="func">car</span> '(<span class="var">a</span> <span class="var">b</span>))</code> (а то и вовсе <code>(<span class="special">quote</span> <span class="var">a</span>)</code>, если провести свёртку констант).
Он честно вычислит значение глобальной переменной <code><span class="var">CAR</span></code> и выполнит вызов
обычной функции, строго придерживаясь протокола: передав продолжение первым
аргументом, а точечную пару — вторым. Значением <code><span class="var">CAR</span></code> теперь должна быть
абстракция <code>(<span class="special">lambda</span> (<span class="var">k</span> <span class="var">p</span>) (<span class="func">k</span> (<span class="func">car</span> <span class="var">p</span>)))</code>, определённая через изначальный
примитив <code><span class="func">car</span></code>. С этой целью мы введём несколько вспомогательных макросов и
добавим каждой библиотечной функции дополнительный аргумент. Функции
с приставкой <code class="c"><span class="func">SCMq_</span></code> являются новым интерфейсом функций, начинающихся
на <code class="c"><span class="func">SCM_</span></code>.</p>

<!--\indexC*{SCM_DefineCPSsubr0}{SCM\_DefineCPSsubr<i>n</i>}-->
<pre class="c"><span class="pre">#define</span> <span class="macro">SCM_DefineCPSsubr2</span>(<span class="var">new_name</span>, <span class="var">old_name</span>) \
  <span class="type">SCM</span> <span class="var">new_name</span>(<span class="type">SCM</span> <span class="var">k</span>, <span class="type">SCM</span> <span class="var">x</span>, <span class="type">SCM</span> <span class="var">y</span>)            \
  {                                            \
      <span class="keyword">return</span> <span class="macro">SCM_invoke1</span>(<span class="var">k</span>, <span class="var">old_name</span>(<span class="var">x</span>, <span class="var">y</span>));   \
  }

<span class="pre">#define</span> <span class="macro">SCM_DefineCPSsubrN</span>(<span class="var">new_name</span>, <span class="var">old_name</span>)                \
  <span class="type">SCM</span> <span class="var">new_name</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="var">number</span>, <span class="type">va_list</span> <span class="var">arguments</span>)       \
  {                                                           \
      <span class="type">SCM</span> <span class="var">k</span> = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);                         \
      <span class="keyword">return</span> <span class="macro">SCM_invoke1</span>(<span class="var">k</span>, <span class="var">old_name</span>(<span class="var">number</span> - <span class="num">1</span>, <span class="var">arguments</span>)); \
  }

<span class="macro">SCM_DefineCPSsubr2</span>(<span class="func">SCMq_gtp</span>, <span class="func">SCM_gtp</span>)
<span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">GREATERP</span>, <span class="string">" > "</span>, <span class="num">3</span>, <span class="func">SCMq_gtp</span>);

<span class="macro">SCM_DefineCPSsubrN</span>(<span class="func">SCMq_list</span>, <span class="func">SCM_list</span>)
<span class="macro">SCM_DefinePredefinedFunctionVariable</span>(<span class="var">LIST</span>, <span class="string">"LIST"</span>, <span class="num">-2</span>, <span class="func">SCMq_list</span>);</pre>


<!--\indexC{apply}-->
<!--\indexC*{SCM_apply}{SCM\_apply}-->
<p>Единственной проблемной функцией остаётся <code><span class="func">apply</span></code>.
Она использует протокол вызова напрямую, так что о появившихся продолжениях ей придётся
рассказывать лично:</p>

<pre class="c"><span class="type">SCM</span> <span class="func">SCMq_apply</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="var">number</span>, <span class="type">va_list</span> <span class="var">arguments</span>)
{
    <span class="type">unsigned</span> <span class="type">long</span> <span class="var">i</span>;
    <span class="type">SCM</span> <span class="var">args</span>[<span class="num">30</span>];
    <span class="type">SCM</span> <span class="var">last_arg</span>;
    <span class="type">SCM</span> <span class="var">k</span>   = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);
    <span class="type">SCM</span> <span class="var">fun</span> = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);

    <span class="keyword">for</span> (<span class="var">i</span> = <span class="num">0</span>; <span class="var">i</span> &lt; <span class="var">number</span> - <span class="num">2</span>; <span class="var">i</span>++) {
        <span class="var">args</span>[<span class="var">i</span>] = <span class="macro">va_arg</span>(<span class="var">arguments</span>, <span class="type">SCM</span>);
    }
    <span class="var">last_arg</span> = <span class="var">args</span>[--<span class="var">i</span>];
    <span class="keyword">while</span> (<span class="macro">SCM_PairP</span>(<span class="var">last_arg</span>)) {
        <span class="var">args</span>[<span class="var">i</span>++] = <span class="macro">SCM_Car</span>(<span class="var">last_arg</span>);
        <span class="var">last_arg</span> = <span class="macro">SCM_Cdr</span>(<span class="var">last_arg</span>);
    }
    <span class="keyword">if</span> (!<span class="macro">SCM_NullP</span>(<span class="var">last_arg</span>)) {
        <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_APPLY_ARG</span>);
    }

    <span class="keyword">switch</span> (<span class="var">i</span>) {
      <span class="keyword">case</span> <span class="num">0</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">1</span>, <span class="var">k</span>);
      <span class="keyword">case</span> <span class="num">1</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">2</span>, <span class="var">k</span>, <span class="var">args</span>[<span class="num">0</span>]);
      <span class="keyword">case</span> <span class="num">2</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">3</span>, <span class="var">k</span>, <span class="var">args</span>[<span class="num">0</span>], <span class="var">args</span>[<span class="num">1</span>]);
      <span class="keyword">case</span> <span class="num">3</span>: <span class="keyword">return</span> <span class="func">SCM_invoke</span>(<span class="var">fun</span>, <span class="num">3</span>, <span class="var">k</span>, <span class="var">args</span>[<span class="num">0</span>], <span class="var">args</span>[<span class="num">1</span>], <span class="var">args</span>[<span class="num">2</span>]);
      <span class="comment">/* ... */</span>
      <span class="keyword">default</span>: <span class="keyword">return</span> <span class="macro">SCM_error</span>(<span class="macro">SCM_ERR_APPLY_SIZE</span>);
    }
}</pre>


<h4 id="cc/call/cc/cc/ssect:example"><span class="wrap"><span class="title">Пример</span></span></h4>

<!--\indexR{компиляция!в Си}-->
<p>Давайте возьмём наш подопытный пример и посмотрим, что же выдаст новый
компилятор. Хоть мы и получаем в итоге код на Си, в нём безошибочно узнаётся
стиль передачи продолжений.</p>

<div class="snippet numbered" id="cc/call/cc/cc/example/src:subj">
  <span class="title">o/chap10kex.c</span>
<table class="numbered-source"><tr>
<td class="lines"><pre>



<span class="lineno">5</span>




<span class="lineno">10</span>




<span class="lineno">15</span>




<span class="lineno">20</span>




<span class="lineno">25</span>




<span class="lineno">30</span>




<span class="lineno">35</span>




<span class="lineno">40</span>




<span class="lineno">45</span>




<span class="lineno">50</span>




<span class="lineno">55</span>




<span class="lineno">60</span>




<span class="lineno">65</span>




<span class="lineno">70</span>




<span class="lineno">75</span>




<span class="lineno">80</span>




<span class="lineno">85</span>




<span class="lineno">90</span>




<span class="lineno">95</span>




<span class="lineno">100</span>




<span class="lineno">105</span>




<span class="lineno">110</span>




<span class="lineno">115</span>




<span class="lineno">120</span>




<span class="lineno">125</span>




<span class="lineno">130</span>




<span class="lineno">135</span>




<span class="lineno">140</span></pre></td>
<td><pre class="c"><span class="comment">/* Compiler to C $Revision: 4.1$
(BEGIN
  (SET! INDEX 1)
  ((LAMBDA
     (CNTER . TMP)
     (SET! TMP (CNTER (LAMBDA (I) (LAMBDA X (CONS I X)))))
     (IF CNTER (CNTER TMP) INDEX))
    (LAMBDA (F) (SET! INDEX (+ 1 INDEX)) (F INDEX))
    'FOO))
*/</span>

<span class="pre">#include</span> <span class="string">"scheme.h"</span>

<span class="comment">/* Global environment: */</span>
<span class="macro">SCM_DefineGlobalVariable</span>(<span class="var">INDEX</span>, <span class="string">"INDEX"</span>);

<span class="comment">/* Quotations: */</span>
<span class="pre">#define</span> <span class="macro">thing3</span> <span class="macro">SCM_nil</span>                      <span class="comment">/* () */</span>
<span class="macro">SCM_DefineString</span>(<span class="var">thing4_object</span>, <span class="string">"FOO"</span>);
<span class="pre">#define</span> <span class="macro">thing4</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing4_object</span>)
<span class="macro">SCM_DefineSymbol</span>(<span class="var">thing2_object</span>, <span class="macro">thing4</span>);    <span class="comment">/* FOO */</span>
<span class="pre">#define</span> <span class="macro">thing2</span> <span class="macro">SCM_Wrap</span>(&amp;<span class="var">thing2_object</span>)
<span class="pre">#define</span> <span class="macro">thing1</span> <span class="macro">SCM_Int2Fixnum</span>(<span class="num">1</span>)
<span class="pre">#define</span> <span class="macro">thing0</span> <span class="macro">thing1</span>                       <span class="comment">/* 1 */</span>

<span class="comment">/* Functions: */</span>
<span class="macro">SCM_DefineClosure</span>(<span class="type">function_0</span>, <span class="type">SCM</span> <span class="var">I</span>; );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_0</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">v_25</span>, <span class="num">0</span>);
    <span class="macro">SCM_DeclareLocalDottedVariable</span>(<span class="var">X</span>, <span class="num">1</span>);
    <span class="type">SCM</span> <span class="var">v_27</span>; <span class="type">SCM</span> <span class="var">v_26</span>;
    <span class="keyword">return</span> (<span class="var">v_26</span> = <span class="macro">SCM_Free</span>(<span class="var">I</span>),
            (<span class="var">v_27</span> = <span class="var">X</span>,
             <span class="macro">SCM_invoke1</span>(<span class="var">v_25</span>,
                         <span class="func">SCM_cons</span>(<span class="var">v_26</span>, <span class="var">v_27</span>))));
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_1</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_1</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">v_24</span>, <span class="num">0</span>);
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">I</span>, <span class="num">1</span>);
    <span class="keyword">return</span> <span class="macro">SCM_invoke1</span>(<span class="var">v_24</span>,
                       <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_0</span>),
                                 <span class="num">-2</span>, <span class="num">1</span>, <span class="var">I</span>));
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_2</span>, <span class="type">SCM</span> <span class="var">v_15</span>; <span class="type">SCM</span> <span class="var">CNTER</span>; <span class="type">SCM</span> <span class="var">TMP</span>; );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_2</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">v_21</span>, <span class="num">0</span>);
    <span class="type">SCM</span> <span class="var">v_20</span>; <span class="type">SCM</span> <span class="var">v_19</span>; <span class="type">SCM</span> <span class="var">v_18</span>; <span class="type">SCM</span> <span class="var">v_17</span>;
    <span class="keyword">return</span> (<span class="var">v_17</span> = (<span class="macro">SCM_Content</span>(<span class="macro">SCM_Free</span>(<span class="var">TMP</span>)) = <span class="var">v_21</span>),
            (<span class="var">v_18</span> = <span class="macro">SCM_Free</span>(<span class="var">CNTER</span>),
             ((<span class="var">v_18</span> != <span class="macro">SCM_false</span>)
              ? (<span class="var">v_19</span> = <span class="macro">SCM_Free</span>(<span class="var">CNTER</span>),
                 (<span class="var">v_20</span> = <span class="macro">SCM_Content</span>(<span class="macro">SCM_Free</span>(<span class="var">TMP</span>)),
                  <span class="macro">SCM_invoke2</span>(<span class="var">v_19</span>,
                              <span class="macro">SCM_Free</span>(<span class="var">v_15</span>),
                              <span class="var">v_20</span>)))
              : <span class="macro">SCM_invoke1</span>(<span class="macro">SCM_Free</span>(<span class="var">v_15</span>),
                            <span class="macro">SCM_CheckedGlobal</span>(<span class="var">INDEX</span>)))));
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_3</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_3</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">v_15</span>, <span class="num">0</span>);
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">CNTER</span>, <span class="num">1</span>);
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">TMP</span>, <span class="num">2</span>);
    <span class="type">SCM</span> <span class="var">v_23</span>; <span class="type">SCM</span> <span class="var">v_22</span>; <span class="type">SCM</span> <span class="var">v_16</span>;
    <span class="keyword">return</span> (<span class="var">v_16</span> = (<span class="var">TMP</span> = <span class="func">SCM_allocate_box</span>(<span class="var">TMP</span>)),
            (<span class="var">v_22</span> = <span class="var">CNTER</span>,
             (<span class="var">v_23</span> = <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_1</span>), <span class="num">2</span>, <span class="num">0</span>),
              <span class="macro">SCM_invoke2</span>(<span class="var">v_22</span>,
                          <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_2</span>),
                                    <span class="num">1</span>, <span class="num">3</span>, <span class="var">v_15</span>, <span class="var">CNTER</span>, <span class="var">TMP</span>),
                          <span class="var">v_23</span>))));
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_4</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_4</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">v_8</span>, <span class="num">0</span>);
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">F</span>, <span class="num">1</span>);
    <span class="type">SCM</span> <span class="var">v_11</span>; <span class="type">SCM</span> <span class="var">v_10</span>; <span class="type">SCM</span> <span class="var">v_9</span>; <span class="type">SCM</span> <span class="var">v_12</span>; <span class="type">SCM</span> <span class="var">v_14</span>; <span class="type">SCM</span> <span class="var">v_13</span>;
    <span class="keyword">return</span> (<span class="var">v_13</span> = <span class="macro">thing1</span>,
            (<span class="var">v_14</span> = <span class="macro">SCM_CheckedGlobal</span>(<span class="var">INDEX</span>),
             (<span class="var">v_12</span> = <span class="macro">SCM_Plus</span>(<span class="var">v_13</span>, <span class="var">v_14</span>),
              (<span class="var">v_9</span> = (<span class="var">INDEX</span> = <span class="var">v_12</span>),
               (<span class="var">v_10</span> = <span class="var">F</span>,
                (<span class="var">v_11</span> = <span class="macro">SCM_CheckedGlobal</span>(<span class="var">INDEX</span>),
                 <span class="macro">SCM_invoke2</span>(<span class="var">v_10</span>,
                             <span class="var">v_8</span>,
                             <span class="var">v_11</span>)))))));
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_5</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_5</span>)
{
    <span class="macro">SCM_DeclareLocalVariable</span>(<span class="var">v_1</span>, <span class="num">0</span>);
    <span class="keyword">return</span> <span class="var">v_1</span>;
}

<span class="macro">SCM_DefineClosure</span>(<span class="type">function_6</span>, );

<span class="macro">SCM_DeclareFunction</span>(<span class="func">function_6</span>)
{
    <span class="type">SCM</span> <span class="var">v_5</span>; <span class="type">SCM</span> <span class="var">v_7</span>; <span class="type">SCM</span> <span class="var">v_6</span>; <span class="type">SCM</span> <span class="var">v_4</span>; <span class="type">SCM</span> <span class="var">v_3</span>; <span class="type">SCM</span> <span class="var">v_2</span>; <span class="type">SCM</span> <span class="var">v_28</span>;
    <span class="keyword">return</span> (<span class="var">v_28</span> = <span class="macro">thing0</span>,
            (<span class="var">v_2</span> = (<span class="var">INDEX</span> = <span class="var">v_28</span>),
             (<span class="var">v_3</span> = <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_3</span>), <span class="num">3</span>, <span class="num">0</span>),
              (<span class="var">v_4</span> = <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_4</span>), <span class="num">2</span>, <span class="num">0</span>),
               (<span class="var">v_6</span> = <span class="macro">thing2</span>,
                (<span class="var">v_7</span> = <span class="macro">thing3</span>,
                 (<span class="var">v_5</span> = <span class="func">SCM_cons</span>(<span class="var">v_6</span>, <span class="var">v_7</span>),
                  <span class="macro">SCM_invoke3</span>(<span class="var">v_3</span>,
                              <span class="func">SCM_close</span>(<span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_5</span>),
                                        <span class="num">1</span>, <span class="num">0</span>),
                              <span class="var">v_4</span>,
                              <span class="var">v_5</span>))))))));
}

<span class="comment">/* Expression: */</span>
<span class="type">int</span> <span class="func">main</span>(<span class="type">void</span>)
{
    <span class="func">SCM_print</span>(<span class="macro">SCM_invoke0</span>(<span class="func">SCM_close</span>(
        <span class="macro">SCM_CfunctionAddress</span>(<span class="func">function_6</span>), <span class="num">0</span>, <span class="num">0</span>)));

    <span class="keyword">return</span> <span class="num">0</span>;
}

<span class="comment">/* End of generated code */</span></pre></td></tr></table></div>

<p>Как видите, размер получаемого файла вырос с 80 строк до 140. Функций стало
в два раза больше (шесть вместо трёх), да и локальных переменных им теперь
требуется не 2, а 22. Короче говоря, программа слегка растолстела. И работать
стала примерно в полтора раза медленнее. После того, как из
<code class="c"><span class="func">main</span></code> был убран
вызов <code class="c"><span class="func">SCM_print</span></code>, вычисления
обёрнуты в цикл на 10000 итераций, а
программа скомпилирована с ключом <code>-O1</code>, время работы CPS-версии по сравнению
с оригинальной увеличилось с 1,1 секунды до 1,7. Памяти обоим
вариантам требуется одинаковое количество, но в первом случае эта память берётся
из стека (где аппаратная поддержка и компилятор Си творят чудеса), тогда как
явные продолжения создаются в куче, что не только само по себе медленно, но и
плохо сказывается на работе кеша. Хотя, как показано в
<span class="cite">[<a href="z1_bibliography.html#as94">AS94</a>]</span>, от большей
части недостатков такого подхода вполне можно избавиться.</p>

<pre class="shell">
<span class="prompt">%</span> <span class="cmd">gcc</span> <span class="opt">-ansi</span> <span class="opt">-pedantic</span> <span class="arg">chap10kex.c</span> <span class="arg">scheme.o</span> <span class="arg">schemeklib.o</span>
<span class="prompt">%</span> <span class="cmd">time</span> <span class="arg">a.out</span>
(2 3)
0.000u 0.020s 0:00.00 0.0% 3+3k 0+0io 0pf+0w
<span class="prompt">%</span> <span class="cmd">size</span> <span class="arg">a.out</span>
text    data    bss     dec     hex
32768   4096    32      36896   9020</pre>


<!--\indexR{хвостовые вызовы}-->
<p>Рассмотренное преобразование само по себе никак не оптимизирует хвостовую
рекурсию, а значит, возможность переполнения стека никуда не делась. Фактически,
CPS даже усугубляет ситуацию тем, что здесь постоянно вызываются функции, но
ни одна из них никогда не возвращает значения. Функции вызываются, стек растёт,
но все <code class="c"><span class="keyword">return</span></code> выполняются последними, так что уменьшаться он будет лишь
в самом работы программы. Вряд ли не особо большой стек Си продержится до этого
момента. Одно из возможных решений показано в <span class="cite">[<a href="z1_bibliography.html#bak95">Bak95</a>]</span>: просто делать время
от времени <code class="c"><span class="func">longjmp</span></code>, чтобы избавиться от уже ненужных записей активаций.</p>


<h2 id="cc/sect:ffi"><span class="wrap"><span class="seq">10.12.</span><span class="title">Взаимодействие с Си</span></span></h2>

<!--\indexR{внешний интерфейс}-->
<p>Так как наш небольшой компилятор использует структуры и функции языка Си для
представления данных и программ, то генерируемый им код способен без особых
проблем взаимодействовать с другим кодом на Си. Наличие <em>внешнего
интерфейса</em> (foreign function interface) чрезвычайно важно для любого языка
программирования, так как это позволяет получить доступ к уже написанным
и отлаженным библиотекам на других языках. Особенно это касается языка Си,
являющегося стандартом де-факто на интерфейсы библиотек. Рассмотрим пример
использования подобного интерфейса, чтобы вы осознали его полезность, а также
трудности, возникающие в процессе реализации.</p>

<p>Стандартная функция <code class="c"><span class="func">system</span></code>
принимает строку, передаёт её командному
интерпретатору операционной системы и возвращает обратно код возврата,
полученный в результате выполнения команд из переданной строки. Предположим,
у нас есть макрос <code><span class="syntax">defforeignprimitive</span></code>,
позволяющий определить для
компилятора интерфейс этой функции:</p>

<!--\indexC{defforeignprimitive}-->
<pre>(<span class="syntax">defforeignprimitive</span> <span class="var">system</span> <span class="var">int</span> (<span class="string">"system"</span> <span class="var">string</span>) <span class="num">1</span>)</pre>

<!--\indexR{маршалинг}-->
<p>Теперь компилятор будет понимать форму <code>(<span class="func">system</span> <span class="math"><span class="ord var">π</span></span>)</code> следующим образом:
сначала выполняется проверка, что <span class="math"><span class="ord var">π</span></span> это действительно строка, затем
вызывается функция <code class="c"><span class="func">system</span></code>, после чего возвращённое ею значение
(типа <code class="c"><span class="type">int</span></code>) преобразуется в целое число Scheme и становится значением всей
формы. Так как строки Scheme и Си представляются почти одинаково, то это
преобразование выполняется легко, чего не скажешь, правда, о других возможных
типах данных. Проблемы <em class="term">маршалинга</em> (так называются данные преобразования)
подробнее рассматриваются в <span class="cite">[<a href="z1_bibliography.html#rm92">RM92</a>,
<a href="z1_bibliography.html#dps94a">DPS94a</a>]</span>.</p>

<p>Конечно, одних преобразований типов недостаточно для полной интеграции языков.
Функция <code><span class="func">system</span></code> должна стать полноценным объектом Scheme. Должно быть
возможным вызвать её с помощью <code><span class="func">apply</span></code> или, например, сохранить в переменной.
Всё это подразумевает существование некоторого класса значений, представляющих
внешние функции.</p>


<h2 id="cc/sect:conclusions"><span class="wrap"><span class="seq">10.13.</span><span class="title">Заключение</span></span></h2>

<p>В данной главе был рассмотрен компилятор из Scheme в Си. Мы написали собственную
библиотеку времени исполнения, но с равным успехом можно было использовать любую
другую, например, библиотеку Bigloo <span class="cite">[<a href="z1_bibliography.html#ser94">Ser94</a>]</span>, SIOD <span class="cite">[<a href="z1_bibliography.html#car94">Car94</a>]</span> или SCM
<span class="cite">[<a href="z1_bibliography.html#jaf94">Jaf94</a>]</span>. В процессе мы обсудили проблемы, возникающие при компиляции в язык
высокого уровня, различия между Scheme и Си, а также преимущества разумного
сотрудничества двух языков.</p>

<p>Читателю настоятельно рекомендуется сравнить полученный компилятор
с компилятором в байт-код. Кроме того, остаётся ещё множество других идей,
стоящих реализации, например:</p>

<ul>
  <li>использование <code><span class="func">read</span></code>
    для чтения и создания цитат;</li>

  <li>отказ от родного стека Си (и его протокола вызова функций)
    в пользу независимого стека, заточенного под Scheme;</li>

  <li>поддержка раздельной компиляции, модулей и т. д.
    <span class="see">[см. <a href="ch07_compilation.html">7 главу</a>]</span></li>
</ul>

<!--\indexR{раскрутка (bootstrapping)}-->
<!--\indexC{eval}-->
<!--\indexC{load}-->
<p>Также можно было бы оценить стоимость (в плане увеличения размера библиотеки и
уменьшения скорости работы) реализации динамических аспектов языка: функции
<code><span class="func">load</span></code> или её упрощённого аналога —
<code><span class="func">eval</span></code>. Пусть это останется
(трудным) упражнением для читателя. Для тех же, кто с ним справится, припасено
ещё одно: скомпилировать полученный компилятор самим собой.</p>


<h2 id="cc/sect:exercises"><span class="wrap"><span class="seq">10.14.</span><span class="title">Упражнения</span></span></h2>

<h5 class="exercise" id="cc/ex:boost-calls">Упражнение <span class="seq">10.1</span></h5>
<p>Вызовы замыканий можно ускорить, адаптировав для них протокол вызова
предопределённых примитивов с фиксированной арностью: то есть вызывать их как
<span class="math"><span class="ord var">f</span><span class="open">(</span><span class="ord var">f</span><span class="punct">,</span><span class="ord var">x</span><span class="punct">,</span><span class="ord var">y</span><span class="close">)</span></span>. Доработайте компилятор соответствующим образом.</p>


<h5 class="exercise" id="cc/ex:global-check">Упражнение <span class="seq">10.2</span></h5>
<!--\indexC*{SCM_CheckedGlobal}{SCM\_CheckedGlobal}-->
<p>Доступ к глобальным переменным был бы эффективнее, если бы при чтении не было
обязательных проверок на инициализированность, выполняемых
<code class="c"><span class="macro">SCM_CheckedGlobal</span></code>. Придумайте,
как выделить все переменные, для которых
эти проверки не требуются, потому что можно быть уверенным в том, что они уже
имеют некоторое значение.</p>


<h5 class="exercise">Проект <span class="seq">10.3</span></h5>

<p>Рассмотренный в этой главе компилятор преобразует дерево объектов в код
на процедурном языке Си. Адаптируйте его для генерации кода на
объектно-ориентированном Си++.</p>

<h5 class="exercise">Проект <span class="seq">10.4</span></h5>

<p>А теперь попробуйте написать компилятор в специализированный низкоуровневый
язык для кодогенерации — Си−−.</p>


<h2><span class="wrap"><span class="title">Рекомендуемая литература</span></span></h2>

<p>В последнее время наблюдается существенный интерес к компиляции языков высокого
уровня в низкоуровневый Си. Ницан Сеньяк отлично раскрыл эту тему в своей
диссертации <span class="cite">[<a href="z1_bibliography.html#sen91">Sén91</a>]</span>, равно как и Мануэль Серрано в статье <span class="cite">[<a href="z1_bibliography.html#ser93">Ser93</a>]</span>.
Если вы уже успели влюбиться по уши в подобный подход, то будьте осторожны
с исходным кодом Bigloo <span class="cite">[<a href="z1_bibliography.html#ser94">Ser94</a>]</span> — можно ведь и не вынырнуть!</p>

</div>
</div>

</body>
</html>
